{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compositesTypeMap = exports.coption = exports.coptionSome = exports.coptionNone = exports.isNoneBuffer = exports.isSomeBuffer = void 0;\nvar assert_1 = require(\"assert\");\nvar types_1 = require(\"../types\");\nvar types_2 = require(\"../types\");\nvar utils_1 = require(\"../utils\");\nvar beet_fixable_1 = require(\"../beet.fixable\");\nvar NONE = 0;\nvar SOME = 1;\n/**\n * @private\n */\nfunction isSomeBuffer(buf, offset) {\n  return buf[offset] === SOME;\n}\nexports.isSomeBuffer = isSomeBuffer;\n/**\n * @private\n */\nfunction isNoneBuffer(buf, offset) {\n  return buf[offset] === NONE;\n}\nexports.isNoneBuffer = isNoneBuffer;\n/**\n * De/Serializes `None` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `0`.\n * This matches the `COption::None` type borsh representation.\n *\n * @template T inner option type\n * @param description the description of the inner type\n *\n * @category beet/option\n */\nfunction coptionNone(description) {\n  (0, utils_1.logTrace)(\"coptionNone(\".concat(description, \")\"));\n  return {\n    write: function write(buf, offset, value) {\n      (0, assert_1.strict)(value == null, 'coptionNone can only handle `null` values');\n      buf[offset] = NONE;\n    },\n    read: function read(buf, offset) {\n      (0, assert_1.strict)(isNoneBuffer(buf, offset), 'coptionNone can only handle `NONE` data');\n      return null;\n    },\n    byteSize: 1,\n    description: \"COption<None(\".concat(description, \")>\")\n  };\n}\nexports.coptionNone = coptionNone;\n/**\n * De/Serializes `Some` case of an _Option_ of type {@link T} represented by\n * {@link COption}.\n *\n * The de/serialized type is prefixed with `1`.\n * This matches the `COption::Some` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nfunction coptionSome(inner) {\n  var byteSize = 1 + inner.byteSize;\n  var beet = {\n    write: function write(buf, offset, value) {\n      (0, types_1.assertFixedSizeBeet)(inner, \"coption inner type \".concat(inner.description, \" needs to be fixed before calling write\"));\n      (0, assert_1.strict)(value != null, 'coptionSome cannot handle `null` values');\n      buf[offset] = SOME;\n      inner.write(buf, offset + 1, value);\n    },\n    read: function read(buf, offset) {\n      (0, types_1.assertFixedSizeBeet)(inner, \"coption inner type \".concat(inner.description, \" needs to be fixed before calling read\"));\n      (0, assert_1.strict)(isSomeBuffer(buf, offset), 'coptionSome can only handle `SOME` data');\n      return inner.read(buf, offset + 1);\n    },\n    description: \"COption<\".concat(inner.description, \">[1 + \").concat(inner.byteSize, \"]\"),\n    byteSize: byteSize,\n    inner: inner\n  };\n  (0, utils_1.logTrace)(beet.description);\n  return beet;\n}\nexports.coptionSome = coptionSome;\n/**\n * De/Serializes an _Option_ of type {@link T} represented by {@link COption}.\n *\n * The de/serialized type is prefixed with `1` if the inner value is present\n * and with `0` if not.\n * This matches the `COption` type borsh representation.\n *\n * @template T inner option type\n * @param inner the De/Serializer for the inner type\n *\n * @category beet/composite\n */\nfunction coption(inner) {\n  return {\n    toFixedFromData: function toFixedFromData(buf, offset) {\n      if (isSomeBuffer(buf, offset)) {\n        var innerFixed = (0, beet_fixable_1.fixBeetFromData)(inner, buf, offset + 1);\n        return coptionSome(innerFixed);\n      } else {\n        (0, assert_1.strict)(isNoneBuffer(buf, offset), \"Expected \".concat(buf, \" to hold a COption\"));\n        return coptionNone(inner.description);\n      }\n    },\n    toFixedFromValue: function toFixedFromValue(val) {\n      return val == null ? coptionNone(inner.description) : coptionSome((0, beet_fixable_1.fixBeetFromValue)(inner, val));\n    },\n    description: \"COption<\".concat(inner.description, \">\")\n  };\n}\nexports.coption = coption;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.compositesTypeMap = {\n  option: {\n    beet: 'coption',\n    isFixable: true,\n    sourcePack: types_2.BEET_PACKAGE,\n    ts: 'COption<Inner>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_2.BEET_PACKAGE\n  }\n};","map":{"version":3,"mappings":"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","names":["NONE","SOME","isSomeBuffer","buf","offset","exports","isNoneBuffer","coptionNone","description","write","value","read","byteSize","coptionSome","inner","beet","coption","toFixedFromData","innerFixed","toFixedFromValue","val","option","isFixable","sourcePack","types_2","ts","arg","types_1","pack"],"sources":["../../../../src/beets/composites.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}