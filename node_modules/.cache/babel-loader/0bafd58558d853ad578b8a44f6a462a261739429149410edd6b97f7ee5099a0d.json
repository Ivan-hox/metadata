{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unpackAccount = exports.getMinimumBalanceForRentExemptAccountWithExtensions = exports.getMinimumBalanceForRentExemptAccount = exports.getMultipleAccounts = exports.getAccount = exports.ACCOUNT_SIZE = exports.AccountLayout = exports.AccountState = void 0;\nvar buffer_layout_1 = require(\"@solana/buffer-layout\");\nvar buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nvar constants_js_1 = require(\"../constants.js\");\nvar errors_js_1 = require(\"../errors.js\");\nvar accountType_js_1 = require(\"../extensions/accountType.js\");\nvar extensionType_js_1 = require(\"../extensions/extensionType.js\");\nvar multisig_js_1 = require(\"./multisig.js\");\n/** Token account state as stored by the program */\nvar AccountState;\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState = exports.AccountState || (exports.AccountState = {}));\n/** Buffer layout for de/serializing a token account */\nexports.AccountLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_utils_1.publicKey)('mint'), (0, buffer_layout_utils_1.publicKey)('owner'), (0, buffer_layout_utils_1.u64)('amount'), (0, buffer_layout_1.u32)('delegateOption'), (0, buffer_layout_utils_1.publicKey)('delegate'), (0, buffer_layout_1.u8)('state'), (0, buffer_layout_1.u32)('isNativeOption'), (0, buffer_layout_utils_1.u64)('isNative'), (0, buffer_layout_utils_1.u64)('delegatedAmount'), (0, buffer_layout_1.u32)('closeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('closeAuthority')]);\n/** Byte length of a token account */\nexports.ACCOUNT_SIZE = exports.AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nfunction getAccount(connection, address, commitment) {\n  var programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_js_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var info;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return connection.getAccountInfo(address, commitment);\n          case 2:\n            info = _context.sent;\n            return _context.abrupt(\"return\", unpackAccount(address, info, programId));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexports.getAccount = getAccount;\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nfunction getMultipleAccounts(connection, addresses, commitment) {\n  var programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_js_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var infos;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return connection.getMultipleAccountsInfo(addresses, commitment);\n          case 2:\n            infos = _context2.sent;\n            return _context2.abrupt(\"return\", addresses.map(function (address, i) {\n              return unpackAccount(address, infos[i], programId);\n            }));\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\nexports.getMultipleAccounts = getMultipleAccounts;\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n          case 2:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\nexports.getMinimumBalanceForRentExemptAccount = getMinimumBalanceForRentExemptAccount;\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptAccountWithExtensions(connection, extensions, commitment) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var accountLen;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            accountLen = (0, extensionType_js_1.getAccountLen)(extensions);\n            _context4.next = 3;\n            return connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n          case 3:\n            return _context4.abrupt(\"return\", _context4.sent);\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\nexports.getMinimumBalanceForRentExemptAccountWithExtensions = getMinimumBalanceForRentExemptAccountWithExtensions;\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nfunction unpackAccount(address, info) {\n  var programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_js_1.TOKEN_PROGRAM_ID;\n  if (!info) throw new errors_js_1.TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new errors_js_1.TokenInvalidAccountOwnerError();\n  if (info.data.length < exports.ACCOUNT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n  var rawAccount = exports.AccountLayout.decode(info.data.slice(0, exports.ACCOUNT_SIZE));\n  var tlvData = Buffer.alloc(0);\n  if (info.data.length > exports.ACCOUNT_SIZE) {\n    if (info.data.length === multisig_js_1.MULTISIG_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data[exports.ACCOUNT_SIZE] != accountType_js_1.AccountType.Account) throw new errors_js_1.TokenInvalidAccountError();\n    tlvData = info.data.slice(exports.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address: address,\n    mint: rawAccount.mint,\n    owner: rawAccount.owner,\n    amount: rawAccount.amount,\n    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n    delegatedAmount: rawAccount.delegatedAmount,\n    isInitialized: rawAccount.state !== AccountState.Uninitialized,\n    isFrozen: rawAccount.state === AccountState.Frozen,\n    isNative: !!rawAccount.isNativeOption,\n    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    tlvData: tlvData\n  };\n}\nexports.unpackAccount = unpackAccount;","map":{"version":3,"mappings":"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","names":["AccountState","exports","span","getAccount","connection","address","commitment","programId","constants_js_1","getAccountInfo","info","unpackAccount","getMultipleAccounts","addresses","getMultipleAccountsInfo","infos","map","i","getMinimumBalanceForRentExemptAccount","getMinimumBalanceForRentExemptAccountWithExtensions","extensions","accountLen","getMinimumBalanceForRentExemption","errors_js_1","owner","equals","data","length","rawAccount","decode","slice","tlvData","Buffer","alloc","multisig_js_1","accountType_js_1","Account","mint","amount","delegate","delegateOption","delegatedAmount","isInitialized","state","Uninitialized","isFrozen","Frozen","isNative","isNativeOption","rentExemptReserve","closeAuthority","closeAuthorityOption"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/state/account.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getAccountLen } from '../extensions/extensionType.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n    tlvData: Buffer;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackAccount(address, info, programId);\n}\n\n/**\n * Retrieve information about multiple token accounts in a single RPC call\n *\n * @param connection Connection to use\n * @param addresses  Token accounts\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getMultipleAccounts(\n    connection: Connection,\n    addresses: PublicKey[],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Account[]> {\n    const infos = await connection.getMultipleAccountsInfo(addresses, commitment);\n    return addresses.map((address, i) => unpackAccount(address, infos[i], programId));\n}\n\n/** Get the minimum lamport balance for a base token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptAccountWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt token account with extensions\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccountWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment\n): Promise<number> {\n    const accountLen = getAccountLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(accountLen, commitment);\n}\n\n/**\n * Unpack a token account\n *\n * @param address   Token account\n * @param info      Token account data\n * @param programId SPL Token program account\n *\n * @return Unpacked token account\n */\nexport function unpackAccount(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID\n): Account {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data.slice(0, ACCOUNT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > ACCOUNT_SIZE) {\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Account) throw new TokenInvalidAccountError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n        tlvData,\n    };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}