{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoOutput = void 0;\nvar CryptoECKey_1 = require(\"./CryptoECKey\");\nvar CryptoHDKey_1 = require(\"./CryptoHDKey\");\nvar lib_1 = require(\"./lib\");\nvar MultiKey_1 = require(\"./MultiKey\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar ScriptExpression_1 = require(\"./ScriptExpression\");\nvar CryptoOutput = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoOutput, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoOutput);\n  function CryptoOutput(scriptExpressions, cryptoKey) {\n    var _this;\n    _classCallCheck(this, CryptoOutput);\n    _this = _super.call(this);\n    _this.scriptExpressions = scriptExpressions;\n    _this.cryptoKey = cryptoKey;\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_OUTPUT;\n    };\n    _this.getCryptoKey = function () {\n      return _this.cryptoKey;\n    };\n    _this.getHDKey = function () {\n      if (_this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {\n        return _this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    _this.getECKey = function () {\n      if (_this.cryptoKey instanceof CryptoECKey_1.CryptoECKey) {\n        return _this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    _this.getMultiKey = function () {\n      if (_this.cryptoKey instanceof MultiKey_1.MultiKey) {\n        return _this.cryptoKey;\n      } else {\n        return undefined;\n      }\n    };\n    _this.getScriptExpressions = function () {\n      return _this.scriptExpressions;\n    };\n    _this._toOutputDescriptor = function (seIndex) {\n      if (seIndex >= _this.scriptExpressions.length) {\n        return _this.cryptoKey.getOutputDescriptorContent();\n      } else {\n        return \"\".concat(_this.scriptExpressions[seIndex].getExpression(), \"(\").concat(_this._toOutputDescriptor(seIndex + 1), \")\");\n      }\n    };\n    _this.toString = function () {\n      return _this._toOutputDescriptor(0);\n    };\n    _this.toDataItem = function () {\n      var dataItem = _this.cryptoKey.toDataItem();\n      if (_this.cryptoKey instanceof CryptoECKey_1.CryptoECKey || _this.cryptoKey instanceof CryptoHDKey_1.CryptoHDKey) {\n        dataItem.setTag(_this.cryptoKey.getRegistryType().getTag());\n      }\n      var clonedSe = _toConsumableArray(_this.scriptExpressions);\n      clonedSe.reverse().forEach(function (se) {\n        var tagValue = se.getTag();\n        if (dataItem.getTag() === undefined) {\n          dataItem.setTag(tagValue);\n        } else {\n          dataItem = new lib_1.DataItem(dataItem, tagValue);\n        }\n      });\n      return dataItem;\n    };\n    return _this;\n  }\n  return _createClass(CryptoOutput);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoOutput = CryptoOutput;\nCryptoOutput.fromDataItem = function (dataItem) {\n  var scriptExpressions = [];\n  var _dataItem = dataItem;\n  while (true) {\n    var _tag = _dataItem.getTag();\n    var se = ScriptExpression_1.ScriptExpression.fromTag(_tag);\n    if (se) {\n      scriptExpressions.push(se);\n      if (_dataItem.getData() instanceof lib_1.DataItem) {\n        _dataItem = _dataItem.getData();\n        _tag = _dataItem.getTag();\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n  var seLength = scriptExpressions.length;\n  var isMultiKey = seLength > 0 && (scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.MULTISIG.getExpression() || scriptExpressions[seLength - 1].getExpression() === ScriptExpression_1.ScriptExpressions.SORTED_MULTISIG.getExpression());\n  if (isMultiKey) {\n    var multiKey = MultiKey_1.MultiKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, multiKey);\n  }\n  if (_dataItem.getTag() === RegistryType_1.RegistryTypes.CRYPTO_HDKEY.getTag()) {\n    var cryptoHDKey = CryptoHDKey_1.CryptoHDKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, cryptoHDKey);\n  } else {\n    var cryptoECKey = CryptoECKey_1.CryptoECKey.fromDataItem(_dataItem);\n    return new CryptoOutput(scriptExpressions, cryptoECKey);\n  }\n};\nCryptoOutput.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoOutput.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["CryptoOutput","scriptExpressions","cryptoKey","RegistryType_1","CRYPTO_OUTPUT","CryptoHDKey_1","undefined","CryptoECKey_1","MultiKey_1","seIndex","length","getOutputDescriptorContent","getExpression","_toOutputDescriptor","dataItem","toDataItem","setTag","getRegistryType","getTag","clonedSe","reverse","forEach","se","tagValue","lib_1","RegistryItem_1","exports","_dataItem","_tag","ScriptExpression_1","fromTag","push","getData","seLength","isMultiKey","MULTISIG","SORTED_MULTISIG","multiKey","fromDataItem","CRYPTO_HDKEY","cryptoHDKey","cryptoECKey","_cborPayload"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoOutput.ts"],"sourcesContent":["import { CryptoECKey } from './CryptoECKey';\nimport { CryptoHDKey } from './CryptoHDKey';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { MultiKey } from './MultiKey';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { ScriptExpression, ScriptExpressions } from './ScriptExpression';\n\nexport class CryptoOutput extends RegistryItem {\n  public getRegistryType = () => {\n    return RegistryTypes.CRYPTO_OUTPUT;\n  };\n\n  constructor(\n    private scriptExpressions: ScriptExpression[],\n    private cryptoKey: CryptoHDKey | CryptoECKey | MultiKey,\n  ) {\n    super();\n  }\n\n  public getCryptoKey = () => this.cryptoKey;\n  public getHDKey = () => {\n    if (this.cryptoKey instanceof CryptoHDKey) {\n      return this.cryptoKey as CryptoHDKey;\n    } else {\n      return undefined;\n    }\n  };\n  public getECKey = () => {\n    if (this.cryptoKey instanceof CryptoECKey) {\n      return this.cryptoKey as CryptoECKey;\n    } else {\n      return undefined;\n    }\n  };\n\n  public getMultiKey = () => {\n    if (this.cryptoKey instanceof MultiKey) {\n      return this.cryptoKey as MultiKey;\n    } else {\n      return undefined;\n    }\n  };\n\n  public getScriptExpressions = () => this.scriptExpressions;\n\n  private _toOutputDescriptor = (seIndex: number): string => {\n    if (seIndex >= this.scriptExpressions.length) {\n      return this.cryptoKey.getOutputDescriptorContent();\n    } else {\n      return `${this.scriptExpressions[seIndex].getExpression()}(${this._toOutputDescriptor(seIndex + 1)})`;\n    }\n  };\n\n  public override toString = () => {\n    return this._toOutputDescriptor(0);\n  };\n\n  toDataItem = () => {\n    let dataItem = this.cryptoKey.toDataItem();\n    if (\n      this.cryptoKey instanceof CryptoECKey ||\n      this.cryptoKey instanceof CryptoHDKey\n    ) {\n      dataItem.setTag(this.cryptoKey.getRegistryType().getTag());\n    }\n\n    const clonedSe = [...this.scriptExpressions];\n\n    clonedSe.reverse().forEach((se) => {\n      const tagValue = se.getTag();\n      if (dataItem.getTag() === undefined) {\n        dataItem.setTag(tagValue);\n      } else {\n        dataItem = new DataItem(dataItem, tagValue);\n      }\n    });\n\n    return dataItem;\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const scriptExpressions: ScriptExpression[] = [];\n    let _dataItem = dataItem;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let _tag = _dataItem.getTag();\n      const se = ScriptExpression.fromTag(_tag as number);\n      if (se) {\n        scriptExpressions.push(se);\n        if (_dataItem.getData() instanceof DataItem) {\n          _dataItem = _dataItem.getData();\n          _tag = _dataItem.getTag();\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    const seLength = scriptExpressions.length;\n    const isMultiKey =\n      seLength > 0 &&\n      (scriptExpressions[seLength - 1].getExpression() ===\n        ScriptExpressions.MULTISIG.getExpression() ||\n        scriptExpressions[seLength - 1].getExpression() ===\n        ScriptExpressions.SORTED_MULTISIG.getExpression());\n    //TODO: judge is multi key by scriptExpressions\n    if (isMultiKey) {\n      const multiKey = MultiKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, multiKey);\n    }\n\n    if (_dataItem.getTag() === RegistryTypes.CRYPTO_HDKEY.getTag()) {\n      const cryptoHDKey = CryptoHDKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, cryptoHDKey);\n    } else {\n      const cryptoECKey = CryptoECKey.fromDataItem(_dataItem);\n      return new CryptoOutput(scriptExpressions, cryptoECKey);\n    }\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoOutput.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}