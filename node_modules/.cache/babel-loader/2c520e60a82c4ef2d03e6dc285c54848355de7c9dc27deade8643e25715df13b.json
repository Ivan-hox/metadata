{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setsTypeMap = exports.set = void 0;\nvar types_1 = require(\"../types\");\nvar numbers_1 = require(\"./numbers\");\nvar utils_1 = require(\"../utils\");\nvar assert_1 = require(\"assert\");\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}.\n *\n * NOTE: that it is not exported as no fixed size set exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the De/Serializers for the key element types\n * @param len amount of entries in the set\n *\n * @category beet/composite\n * @private\n */\nfunction fixedSizeSet(keyElement, fixedElements, len) {\n  var keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  function determineSizes() {\n    if (keyElementFixed) {\n      var _elementByteSize = keyElement.byteSize;\n      return {\n        elementByteSize: _elementByteSize,\n        byteSize: 4 + len * _elementByteSize\n      };\n    } else {\n      var keysByteSize = 0;\n      var _iterator = _createForOfIteratorHelper(fixedElements.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var k = _step.value;\n          keysByteSize += k.byteSize;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _elementByteSize2 = Math.ceil(keysByteSize / len);\n      return {\n        elementByteSize: _elementByteSize2,\n        byteSize: 4 + keysByteSize\n      };\n    }\n  }\n  var _determineSizes = determineSizes(),\n    elementByteSize = _determineSizes.elementByteSize,\n    byteSize = _determineSizes.byteSize;\n  return {\n    write: function write(buf, offset, set) {\n      // Write the values first and then the size as it comes clear while we do the former\n      var cursor = offset + 4;\n      var size = 0;\n      var _iterator2 = _createForOfIteratorHelper(set.keys()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var k = _step2.value;\n          var fixedKey = keyElementFixed ? keyElement : null;\n          if (fixedKey == null) {\n            // When we write the value we know the key and an just pull the\n            // matching fixed beet for key from the provided set which is\n            // faster than fixing it by value\n            var el = fixedElements.get(k);\n            (0, assert_1.strict)(el != null, \"Should be able to find beet el for \".concat((0, utils_1.stringify)(k), \", but could not\"));\n            fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = el;\n          }\n          fixedKey.write(buf, cursor, k);\n          cursor += fixedKey.byteSize;\n          size++;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      numbers_1.u32.write(buf, offset, size);\n      assert_1.strict.equal(size, len, \"Expected set to have size \".concat(len, \", but has \").concat(size, \".\"));\n    },\n    read: function read(buf, offset) {\n      var size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, len, \"Expected set to have size \".concat(len, \", but has \").concat(size, \".\"));\n      var cursor = offset + 4;\n      var set = new Set();\n      for (var i = 0; i < size; i++) {\n        // When we read the value from a buffer we don't know the key we're\n        // reading yet and thus cannot use the provided set of fixed\n        // de/serializers.\n        // Therefore we obtain it by fixing it by data instead.\n        var fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        var k = fixedKey.read(buf, cursor);\n        cursor += fixedKey.byteSize;\n        set.add(k);\n      }\n      return set;\n    },\n    elementByteSize: elementByteSize,\n    byteSize: byteSize,\n    length: len,\n    lenPrefixByteSize: 4,\n    description: \"Set<\".concat(keyElement.description, \">\")\n  };\n}\n/**\n * De/Serializes a set with a specific number of keys of type {@link K}\n *\n * @template K type of key elements held in the set\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n *\n * @category beet/composite\n */\nfunction set(keyElement) {\n  var keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  return {\n    toFixedFromData: function toFixedFromData(buf, offset) {\n      var len = numbers_1.u32.read(buf, offset);\n      var cursor = offset + 4;\n      // Shortcut for the case that both key and value are fixed size beets\n      if (keyIsFixed) {\n        return fixedSizeSet(keyElement, new Map(), len);\n      }\n      // If key is not fixed size beet we need to determine the fixed versions and add them to a set by key\n      var fixedBeets = new Map();\n      for (var i = 0; i < len; i++) {\n        var keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        var key = keyFixed.read(buf, cursor);\n        cursor += keyFixed.byteSize;\n        fixedBeets.set(key, keyFixed);\n      }\n      return fixedSizeSet(keyElement, fixedBeets, len);\n    },\n    toFixedFromValue: function toFixedFromValue(setVal) {\n      var len = setVal.size;\n      // As above shortcut for the optimal case and build a set for all others\n      if (keyIsFixed) {\n        return fixedSizeSet(keyElement, new Map(), len);\n      }\n      var fixedBeets = new Map();\n      var _iterator3 = _createForOfIteratorHelper(setVal),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var k = _step3.value;\n          var keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);\n          fixedBeets.set(k, keyFixed);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return fixedSizeSet(keyElement, fixedBeets, len);\n    },\n    description: \"FixableSet<\".concat(keyElement.description, \">\")\n  };\n}\nexports.set = set;\n/**\n * Sets sets beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.setsTypeMap = {\n  Set: {\n    beet: 'set',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'Set'\n  }\n};","map":{"version":3,"mappings":"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","names":["fixedSizeSet","keyElement","fixedElements","len","keyElementFixed","determineSizes","elementByteSize","byteSize","keysByteSize","values","k","Math","ceil","write","buf","offset","set","cursor","size","keys","fixedKey","el","get","numbers_1","assert_1","equal","read","Set","i","toFixedFromData","add","length","lenPrefixByteSize","description","keyIsFixed","Map","fixedBeets","keyFixed","key","toFixedFromValue","setVal","exports","beet","isFixable","sourcePack","types_1","ts"],"sources":["../../../../src/beets/sets.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}