{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BeetReader = exports.BeetWriter = void 0;\nvar assert_1 = require(\"assert\");\n/**\n * Underlying writer used to serialize structs.\n *\n * @private\n * @category beet/struct\n */\nvar BeetWriter = /*#__PURE__*/function () {\n  function BeetWriter(byteSize) {\n    _classCallCheck(this, BeetWriter);\n    this.buf = Buffer.alloc(byteSize);\n    this._offset = 0;\n  }\n  _createClass(BeetWriter, [{\n    key: \"buffer\",\n    get: function get() {\n      return this.buf;\n    }\n  }, {\n    key: \"offset\",\n    get: function get() {\n      return this._offset;\n    }\n  }, {\n    key: \"maybeResize\",\n    value: function maybeResize(bytesNeeded) {\n      if (this._offset + bytesNeeded > this.buf.length) {\n        assert_1.strict.fail(\"We shouldn't ever need to resize, but \".concat(this._offset + bytesNeeded, \" > \").concat(this.buf.length));\n        // this.buf = Buffer.concat([this.buf, Buffer.alloc(this.allocateBytes)])\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(beet, value) {\n      this.maybeResize(beet.byteSize);\n      beet.write(this.buf, this._offset, value);\n      this._offset += beet.byteSize;\n    }\n  }, {\n    key: \"writeStruct\",\n    value: function writeStruct(instance, fields) {\n      var _iterator = _createForOfIteratorHelper(fields),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            key = _step$value[0],\n            beet = _step$value[1];\n          var value = instance[key];\n          this.write(beet, value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n  return BeetWriter;\n}();\nexports.BeetWriter = BeetWriter;\n/**\n * Underlying reader used to deserialize structs.\n *\n * @private\n * @category beet/struct\n */\nvar BeetReader = /*#__PURE__*/function () {\n  function BeetReader(buffer) {\n    var _offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    _classCallCheck(this, BeetReader);\n    this.buffer = buffer;\n    this._offset = _offset;\n  }\n  _createClass(BeetReader, [{\n    key: \"offset\",\n    get: function get() {\n      return this._offset;\n    }\n  }, {\n    key: \"read\",\n    value: function read(beet) {\n      var value = beet.read(this.buffer, this._offset);\n      this._offset += beet.byteSize;\n      return value;\n    }\n  }, {\n    key: \"readStruct\",\n    value: function readStruct(fields) {\n      var acc = {};\n      var _iterator2 = _createForOfIteratorHelper(fields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            key = _step2$value[0],\n            beet = _step2$value[1];\n          acc[key] = this.read(beet);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return acc;\n    }\n  }]);\n  return BeetReader;\n}();\nexports.BeetReader = BeetReader;","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AAGA;;;;;;AAAA,IAMaA,UAAU;EAGrB,oBAAYC,QAAgB;IAAA;IAC1B,IAAI,CAACC,GAAG,GAAGC,MAAM,CAACC,KAAK,CAACH,QAAQ,CAAC;IACjC,IAAI,CAACI,OAAO,GAAG,CAAC;EAClB;EAAC;IAAA;IAAA,KAED,eAAU;MACR,OAAO,IAAI,CAACH,GAAG;IACjB;EAAC;IAAA;IAAA,KAED,eAAU;MACR,OAAO,IAAI,CAACG,OAAO;IACrB;EAAC;IAAA;IAAA,OAEO,qBAAYC,WAAmB;MACrC,IAAI,IAAI,CAACD,OAAO,GAAGC,WAAW,GAAG,IAAI,CAACJ,GAAG,CAACK,MAAM,EAAE;QAChDC,eAAM,CAACC,IAAI,iDAEP,IAAI,CAACJ,OAAO,GAAGC,WACjB,gBAAM,IAAI,CAACJ,GAAG,CAACK,MAAM,EACtB;QACD;;IAEJ;EAAC;IAAA;IAAA,OAED,eAASG,IAAsB,EAAEC,KAAQ;MACvC,IAAI,CAACC,WAAW,CAACF,IAAI,CAACT,QAAQ,CAAC;MAC/BS,IAAI,CAACG,KAAK,CAAC,IAAI,CAACX,GAAG,EAAE,IAAI,CAACG,OAAO,EAAEM,KAAK,CAAC;MACzC,IAAI,CAACN,OAAO,IAAIK,IAAI,CAACT,QAAQ;IAC/B;EAAC;IAAA;IAAA,OAED,qBAAea,QAAW,EAAEC,MAA2B;MAAA,2CAC3BA,MAAM;QAAA;MAAA;QAAhC,oDAAkC;UAAA;YAAtBC,GAAG;YAAEN,IAAI;UACnB,IAAMC,KAAK,GAAGG,QAAQ,CAACE,GAAG,CAAC;UAC3B,IAAI,CAACH,KAAK,CAACH,IAAI,EAAEC,KAAK,CAAC;;MACxB;QAAA;MAAA;QAAA;MAAA;IACH;EAAC;EAAA;AAAA;AAtCHM;AAyCA;;;;;;AAAA,IAMaC,UAAU;EACrB,oBAA6BC,MAAc,EAA6B;IAAA,IAAnBd,8EAAkB,CAAC;IAAA;IAA3C,WAAM,GAANc,MAAM;IAAkB,YAAO,GAAPd,OAAO;EAAe;EAAC;IAAA;IAAA,KAE5E,eAAU;MACR,OAAO,IAAI,CAACA,OAAO;IACrB;EAAC;IAAA;IAAA,OAED,cAAQK,IAAsB;MAC5B,IAAMC,KAAK,GAAGD,IAAI,CAACU,IAAI,CAAC,IAAI,CAACD,MAAM,EAAE,IAAI,CAACd,OAAO,CAAC;MAClD,IAAI,CAACA,OAAO,IAAIK,IAAI,CAACT,QAAQ;MAC7B,OAAOU,KAAK;IACd;EAAC;IAAA;IAAA,OAED,oBAAcI,MAA2B;MACvC,IAAMM,GAAG,GAAS,EAAE;MAAA,4CACMN,MAAM;QAAA;MAAA;QAAhC,uDAAkC;UAAA;YAAtBC,GAAG;YAAEN,IAAI;UACnBW,GAAG,CAACL,GAAG,CAAC,GAAG,IAAI,CAACI,IAAI,CAACV,IAAI,CAAC;;MAC3B;QAAA;MAAA;QAAA;MAAA;MACD,OAAOW,GAAG;IACZ;EAAC;EAAA;AAAA;AAnBHJ","names":["BeetWriter","byteSize","buf","Buffer","alloc","_offset","bytesNeeded","length","assert_1","fail","beet","value","maybeResize","write","instance","fields","key","exports","BeetReader","buffer","read","acc"],"sources":["../../../src/read-write.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}