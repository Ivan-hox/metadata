{"ast":null,"code":"import _objectSpread from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\nexport var WalletConnectChainID;\n(function (WalletConnectChainID) {\n  WalletConnectChainID[\"Mainnet\"] = \"solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ\";\n  WalletConnectChainID[\"Devnet\"] = \"solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K\";\n})(WalletConnectChainID || (WalletConnectChainID = {}));\nexport var WalletConnectRPCMethods;\n(function (WalletConnectRPCMethods) {\n  WalletConnectRPCMethods[\"signTransaction\"] = \"solana_signTransaction\";\n  WalletConnectRPCMethods[\"signMessage\"] = \"solana_signMessage\";\n})(WalletConnectRPCMethods || (WalletConnectRPCMethods = {}));\nvar getConnectParams = function getConnectParams(chainId, pairingTopic) {\n  return {\n    requiredNamespaces: {\n      solana: {\n        chains: [chainId],\n        methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n        events: []\n      }\n    },\n    pairingTopic: pairingTopic\n  };\n};\nexport var WalletConnectWallet = /*#__PURE__*/function () {\n  function WalletConnectWallet(config) {\n    _classCallCheck(this, WalletConnectWallet);\n    this._options = config.options;\n    this._network = config.network;\n  }\n  _createClass(WalletConnectWallet, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this$_client,\n          _this = this;\n        var client, sessions, _yield$client$connect, uri, approval;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!((_this$_client = this._client) !== null && _this$_client !== void 0)) {\n                  _context.next = 4;\n                  break;\n                }\n                _context.t0 = _this$_client;\n                _context.next = 7;\n                break;\n              case 4:\n                _context.next = 6;\n                return WalletConnectClient.init(this._options);\n              case 6:\n                _context.t0 = _context.sent;\n              case 7:\n                client = _context.t0;\n                sessions = client.find(getConnectParams(this._network)).filter(function (s) {\n                  return s.acknowledged;\n                });\n                if (!sessions.length) {\n                  _context.next = 15;\n                  break;\n                }\n                // select last matching session\n                this._session = sessions[sessions.length - 1];\n                // We assign this variable only after we're sure we've received approval\n                this._client = client;\n                return _context.abrupt(\"return\", {\n                  publicKey: this.publicKey\n                });\n              case 15:\n                _context.next = 17;\n                return client.connect(getConnectParams(this._network));\n              case 17:\n                _yield$client$connect = _context.sent;\n                uri = _yield$client$connect.uri;\n                approval = _yield$client$connect.approval;\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (uri) {\n                    QRCodeModal.open(uri, function () {\n                      reject(new QRCodeModalError());\n                    });\n                  }\n                  approval().then(function (session) {\n                    _this._session = session;\n                    // We assign this variable only after we're sure we've received approval\n                    _this._client = client;\n                    resolve({\n                      publicKey: _this.publicKey\n                    });\n                  }).catch(reject).finally(function () {\n                    QRCodeModal.close();\n                  });\n                }));\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._client && this._session)) {\n                  _context2.next = 6;\n                  break;\n                }\n                _context2.next = 3;\n                return this._client.disconnect({\n                  topic: this._session.topic,\n                  reason: getSdkError('USER_DISCONNECTED')\n                });\n              case 3:\n                this._session = undefined;\n                _context2.next = 7;\n                break;\n              case 6:\n                throw new ClientNotInitializedError();\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n      return disconnect;\n    }()\n  }, {\n    key: \"client\",\n    get: function get() {\n      if (this._client) {\n        // TODO: using client.off throws an error\n        return Object.assign({}, this._client, {\n          off: this._client.removeListener\n        });\n        // return this._client;\n      } else {\n        throw new ClientNotInitializedError();\n      }\n    }\n  }, {\n    key: \"publicKey\",\n    get: function get() {\n      if (this._client && this._session) {\n        var _parseAccountId = parseAccountId(this._session.namespaces.solana.accounts[0]),\n          address = _parseAccountId.address;\n        return new PublicKey(address);\n      } else {\n        throw new ClientNotInitializedError();\n      }\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(transaction) {\n        var _yield$this$_client$r, signature;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this._client && this._session)) {\n                  _context3.next = 9;\n                  break;\n                }\n                _context3.next = 3;\n                return this._client.request({\n                  chainId: this._network,\n                  topic: this._session.topic,\n                  request: {\n                    method: WalletConnectRPCMethods.signTransaction,\n                    params: _objectSpread({}, transaction)\n                  }\n                });\n              case 3:\n                _yield$this$_client$r = _context3.sent;\n                signature = _yield$this$_client$r.signature;\n                transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n                return _context3.abrupt(\"return\", transaction);\n              case 9:\n                throw new ClientNotInitializedError();\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function signTransaction(_x) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(message) {\n        var _yield$this$_client$r2, signature;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this._client && this._session)) {\n                  _context4.next = 8;\n                  break;\n                }\n                _context4.next = 3;\n                return this._client.request({\n                  // The network does not change the output of message signing, but this is a required parameter for SignClient\n                  chainId: this._network,\n                  topic: this._session.topic,\n                  request: {\n                    method: WalletConnectRPCMethods.signMessage,\n                    params: {\n                      pubkey: this.publicKey.toString(),\n                      message: base58.encode(message)\n                    }\n                  }\n                });\n              case 3:\n                _yield$this$_client$r2 = _context4.sent;\n                signature = _yield$this$_client$r2.signature;\n                return _context4.abrupt(\"return\", base58.decode(signature));\n              case 8:\n                throw new ClientNotInitializedError();\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function signMessage(_x2) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }()\n  }]);\n  return WalletConnectWallet;\n}();","map":{"version":3,"mappings":"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","names":["PublicKey","QRCodeModal","WalletConnectClient","getSdkError","parseAccountId","base58","ClientNotInitializedError","QRCodeModalError","WalletConnectChainID","WalletConnectRPCMethods","getConnectParams","chainId","pairingTopic","requiredNamespaces","solana","chains","methods","signTransaction","signMessage","events","WalletConnectWallet","config","_options","options","_network","network","_client","init","client","sessions","find","filter","s","acknowledged","length","_session","publicKey","connect","uri","approval","Promise","resolve","reject","open","then","session","catch","finally","close","disconnect","topic","reason","undefined","Object","assign","off","removeListener","namespaces","accounts","address","transaction","request","method","params","signature","addSignature","Buffer","from","decode","message","pubkey","toString","encode"],"sources":["/Users/ivan/Metadata/node_modules/@jnwng/walletconnect-solana/src/adapter.ts"],"sourcesContent":["import type { Transaction } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport QRCodeModal from '@walletconnect/qrcode-modal';\nimport WalletConnectClient from '@walletconnect/sign-client';\nimport type { EngineTypes, SessionTypes, SignClientTypes } from '@walletconnect/types';\nimport { getSdkError, parseAccountId } from '@walletconnect/utils';\nimport base58 from 'bs58';\nimport { ClientNotInitializedError, QRCodeModalError } from './errors.js';\n\nexport interface WalletConnectWalletAdapterConfig {\n    network: WalletConnectChainID;\n    options: SignClientTypes.Options;\n}\n\nexport enum WalletConnectChainID {\n    Mainnet = 'solana:4sGjMW1sUnHzSxGspuhpqLDx6wiyjNtZ',\n    Devnet = 'solana:8E9rvCKLFQia2Y35HXjjpWzj8weVo44K',\n}\n\nexport enum WalletConnectRPCMethods {\n    signTransaction = 'solana_signTransaction',\n    signMessage = 'solana_signMessage',\n}\n\ninterface WalletConnectWalletInit {\n    publicKey: PublicKey;\n}\n\nconst getConnectParams = (chainId: WalletConnectChainID, pairingTopic?: string): EngineTypes.ConnectParams => ({\n    requiredNamespaces: {\n        solana: {\n            chains: [chainId],\n            methods: [WalletConnectRPCMethods.signTransaction, WalletConnectRPCMethods.signMessage],\n            events: [],\n        },\n    },\n    pairingTopic,\n});\n\nexport class WalletConnectWallet {\n    private _client: WalletConnectClient | undefined;\n    private _session: SessionTypes.Struct | undefined;\n    private readonly _network: WalletConnectChainID;\n    private readonly _options: SignClientTypes.Options;\n\n    constructor(config: WalletConnectWalletAdapterConfig) {\n        this._options = config.options;\n        this._network = config.network;\n    }\n\n    async connect(): Promise<WalletConnectWalletInit> {\n        const client = this._client ?? (await WalletConnectClient.init(this._options));\n        const sessions = client.find(getConnectParams(this._network)).filter((s) => s.acknowledged);\n        if (sessions.length) {\n            // select last matching session\n            this._session = sessions[sessions.length - 1];\n            // We assign this variable only after we're sure we've received approval\n            this._client = client;\n\n            return {\n                publicKey: this.publicKey,\n            };\n        } else {\n            const { uri, approval } = await client.connect(getConnectParams(this._network));\n            return new Promise((resolve, reject) => {\n                if (uri) {\n                    QRCodeModal.open(uri, () => {\n                        reject(new QRCodeModalError());\n                    });\n                }\n\n                approval()\n                    .then((session) => {\n                        this._session = session;\n                        // We assign this variable only after we're sure we've received approval\n                        this._client = client;\n\n                        resolve({ publicKey: this.publicKey });\n                    })\n                    .catch(reject)\n                    .finally(() => {\n                        QRCodeModal.close();\n                    });\n            });\n        }\n    }\n\n    async disconnect() {\n        if (this._client && this._session) {\n            await this._client.disconnect({\n                topic: this._session.topic,\n                reason: getSdkError('USER_DISCONNECTED'),\n            });\n            this._session = undefined;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    get client(): WalletConnectClient {\n        if (this._client) {\n            // TODO: using client.off throws an error\n            return Object.assign({}, this._client, { off: this._client.removeListener });\n            // return this._client;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    get publicKey(): PublicKey {\n        if (this._client && this._session) {\n            const { address } = parseAccountId(this._session.namespaces.solana.accounts[0]);\n            return new PublicKey(address);\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    async signTransaction(transaction: Transaction): Promise<Transaction> {\n        if (this._client && this._session) {\n            const { signature } = await this._client.request<{ signature: string }>({\n                chainId: this._network,\n                topic: this._session.topic,\n                request: { method: WalletConnectRPCMethods.signTransaction, params: { ...transaction } },\n            });\n            transaction.addSignature(this.publicKey, Buffer.from(base58.decode(signature)));\n\n            return transaction;\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        if (this._client && this._session) {\n            const { signature } = await this._client.request<{ signature: string }>({\n                // The network does not change the output of message signing, but this is a required parameter for SignClient\n                chainId: this._network,\n                topic: this._session.topic,\n                request: {\n                    method: WalletConnectRPCMethods.signMessage,\n                    params: { pubkey: this.publicKey.toString(), message: base58.encode(message) },\n                },\n            });\n\n            return base58.decode(signature);\n        } else {\n            throw new ClientNotInitializedError();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}