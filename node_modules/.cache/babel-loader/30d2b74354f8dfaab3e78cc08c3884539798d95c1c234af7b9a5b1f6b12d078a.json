{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toConsumableArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar assert_1 = __importDefault(require(\"assert\"));\nvar utils_1 = require(\"./utils\");\nvar bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nvar bytewordsLookUpTable = [];\nvar BYTEWORDS_NUM = 256;\nvar BYTEWORD_LENGTH = 4;\nvar MINIMAL_BYTEWORD_LENGTH = 2;\nvar STYLES;\n(function (STYLES) {\n  STYLES[\"STANDARD\"] = \"standard\";\n  STYLES[\"URI\"] = \"uri\";\n  STYLES[\"MINIMAL\"] = \"minimal\";\n})(STYLES || (STYLES = {}));\nvar getWord = function getWord(index) {\n  return bytewords.slice(index * BYTEWORD_LENGTH, index * BYTEWORD_LENGTH + BYTEWORD_LENGTH);\n};\nvar getMinimalWord = function getMinimalWord(index) {\n  var byteword = getWord(index);\n  return \"\".concat(byteword[0]).concat(byteword[BYTEWORD_LENGTH - 1]);\n};\nvar addCRC = function addCRC(string) {\n  var crc = utils_1.getCRCHex(Buffer.from(string, 'hex'));\n  return \"\".concat(string).concat(crc);\n};\nvar encodeWithSeparator = function encodeWithSeparator(word, separator) {\n  var crcAppendedWord = addCRC(word);\n  var crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  var result = crcWordBuff.reduce(function (result, w) {\n    return [].concat(_toConsumableArray(result), [getWord(w)]);\n  }, []);\n  return result.join(separator);\n};\nvar encodeMinimal = function encodeMinimal(word) {\n  var crcAppendedWord = addCRC(word);\n  var crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  var result = crcWordBuff.reduce(function (result, w) {\n    return result + getMinimalWord(w);\n  }, '');\n  return result;\n};\nvar decodeWord = function decodeWord(word, wordLength) {\n  assert_1.default(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n  var dim = 26;\n  // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n  if (bytewordsLookUpTable.length === 0) {\n    var array_len = dim * dim;\n    bytewordsLookUpTable = _toConsumableArray(new Array(array_len)).map(function () {\n      return -1;\n    });\n    for (var i = 0; i < BYTEWORDS_NUM; i++) {\n      var byteword = getWord(i);\n      var _x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      var _y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      var _offset = _y * dim + _x;\n      bytewordsLookUpTable[_offset] = i;\n    }\n  }\n  // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n  var x = word[0].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  var y = word[wordLength == 4 ? 3 : 1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  assert_1.default(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n  var offset = y * dim + x;\n  var value = bytewordsLookUpTable[offset];\n  assert_1.default(value !== -1, 'Invalid Bytewords: value not in lookup table');\n  // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n  if (wordLength == BYTEWORD_LENGTH) {\n    var _byteword = getWord(value);\n    var c1 = word[1].toLowerCase();\n    var c2 = word[2].toLowerCase();\n    assert_1.default(c1 === _byteword[1] && c2 === _byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  }\n  // Successful decode.\n  return Buffer.from([value]).toString('hex');\n};\nvar _decode = function _decode(string, separator, wordLength) {\n  var words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : utils_1.partition(string, 2);\n  var decodedString = words.map(function (word) {\n    return decodeWord(word, wordLength);\n  }).join('');\n  assert_1.default(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n  var _utils_1$split = utils_1.split(Buffer.from(decodedString, 'hex'), 4),\n    _utils_1$split2 = _slicedToArray(_utils_1$split, 2),\n    body = _utils_1$split2[0],\n    bodyChecksum = _utils_1$split2[1];\n  var checksum = utils_1.getCRCHex(body); // convert to hex\n  assert_1.default(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n  return body.toString('hex');\n};\nvar decode = function decode(string) {\n  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n    default:\n      throw new Error(\"Invalid style \".concat(style));\n  }\n};\nvar encode = function encode(string) {\n  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : STYLES.MINIMAL;\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n    default:\n      throw new Error(\"Invalid style \".concat(style));\n  }\n};\nexports.default = {\n  decode: decode,\n  encode: encode,\n  STYLES: STYLES\n};","map":{"version":3,"mappings":"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","names":["bytewords","bytewordsLookUpTable","BYTEWORDS_NUM","BYTEWORD_LENGTH","MINIMAL_BYTEWORD_LENGTH","STYLES","getWord","index","slice","getMinimalWord","byteword","addCRC","string","crc","utils_1","Buffer","from","encodeWithSeparator","word","separator","crcAppendedWord","crcWordBuff","result","reduce","w","join","encodeMinimal","decodeWord","wordLength","assert_1","length","dim","array_len","Array","map","i","x","charCodeAt","y","offset","toLowerCase","value","c1","c2","toString","_decode","words","split","decodedString","body","bodyChecksum","checksum","decode","style","MINIMAL","STANDARD","URI","Error","encode","exports"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/bytewords.ts"],"sourcesContent":["import assert from \"assert\";\nimport { getCRCHex, partition, split } from \"./utils\";\n\nconst bytewords = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlimplionlistlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszerozestzinczonezoom';\nlet bytewordsLookUpTable: number[] = [];\nconst BYTEWORDS_NUM = 256;\nconst BYTEWORD_LENGTH = 4;\nconst MINIMAL_BYTEWORD_LENGTH = 2;\n\nenum STYLES {\n  STANDARD = 'standard',\n  URI = 'uri',\n  MINIMAL = 'minimal'\n}\n\nconst getWord = (index: number): string => {\n  return bytewords.slice(index * BYTEWORD_LENGTH, (index * BYTEWORD_LENGTH) + BYTEWORD_LENGTH)\n}\n\nconst getMinimalWord = (index: number): string => {\n  const byteword = getWord(index);\n\n  return `${byteword[0]}${byteword[BYTEWORD_LENGTH - 1]}`\n}\n\nconst addCRC = (string: string): string => {\n  const crc = getCRCHex(Buffer.from(string, 'hex'));\n\n  return `${string}${crc}`;\n}\n\nconst encodeWithSeparator = (word: string, separator: string): string => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result: string[], w) => ([...result, getWord(w)]), []);\n\n  return result.join(separator);\n}\n\nconst encodeMinimal = (word: string): string => {\n  const crcAppendedWord = addCRC(word);\n  const crcWordBuff = Buffer.from(crcAppendedWord, 'hex');\n  const result = crcWordBuff.reduce((result, w) => result + getMinimalWord(w), '');\n\n  return result;\n}\n\nconst decodeWord = (word: string, wordLength: number): string => {\n  assert(word.length === wordLength, 'Invalid Bytewords: word.length does not match wordLength provided');\n\n  const dim = 26;\n\n  // Since the first and last letters of each Byteword are unique,\n  // we can use them as indexes into a two-dimensional lookup table.\n  // This table is generated lazily.\n  if (bytewordsLookUpTable.length === 0) {\n    const array_len = dim * dim;\n    bytewordsLookUpTable = [...new Array(array_len)].map(() => -1)\n\n    for (let i = 0; i < BYTEWORDS_NUM; i++) {\n      const byteword = getWord(i);\n      let x = byteword[0].charCodeAt(0) - 'a'.charCodeAt(0);\n      let y = byteword[3].charCodeAt(0) - 'a'.charCodeAt(0);\n      let offset = y * dim + x;\n      bytewordsLookUpTable[offset] = i;\n    }\n  }\n\n  // If the coordinates generated by the first and last letters are out of bounds,\n  // or the lookup table contains -1 at the coordinates, then the word is not valid.\n  let x = (word[0]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n  let y = (word[wordLength == 4 ? 3 : 1]).toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);\n\n  assert(0 <= x && x < dim && 0 <= y && y < dim, 'Invalid Bytewords: invalid word');\n\n  let offset = y * dim + x;\n  let value = bytewordsLookUpTable[offset];\n\n  assert(value !== -1, 'Invalid Bytewords: value not in lookup table');\n\n  // If we're decoding a full four-letter word, verify that the two middle letters are correct.\n  if (wordLength == BYTEWORD_LENGTH) {\n    const byteword = getWord(value)\n    let c1 = word[1].toLowerCase();\n    let c2 = word[2].toLowerCase();\n\n    assert(c1 === byteword[1] && c2 === byteword[2], 'Invalid Bytewords: invalid middle letters of word');\n  }\n\n  // Successful decode.\n  return Buffer.from([value]).toString('hex')\n}\n\nconst _decode = (string: string, separator: string, wordLength: number): string => {\n  const words = wordLength == BYTEWORD_LENGTH ? string.split(separator) : partition(string, 2)\n  const decodedString = words.map((word: string) => decodeWord(word, wordLength)).join('');\n\n  assert(decodedString.length >= 5, 'Invalid Bytewords: invalid decoded string length');\n\n  const [body, bodyChecksum] = split(Buffer.from(decodedString, 'hex'), 4)\n  const checksum = getCRCHex(body)// convert to hex\n\n  assert(checksum === bodyChecksum.toString('hex'), 'Invalid Checksum');\n\n  return body.toString('hex');\n}\n\n\nconst decode = (string: string, style: STYLES = STYLES.MINIMAL): string => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return _decode(string, ' ', BYTEWORD_LENGTH);\n    case STYLES.URI:\n      return _decode(string, '-', BYTEWORD_LENGTH);\n    case STYLES.MINIMAL:\n      return _decode(string, '', MINIMAL_BYTEWORD_LENGTH);\n    default:\n      throw new Error(`Invalid style ${style}`)\n  }\n}\n\nconst encode = (string: string, style: STYLES = STYLES.MINIMAL): string => {\n  switch (style) {\n    case STYLES.STANDARD:\n      return encodeWithSeparator(string, ' ');\n    case STYLES.URI:\n      return encodeWithSeparator(string, '-');\n    case STYLES.MINIMAL:\n      return encodeMinimal(string);\n    default:\n      throw new Error(`Invalid style ${style}`)\n  }\n}\n\nexport default {\n  decode,\n  encode,\n  STYLES\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}