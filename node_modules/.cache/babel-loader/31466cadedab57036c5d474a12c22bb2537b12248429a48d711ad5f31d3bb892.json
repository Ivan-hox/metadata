{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase(_ref) {\n  var children = _ref.children,\n    adapters = _ref.wallets,\n    adapter = _ref.adapter,\n    isUnloadingRef = _ref.isUnloadingRef,\n    onAutoConnectRequest = _ref.onAutoConnectRequest,\n    onConnectError = _ref.onConnectError,\n    onError = _ref.onError,\n    onSelectWallet = _ref.onSelectWallet;\n  var isConnectingRef = useRef(false);\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    connecting = _useState2[0],\n    setConnecting = _useState2[1];\n  var isDisconnectingRef = useRef(false);\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    disconnecting = _useState4[0],\n    setDisconnecting = _useState4[1];\n  var _useState5 = useState(function () {\n      var _adapter$publicKey;\n      return (_adapter$publicKey = adapter === null || adapter === void 0 ? void 0 : adapter.publicKey) !== null && _adapter$publicKey !== void 0 ? _adapter$publicKey : null;\n    }),\n    _useState6 = _slicedToArray(_useState5, 2),\n    publicKey = _useState6[0],\n    setPublicKey = _useState6[1];\n  var _useState7 = useState(function () {\n      var _adapter$connected;\n      return (_adapter$connected = adapter === null || adapter === void 0 ? void 0 : adapter.connected) !== null && _adapter$connected !== void 0 ? _adapter$connected : false;\n    }),\n    _useState8 = _slicedToArray(_useState7, 2),\n    connected = _useState8[0],\n    setConnected = _useState8[1];\n  /**\n   * Store the error handlers as refs so that a change in the\n   * custom error handler does not recompute other dependencies.\n   */\n  var onErrorRef = useRef(onError);\n  useEffect(function () {\n    onErrorRef.current = onError;\n    return function () {\n      onErrorRef.current = undefined;\n    };\n  }, [onError]);\n  var handleErrorRef = useRef(function (error, adapter) {\n    if (!isUnloadingRef.current) {\n      if (onErrorRef.current) {\n        onErrorRef.current(error, adapter);\n      } else {\n        console.error(error, adapter);\n        if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n          window.open(adapter.url, '_blank');\n        }\n      }\n    }\n    return error;\n  });\n  // Wrap adapters to conform to the `Wallet` interface\n  var _useState9 = useState(function () {\n      return adapters.map(function (adapter) {\n        return {\n          adapter: adapter,\n          readyState: adapter.readyState\n        };\n      }).filter(function (_ref2) {\n        var readyState = _ref2.readyState;\n        return readyState !== WalletReadyState.Unsupported;\n      });\n    }),\n    _useState10 = _slicedToArray(_useState9, 2),\n    wallets = _useState10[0],\n    setWallets = _useState10[1];\n  // When the adapters change, start to listen for changes to their `readyState`\n  useEffect(function () {\n    // When the adapters change, wrap them to conform to the `Wallet` interface\n    setWallets(function (wallets) {\n      return adapters.map(function (adapter, index) {\n        var wallet = wallets[index];\n        // If the wallet hasn't changed, return the same instance\n        return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState ? wallet : {\n          adapter: adapter,\n          readyState: adapter.readyState\n        };\n      }).filter(function (_ref3) {\n        var readyState = _ref3.readyState;\n        return readyState !== WalletReadyState.Unsupported;\n      });\n    });\n    function handleReadyStateChange(readyState) {\n      var _this = this;\n      setWallets(function (prevWallets) {\n        var index = prevWallets.findIndex(function (_ref4) {\n          var adapter = _ref4.adapter;\n          return adapter === _this;\n        });\n        if (index === -1) return prevWallets;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        var adapter = prevWallets[index].adapter;\n        return [].concat(_toConsumableArray(prevWallets.slice(0, index)), [{\n          adapter: adapter,\n          readyState: readyState\n        }], _toConsumableArray(prevWallets.slice(index + 1))).filter(function (_ref5) {\n          var readyState = _ref5.readyState;\n          return readyState !== WalletReadyState.Unsupported;\n        });\n      });\n    }\n    adapters.forEach(function (adapter) {\n      return adapter.on('readyStateChange', handleReadyStateChange, adapter);\n    });\n    return function () {\n      adapters.forEach(function (adapter) {\n        return adapter.off('readyStateChange', handleReadyStateChange, adapter);\n      });\n    };\n  }, [adapter, adapters]);\n  var wallet = useMemo(function () {\n    var _wallets$find;\n    return (_wallets$find = wallets.find(function (wallet) {\n      return wallet.adapter === adapter;\n    })) !== null && _wallets$find !== void 0 ? _wallets$find : null;\n  }, [adapter, wallets]);\n  // Setup and teardown event listeners when the adapter changes\n  useEffect(function () {\n    if (!adapter) return;\n    var handleConnect = function handleConnect(publicKey) {\n      setPublicKey(publicKey);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(true);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    var handleDisconnect = function handleDisconnect() {\n      if (isUnloadingRef.current) return;\n      setPublicKey(null);\n      isConnectingRef.current = false;\n      setConnecting(false);\n      setConnected(false);\n      isDisconnectingRef.current = false;\n      setDisconnecting(false);\n    };\n    var handleError = function handleError(error) {\n      handleErrorRef.current(error, adapter);\n    };\n    adapter.on('connect', handleConnect);\n    adapter.on('disconnect', handleDisconnect);\n    adapter.on('error', handleError);\n    return function () {\n      adapter.off('connect', handleConnect);\n      adapter.off('disconnect', handleDisconnect);\n      adapter.off('error', handleError);\n      handleDisconnect();\n    };\n  }, [adapter, isUnloadingRef]);\n  // When the adapter changes, clear the `autoConnect` tracking flag\n  var didAttemptAutoConnectRef = useRef(false);\n  useEffect(function () {\n    return function () {\n      didAttemptAutoConnectRef.current = false;\n    };\n  }, [adapter]);\n  // If auto-connect is enabled, request to connect when the adapter changes and is ready\n  useEffect(function () {\n    if (didAttemptAutoConnectRef.current || isConnectingRef.current || connected || !onAutoConnectRequest || !((wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Installed || (wallet === null || wallet === void 0 ? void 0 : wallet.readyState) === WalletReadyState.Loadable)) {\n      return;\n    }\n    isConnectingRef.current = true;\n    setConnecting(true);\n    didAttemptAutoConnectRef.current = true;\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return onAutoConnectRequest();\n            case 3:\n              _context.next = 8;\n              break;\n            case 5:\n              _context.prev = 5;\n              _context.t0 = _context[\"catch\"](0);\n              onConnectError();\n              // Drop the error. It will be caught by `handleError` anyway.\n            case 8:\n              _context.prev = 8;\n              setConnecting(false);\n              isConnectingRef.current = false;\n              return _context.finish(8);\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 5, 8, 12]]);\n    }))();\n  }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n  // Send a transaction using the provided connection\n  var sendTransaction = useCallback( /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transaction, connection, options) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (adapter) {\n                _context2.next = 2;\n                break;\n              }\n              throw handleErrorRef.current(new WalletNotSelectedError());\n            case 2:\n              if (connected) {\n                _context2.next = 4;\n                break;\n              }\n              throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            case 4:\n              _context2.next = 6;\n              return adapter.sendTransaction(transaction, connection, options);\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x, _x2, _x3) {\n      return _ref7.apply(this, arguments);\n    };\n  }(), [adapter, connected]);\n  // Sign a transaction if the wallet supports it\n  var signTransaction = useMemo(function () {\n    return adapter && 'signTransaction' in adapter ? /*#__PURE__*/function () {\n      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(transaction) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (connected) {\n                  _context3.next = 2;\n                  break;\n                }\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n              case 2:\n                _context3.next = 4;\n                return adapter.signTransaction(transaction);\n              case 4:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x4) {\n        return _ref8.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, connected]);\n  // Sign multiple transactions if the wallet supports it\n  var signAllTransactions = useMemo(function () {\n    return adapter && 'signAllTransactions' in adapter ? /*#__PURE__*/function () {\n      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transactions) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (connected) {\n                  _context4.next = 2;\n                  break;\n                }\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n              case 2:\n                _context4.next = 4;\n                return adapter.signAllTransactions(transactions);\n              case 4:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      return function (_x5) {\n        return _ref9.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, connected]);\n  // Sign an arbitrary message if the wallet supports it\n  var signMessage = useMemo(function () {\n    return adapter && 'signMessage' in adapter ? /*#__PURE__*/function () {\n      var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(message) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (connected) {\n                  _context5.next = 2;\n                  break;\n                }\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n              case 2:\n                _context5.next = 4;\n                return adapter.signMessage(message);\n              case 4:\n                return _context5.abrupt(\"return\", _context5.sent);\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      return function (_x6) {\n        return _ref10.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, connected]);\n  var handleConnect = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n    var adapter, readyState;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!(isConnectingRef.current || isDisconnectingRef.current || wallet !== null && wallet !== void 0 && wallet.adapter.connected)) {\n              _context6.next = 2;\n              break;\n            }\n            return _context6.abrupt(\"return\");\n          case 2:\n            if (wallet) {\n              _context6.next = 4;\n              break;\n            }\n            throw handleErrorRef.current(new WalletNotSelectedError());\n          case 4:\n            adapter = wallet.adapter, readyState = wallet.readyState;\n            if (readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable) {\n              _context6.next = 7;\n              break;\n            }\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n          case 7:\n            isConnectingRef.current = true;\n            setConnecting(true);\n            _context6.prev = 9;\n            _context6.next = 12;\n            return adapter.connect();\n          case 12:\n            _context6.next = 18;\n            break;\n          case 14:\n            _context6.prev = 14;\n            _context6.t0 = _context6[\"catch\"](9);\n            onConnectError();\n            throw _context6.t0;\n          case 18:\n            _context6.prev = 18;\n            setConnecting(false);\n            isConnectingRef.current = false;\n            return _context6.finish(18);\n          case 22:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[9, 14, 18, 22]]);\n  })), [onConnectError, wallet]);\n  var handleDisconnect = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!isDisconnectingRef.current) {\n              _context7.next = 2;\n              break;\n            }\n            return _context7.abrupt(\"return\");\n          case 2:\n            if (adapter) {\n              _context7.next = 4;\n              break;\n            }\n            return _context7.abrupt(\"return\");\n          case 4:\n            isDisconnectingRef.current = true;\n            setDisconnecting(true);\n            _context7.prev = 6;\n            _context7.next = 9;\n            return adapter.disconnect();\n          case 9:\n            _context7.prev = 9;\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n            return _context7.finish(9);\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[6,, 9, 13]]);\n  })), [adapter]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: !!onAutoConnectRequest,\n      wallets: wallets,\n      wallet: wallet,\n      publicKey: publicKey,\n      connected: connected,\n      connecting: connecting,\n      disconnecting: disconnecting,\n      select: onSelectWallet,\n      connect: handleConnect,\n      disconnect: handleDisconnect,\n      sendTransaction: sendTransaction,\n      signTransaction: signTransaction,\n      signAllTransactions: signAllTransactions,\n      signMessage: signMessage\n    }\n  }, children);\n}","map":{"version":3,"mappings":"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","names":["WalletNotConnectedError","WalletNotReadyError","WalletReadyState","React","useCallback","useEffect","useMemo","useRef","useState","WalletNotSelectedError","WalletContext","WalletProviderBase","children","adapters","wallets","adapter","isUnloadingRef","onAutoConnectRequest","onConnectError","onError","onSelectWallet","isConnectingRef","connecting","setConnecting","isDisconnectingRef","disconnecting","setDisconnecting","publicKey","setPublicKey","connected","setConnected","onErrorRef","current","undefined","handleErrorRef","error","console","window","open","url","map","readyState","filter","Unsupported","setWallets","index","wallet","handleReadyStateChange","prevWallets","findIndex","slice","forEach","on","off","find","handleConnect","handleDisconnect","handleError","didAttemptAutoConnectRef","Installed","Loadable","sendTransaction","transaction","connection","options","signTransaction","signAllTransactions","transactions","signMessage","message","connect","disconnect","Provider","value","autoConnect","select"],"sources":["/Users/ivan/Metadata/node_modules/@solana/wallet-adapter-react/src/WalletProviderBase.tsx"],"sourcesContent":["import {\n    type Adapter,\n    type MessageSignerWalletAdapterProps,\n    type SignerWalletAdapterProps,\n    type WalletAdapterProps,\n    type WalletError,\n    type WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { type PublicKey } from '@solana/web3.js';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\n\nexport interface WalletProviderBaseProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    adapter: Adapter | null;\n    isUnloadingRef: React.RefObject<boolean>;\n    // NOTE: The presence/absence of this handler implies that auto-connect is enabled/disabled.\n    onAutoConnectRequest?: () => Promise<void>;\n    onConnectError: () => void;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n    onSelectWallet: (walletName: WalletName | null) => void;\n}\n\nexport function WalletProviderBase({\n    children,\n    wallets: adapters,\n    adapter,\n    isUnloadingRef,\n    onAutoConnectRequest,\n    onConnectError,\n    onError,\n    onSelectWallet,\n}: WalletProviderBaseProps) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error: WalletError, adapter?: Adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            } else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters\n            .map((adapter) => ({\n                adapter,\n                readyState: adapter.readyState,\n            }))\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n    );\n\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) =>\n            adapters\n                .map((adapter, index) => {\n                    const wallet = wallets[index];\n                    // If the wallet hasn't changed, return the same instance\n                    return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                        ? wallet\n                        : {\n                              adapter: adapter,\n                              readyState: adapter.readyState,\n                          };\n                })\n                .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported)\n        );\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1) return prevWallets;\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index]!;\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter) return;\n\n        const handleConnect = (publicKey: PublicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current) return;\n\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n\n        const handleError = (error: WalletError) => {\n            handleErrorRef.current(error, adapter);\n        };\n\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable)\n        ) {\n            return;\n        }\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            } catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            } finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n\n    // Send a transaction using the provided connection\n    const sendTransaction: WalletAdapterProps['sendTransaction'] = useCallback(\n        async (transaction, connection, options) => {\n            if (!adapter) throw handleErrorRef.current(new WalletNotSelectedError());\n            if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.sendTransaction(transaction, connection, options);\n        },\n        [adapter, connected]\n    );\n\n    // Sign a transaction if the wallet supports it\n    const signTransaction: SignerWalletAdapterProps['signTransaction'] | undefined = useMemo(\n        () =>\n            adapter && 'signTransaction' in adapter\n                ? async (transaction) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signTransaction(transaction);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions: SignerWalletAdapterProps['signAllTransactions'] | undefined = useMemo(\n        () =>\n            adapter && 'signAllTransactions' in adapter\n                ? async (transactions) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signAllTransactions(transactions);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage: MessageSignerWalletAdapterProps['signMessage'] | undefined = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message) => {\n                      if (!connected) throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, connected]\n    );\n\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected) return;\n        if (!wallet) throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (e) {\n            onConnectError();\n            throw e;\n        } finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current) return;\n        if (!adapter) return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect: !!onAutoConnectRequest,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: onSelectWallet,\n                connect: handleConnect,\n                disconnect: handleDisconnect,\n                sendTransaction,\n                signTransaction,\n                signAllTransactions,\n                signMessage,\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}