{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\nvar utils_1 = require(\"./utils\");\nvar fountainUtils_1 = require(\"./fountainUtils\");\nvar errors_1 = require(\"./errors\");\nvar FountainDecoderPart = /*#__PURE__*/function () {\n  function FountainDecoderPart(_indexes, _fragment) {\n    _classCallCheck(this, FountainDecoderPart);\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n  _createClass(FountainDecoderPart, [{\n    key: \"indexes\",\n    get: function get() {\n      return this._indexes;\n    }\n  }, {\n    key: \"fragment\",\n    get: function get() {\n      return this._fragment;\n    }\n  }, {\n    key: \"isSimple\",\n    value: function isSimple() {\n      return this.indexes.length === 1;\n    }\n  }], [{\n    key: \"fromEncoderPart\",\n    value: function fromEncoderPart(encoderPart) {\n      var indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n      var fragment = encoderPart.fragment;\n      return new FountainDecoderPart(indexes, fragment);\n    }\n  }]);\n  return FountainDecoderPart;\n}();\nexports.FountainDecoderPart = FountainDecoderPart;\nvar FountainDecoder = /*#__PURE__*/function () {\n  function FountainDecoder() {\n    _classCallCheck(this, FountainDecoder);\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n  _createClass(FountainDecoder, [{\n    key: \"validatePart\",\n    value: function validatePart(part) {\n      var _this = this;\n      // If this is the first part we've seen\n      if (this.expectedPartIndexes.length === 0) {\n        // Record the things that all the other parts we see will have to match to be valid.\n        _toConsumableArray(new Array(part.seqLength)).forEach(function (_, index) {\n          return _this.expectedPartIndexes.push(index);\n        });\n        this.expectedMessageLength = part.messageLength;\n        this.expectedChecksum = part.checksum;\n        this.expectedFragmentLength = part.fragment.length;\n      } else {\n        // If this part's values don't match the first part's values, throw away the part\n        if (this.expectedPartIndexes.length !== part.seqLength) {\n          return false;\n        }\n        if (this.expectedMessageLength !== part.messageLength) {\n          return false;\n        }\n        if (this.expectedChecksum !== part.checksum) {\n          return false;\n        }\n        if (this.expectedFragmentLength !== part.fragment.length) {\n          return false;\n        }\n      }\n      // This part should be processed\n      return true;\n    }\n  }, {\n    key: \"reducePartByPart\",\n    value: function reducePartByPart(a, b) {\n      // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n      if (utils_1.arrayContains(a.indexes, b.indexes)) {\n        var newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n        var newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n        return new FountainDecoderPart(newIndexes, newFragment);\n      } else {\n        // `a` is not reducable by `b`, so return a\n        return a;\n      }\n    }\n  }, {\n    key: \"reduceMixedBy\",\n    value: function reduceMixedBy(part) {\n      var _this2 = this;\n      var newMixed = [];\n      this.mixedParts.map(function (_ref) {\n        var mixedPart = _ref.value;\n        return _this2.reducePartByPart(mixedPart, part);\n      }).forEach(function (reducedPart) {\n        if (reducedPart.isSimple()) {\n          _this2.queuedParts.push(reducedPart);\n        } else {\n          newMixed.push({\n            key: reducedPart.indexes,\n            value: reducedPart\n          });\n        }\n      });\n      this.mixedParts = newMixed;\n    }\n  }, {\n    key: \"processSimplePart\",\n    value: function processSimplePart(part) {\n      // Don't process duplicate parts\n      var fragmentIndex = part.indexes[0];\n      if (this.receivedPartIndexes.includes(fragmentIndex)) {\n        return;\n      }\n      this.simpleParts.push({\n        key: part.indexes,\n        value: part\n      });\n      this.receivedPartIndexes.push(fragmentIndex);\n      // If we've received all the parts\n      if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n        // Reassemble the message from its fragments\n        var sortedParts = this.simpleParts.map(function (_ref2) {\n          var value = _ref2.value;\n          return value;\n        }).sort(function (a, b) {\n          return a.indexes[0] - b.indexes[0];\n        });\n        var message = FountainDecoder.joinFragments(sortedParts.map(function (part) {\n          return part.fragment;\n        }), this.expectedMessageLength);\n        var checksum = utils_1.getCRC(message);\n        if (checksum === this.expectedChecksum) {\n          this.result = message;\n        } else {\n          this.error = new errors_1.InvalidChecksumError();\n        }\n      } else {\n        this.reduceMixedBy(part);\n      }\n    }\n  }, {\n    key: \"processMixedPart\",\n    value: function processMixedPart(part) {\n      var _this3 = this;\n      // Don't process duplicate parts\n      if (this.mixedParts.some(function (_ref3) {\n        var indexes = _ref3.key;\n        return utils_1.arraysEqual(indexes, part.indexes);\n      })) {\n        return;\n      }\n      // Reduce this part by all the others\n      var p2 = this.simpleParts.reduce(function (acc, _ref4) {\n        var p = _ref4.value;\n        return _this3.reducePartByPart(acc, p);\n      }, part);\n      p2 = this.mixedParts.reduce(function (acc, _ref5) {\n        var p = _ref5.value;\n        return _this3.reducePartByPart(acc, p);\n      }, p2);\n      // If the part is now simple\n      if (p2.isSimple()) {\n        // Add it to the queue\n        this.queuedParts.push(p2);\n      } else {\n        this.reduceMixedBy(p2);\n        this.mixedParts.push({\n          key: p2.indexes,\n          value: p2\n        });\n      }\n    }\n  }, {\n    key: \"processQueuedItem\",\n    value: function processQueuedItem() {\n      if (this.queuedParts.length === 0) {\n        return;\n      }\n      var part = this.queuedParts.shift();\n      if (part.isSimple()) {\n        this.processSimplePart(part);\n      } else {\n        this.processMixedPart(part);\n      }\n    }\n  }, {\n    key: \"receivePart\",\n    value: function receivePart(encoderPart) {\n      if (this.isComplete()) {\n        return false;\n      }\n      if (!this.validatePart(encoderPart)) {\n        return false;\n      }\n      var decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n      this.lastPartIndexes = decoderPart.indexes;\n      this.queuedParts.push(decoderPart);\n      while (!this.isComplete() && this.queuedParts.length > 0) {\n        this.processQueuedItem();\n      }\n      ;\n      this.processedPartsCount += 1;\n      return true;\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return Boolean(this.result !== undefined && this.result.length > 0);\n    }\n  }, {\n    key: \"isSuccess\",\n    value: function isSuccess() {\n      return Boolean(this.error === undefined && this.isComplete());\n    }\n  }, {\n    key: \"resultMessage\",\n    value: function resultMessage() {\n      return this.isSuccess() ? this.result : Buffer.from([]);\n    }\n  }, {\n    key: \"isFailure\",\n    value: function isFailure() {\n      return this.error !== undefined;\n    }\n  }, {\n    key: \"resultError\",\n    value: function resultError() {\n      return this.error ? this.error.message : '';\n    }\n  }, {\n    key: \"expectedPartCount\",\n    value: function expectedPartCount() {\n      return this.expectedPartIndexes.length;\n    }\n  }, {\n    key: \"getExpectedPartIndexes\",\n    value: function getExpectedPartIndexes() {\n      return _toConsumableArray(this.expectedPartIndexes);\n    }\n  }, {\n    key: \"getReceivedPartIndexes\",\n    value: function getReceivedPartIndexes() {\n      return _toConsumableArray(this.receivedPartIndexes);\n    }\n  }, {\n    key: \"getLastPartIndexes\",\n    value: function getLastPartIndexes() {\n      return _toConsumableArray(this.lastPartIndexes);\n    }\n  }, {\n    key: \"estimatedPercentComplete\",\n    value: function estimatedPercentComplete() {\n      if (this.isComplete()) {\n        return 1;\n      }\n      var expectedPartCount = this.expectedPartCount();\n      if (expectedPartCount === 0) {\n        return 0;\n      }\n      // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n      // that `this.processedPartsCount` also tracks the duplicate parts that have been\n      // processeed.\n      return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n    }\n  }, {\n    key: \"getProgress\",\n    value: function getProgress() {\n      if (this.isComplete()) {\n        return 1;\n      }\n      var expectedPartCount = this.expectedPartCount();\n      if (expectedPartCount === 0) {\n        return 0;\n      }\n      return this.receivedPartIndexes.length / expectedPartCount;\n    }\n  }]);\n  return FountainDecoder;\n}();\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = function (fragments, messageLength) {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"mappings":";;;;;;;;;AAAA;AACA;AAEA;AAAgD,IAEnCA,mBAAmB;EAC9B,6BACUC,QAAkB,EAClBC,SAAiB;IAAA;IADjB,aAAQ,GAARD,QAAQ;IACR,cAAS,GAATC,SAAS;EACf;EAAC;IAAA;IAAA,KAEL,eAAW;MAAK,OAAO,IAAI,CAACD,QAAQ;IAAE;EAAC;IAAA;IAAA,KACvC,eAAY;MAAK,OAAO,IAAI,CAACC,SAAS;IAAE;EAAC;IAAA;IAAA,OASlC,oBAAQ;MACb,OAAO,IAAI,CAACC,OAAO,CAACC,MAAM,KAAK,CAAC;IAClC;EAAC;IAAA;IAAA,OATM,yBAAuBC,WAAgC;MAC5D,IAAMF,OAAO,GAAGG,+BAAe,CAACD,WAAW,CAACE,MAAM,EAAEF,WAAW,CAACG,SAAS,EAAEH,WAAW,CAACI,QAAQ,CAAC;MAChG,IAAMC,QAAQ,GAAGL,WAAW,CAACK,QAAQ;MAErC,OAAO,IAAIV,mBAAmB,CAACG,OAAO,EAAEO,QAAQ,CAAC;IACnD;EAAC;EAAA;AAAA;AAdHC;AAmBC,IAQoBC,eAAe;EAApC;IAAA;IAEU,WAAM,GAAuBC,SAAS;IACtC,0BAAqB,GAAW,CAAC;IACjC,qBAAgB,GAAW,CAAC;IAC5B,2BAAsB,GAAW,CAAC;IAClC,wBAAmB,GAAW,CAAC;IAC/B,wBAAmB,GAAgB,EAAE;IACrC,oBAAe,GAAgB,EAAE;IACjC,gBAAW,GAA0B,EAAE;IACvC,wBAAmB,GAAgB,EAAE;IACrC,eAAU,GAAe,EAAE;IAC3B,gBAAW,GAAe,EAAE;EA8NtC;EAAC;IAAA;IAAA,OA3NS,sBAAaC,IAAyB;MAAA;MAC5C;MACA,IAAI,IAAI,CAACC,mBAAmB,CAACX,MAAM,KAAK,CAAC,EAAE;QACzC;QACA,mBAAI,IAAIY,KAAK,CAACF,IAAI,CAACN,SAAS,CAAC,EAC1BS,OAAO,CAAC,UAACC,CAAC,EAAEC,KAAK;UAAA,OAAK,KAAI,CAACJ,mBAAmB,CAACK,IAAI,CAACD,KAAK,CAAC;QAAA,EAAC;QAE9D,IAAI,CAACE,qBAAqB,GAAGP,IAAI,CAACQ,aAAa;QAC/C,IAAI,CAACC,gBAAgB,GAAGT,IAAI,CAACL,QAAQ;QACrC,IAAI,CAACe,sBAAsB,GAAGV,IAAI,CAACJ,QAAQ,CAACN,MAAM;OACnD,MACI;QACH;QACA,IAAI,IAAI,CAACW,mBAAmB,CAACX,MAAM,KAAKU,IAAI,CAACN,SAAS,EAAE;UACtD,OAAO,KAAK;;QAEd,IAAI,IAAI,CAACa,qBAAqB,KAAKP,IAAI,CAACQ,aAAa,EAAE;UACrD,OAAO,KAAK;;QAEd,IAAI,IAAI,CAACC,gBAAgB,KAAKT,IAAI,CAACL,QAAQ,EAAE;UAC3C,OAAO,KAAK;;QAEd,IAAI,IAAI,CAACe,sBAAsB,KAAKV,IAAI,CAACJ,QAAQ,CAACN,MAAM,EAAE;UACxD,OAAO,KAAK;;;MAIhB;MACA,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAEO,0BAAiBqB,CAAsB,EAAEC,CAAsB;MACrE;MACA,IAAIC,qBAAa,CAACF,CAAC,CAACtB,OAAO,EAAEuB,CAAC,CAACvB,OAAO,CAAC,EAAE;QACvC,IAAMyB,UAAU,GAAGD,qBAAa,CAACF,CAAC,CAACtB,OAAO,EAAEuB,CAAC,CAACvB,OAAO,CAAC;QACtD,IAAM0B,WAAW,GAAGF,iBAAS,CAACF,CAAC,CAACf,QAAQ,EAAEgB,CAAC,CAAChB,QAAQ,CAAC;QAErD,OAAO,IAAIV,mBAAmB,CAAC4B,UAAU,EAAEC,WAAW,CAAC;OACxD,MAAM;QACL;QACA,OAAOJ,CAAC;;IAEZ;EAAC;IAAA;IAAA,OAEO,uBAAcX,IAAyB;MAAA;MAC7C,IAAMgB,QAAQ,GAAe,EAAE;MAE/B,IAAI,CAACC,UAAU,CACZC,GAAG,CAAC;QAAA,IAAUC,SAAS,QAAhBC,KAAK;QAAA,OAAkB,MAAI,CAACC,gBAAgB,CAACF,SAAS,EAAEnB,IAAI,CAAC;MAAA,EAAC,CACrEG,OAAO,CAAC,qBAAW,EAAG;QACrB,IAAImB,WAAW,CAACC,QAAQ,EAAE,EAAE;UAC1B,MAAI,CAACC,WAAW,CAAClB,IAAI,CAACgB,WAAW,CAAC;SACnC,MAAM;UACLN,QAAQ,CAACV,IAAI,CAAC;YAAEmB,GAAG,EAAEH,WAAW,CAACjC,OAAO;YAAE+B,KAAK,EAAEE;UAAW,CAAE,CAAC;;MAEnE,CAAC,CAAC;MAEJ,IAAI,CAACL,UAAU,GAAGD,QAAQ;IAC5B;EAAC;IAAA;IAAA,OAEO,2BAAkBhB,IAAyB;MACjD;MACA,IAAM0B,aAAa,GAAG1B,IAAI,CAACX,OAAO,CAAC,CAAC,CAAC;MAErC,IAAI,IAAI,CAACsC,mBAAmB,CAACC,QAAQ,CAACF,aAAa,CAAC,EAAE;QACpD;;MAGF,IAAI,CAACG,WAAW,CAACvB,IAAI,CAAC;QAAEmB,GAAG,EAAEzB,IAAI,CAACX,OAAO;QAAE+B,KAAK,EAAEpB;MAAI,CAAE,CAAC;MACzD,IAAI,CAAC2B,mBAAmB,CAACrB,IAAI,CAACoB,aAAa,CAAC;MAE5C;MACA,IAAIb,mBAAW,CAAC,IAAI,CAACc,mBAAmB,EAAE,IAAI,CAAC1B,mBAAmB,CAAC,EAAE;QACnE;QACA,IAAM6B,WAAW,GAAG,IAAI,CAACD,WAAW,CACjCX,GAAG,CAAC;UAAA,IAAGE,KAAK,SAALA,KAAK;UAAA,OAAOA,KAAK;QAAA,EAAC,CACzBW,IAAI,CAAC,UAACpB,CAAC,EAAEC,CAAC;UAAA,OAAMD,CAAC,CAACtB,OAAO,CAAC,CAAC,CAAC,GAAGuB,CAAC,CAACvB,OAAO,CAAC,CAAC,CAAC;QAAA,CAAC,CAAC;QAChD,IAAM2C,OAAO,GAAGlC,eAAe,CAACmC,aAAa,CAACH,WAAW,CAACZ,GAAG,CAAC,cAAI;UAAA,OAAIlB,IAAI,CAACJ,QAAQ;QAAA,EAAC,EAAE,IAAI,CAACW,qBAAqB,CAAC;QACjH,IAAMZ,QAAQ,GAAGkB,cAAM,CAACmB,OAAO,CAAC;QAEhC,IAAIrC,QAAQ,KAAK,IAAI,CAACc,gBAAgB,EAAE;UACtC,IAAI,CAACyB,MAAM,GAAGF,OAAO;SACtB,MAAM;UACL,IAAI,CAACG,KAAK,GAAG,IAAIC,6BAAoB,EAAE;;OAE1C,MACI;QACH,IAAI,CAACC,aAAa,CAACrC,IAAI,CAAC;;IAE5B;EAAC;IAAA;IAAA,OAEO,0BAAiBA,IAAyB;MAAA;MAChD;MACA,IAAI,IAAI,CAACiB,UAAU,CAACqB,IAAI,CAAC;QAAA,IAAQjD,OAAO,SAAZoC,GAAG;QAAA,OAAgBZ,mBAAW,CAACxB,OAAO,EAAEW,IAAI,CAACX,OAAO,CAAC;MAAA,EAAC,EAAE;QAClF;;MAGF;MACA,IAAIkD,EAAE,GAAG,IAAI,CAACV,WAAW,CAACW,MAAM,CAAC,UAACC,GAAG;QAAA,IAAWC,CAAC,SAARtB,KAAK;QAAA,OAAU,MAAI,CAACC,gBAAgB,CAACoB,GAAG,EAAEC,CAAC,CAAC;MAAA,GAAE1C,IAAI,CAAC;MAC5FuC,EAAE,GAAG,IAAI,CAACtB,UAAU,CAACuB,MAAM,CAAC,UAACC,GAAG;QAAA,IAAWC,CAAC,SAARtB,KAAK;QAAA,OAAU,MAAI,CAACC,gBAAgB,CAACoB,GAAG,EAAEC,CAAC,CAAC;MAAA,GAAEH,EAAE,CAAC;MAErF;MACA,IAAIA,EAAE,CAAChB,QAAQ,EAAE,EAAE;QACjB;QACA,IAAI,CAACC,WAAW,CAAClB,IAAI,CAACiC,EAAE,CAAC;OAC1B,MAAM;QACL,IAAI,CAACF,aAAa,CAACE,EAAE,CAAC;QAEtB,IAAI,CAACtB,UAAU,CAACX,IAAI,CAAC;UAAEmB,GAAG,EAAEc,EAAE,CAAClD,OAAO;UAAE+B,KAAK,EAAEmB;QAAE,CAAE,CAAC;;IAExD;EAAC;IAAA;IAAA,OAEO,6BAAiB;MACvB,IAAI,IAAI,CAACf,WAAW,CAAClC,MAAM,KAAK,CAAC,EAAE;QACjC;;MAGF,IAAMU,IAAI,GAAG,IAAI,CAACwB,WAAW,CAACmB,KAAK,EAAG;MAEtC,IAAI3C,IAAI,CAACuB,QAAQ,EAAE,EAAE;QACnB,IAAI,CAACqB,iBAAiB,CAAC5C,IAAI,CAAC;OAC7B,MAAM;QACL,IAAI,CAAC6C,gBAAgB,CAAC7C,IAAI,CAAC;;IAE/B;EAAC;IAAA;IAAA,OAMM,qBAAYT,WAAgC;MACjD,IAAI,IAAI,CAACuD,UAAU,EAAE,EAAE;QACrB,OAAO,KAAK;;MAGd,IAAI,CAAC,IAAI,CAACC,YAAY,CAACxD,WAAW,CAAC,EAAE;QACnC,OAAO,KAAK;;MAGd,IAAMyD,WAAW,GAAG9D,mBAAmB,CAAC+D,eAAe,CAAC1D,WAAW,CAAC;MAEpE,IAAI,CAAC2D,eAAe,GAAGF,WAAW,CAAC3D,OAAO;MAC1C,IAAI,CAACmC,WAAW,CAAClB,IAAI,CAAC0C,WAAW,CAAC;MAElC,OAAO,CAAC,IAAI,CAACF,UAAU,EAAE,IAAI,IAAI,CAACtB,WAAW,CAAClC,MAAM,GAAG,CAAC,EAAE;QACxD,IAAI,CAAC6D,iBAAiB,EAAE;;MACzB;MAED,IAAI,CAACC,mBAAmB,IAAI,CAAC;MAE7B,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAEM,sBAAU;MACf,OAAOC,OAAO,CAAC,IAAI,CAACnB,MAAM,KAAKnC,SAAS,IAAI,IAAI,CAACmC,MAAM,CAAC5C,MAAM,GAAG,CAAC,CAAC;IACrE;EAAC;IAAA;IAAA,OAEM,qBAAS;MACd,OAAO+D,OAAO,CAAC,IAAI,CAAClB,KAAK,KAAKpC,SAAS,IAAI,IAAI,CAAC+C,UAAU,EAAE,CAAC;IAC/D;EAAC;IAAA;IAAA,OAEM,yBAAa;MAClB,OAAO,IAAI,CAACQ,SAAS,EAAE,GAAG,IAAI,CAACpB,MAAO,GAAGqB,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;IAC1D;EAAC;IAAA;IAAA,OAEM,qBAAS;MACd,OAAO,IAAI,CAACrB,KAAK,KAAKpC,SAAS;IACjC;EAAC;IAAA;IAAA,OAEM,uBAAW;MAChB,OAAO,IAAI,CAACoC,KAAK,GAAG,IAAI,CAACA,KAAK,CAACH,OAAO,GAAG,EAAE;IAC7C;EAAC;IAAA;IAAA,OAEM,6BAAiB;MACtB,OAAO,IAAI,CAAC/B,mBAAmB,CAACX,MAAM;IACxC;EAAC;IAAA;IAAA,OAEM,kCAAsB;MAC3B,0BAAW,IAAI,CAACW,mBAAmB;IACrC;EAAC;IAAA;IAAA,OAEM,kCAAsB;MAC3B,0BAAW,IAAI,CAAC0B,mBAAmB;IACrC;EAAC;IAAA;IAAA,OAEM,8BAAkB;MACvB,0BAAW,IAAI,CAACuB,eAAe;IACjC;EAAC;IAAA;IAAA,OAEM,oCAAwB;MAC7B,IAAI,IAAI,CAACJ,UAAU,EAAE,EAAE;QACrB,OAAO,CAAC;;MAGV,IAAMW,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,EAAE;MAElD,IAAIA,iBAAiB,KAAK,CAAC,EAAE;QAC3B,OAAO,CAAC;;MAGV;MACA;MACA;MACA,OAAOC,IAAI,CAACC,GAAG,CAAC,IAAI,EAAE,IAAI,CAACP,mBAAmB,IAAIK,iBAAiB,GAAG,IAAI,CAAC,CAAC;IAC9E;EAAC;IAAA;IAAA,OAEM,uBAAW;MAChB,IAAI,IAAI,CAACX,UAAU,EAAE,EAAE;QACrB,OAAO,CAAC;;MAGV,IAAMW,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,EAAE;MAElD,IAAIA,iBAAiB,KAAK,CAAC,EAAE;QAC3B,OAAO,CAAC;;MAGV,OAAO,IAAI,CAAC9B,mBAAmB,CAACrC,MAAM,GAAGmE,iBAAiB;IAC5D;EAAC;EAAA;AAAA;AAzOH5D;AA6IgBC,6BAAa,GAAG,UAAC8D,SAAmB,EAAEpD,aAAqB,EAAI;EAC3E,OAAO+C,MAAM,CAACM,MAAM,CAACD,SAAS,CAAC,CAACE,KAAK,CAAC,CAAC,EAAEtD,aAAa,CAAC;AACzD,CAAC","names":["FountainDecoderPart","_indexes","_fragment","indexes","length","encoderPart","fountainUtils_1","seqNum","seqLength","checksum","fragment","exports","FountainDecoder","undefined","part","expectedPartIndexes","Array","forEach","_","index","push","expectedMessageLength","messageLength","expectedChecksum","expectedFragmentLength","a","b","utils_1","newIndexes","newFragment","newMixed","mixedParts","map","mixedPart","value","reducePartByPart","reducedPart","isSimple","queuedParts","key","fragmentIndex","receivedPartIndexes","includes","simpleParts","sortedParts","sort","message","joinFragments","result","error","errors_1","reduceMixedBy","some","p2","reduce","acc","p","shift","processSimplePart","processMixedPart","isComplete","validatePart","decoderPart","fromEncoderPart","lastPartIndexes","processQueuedItem","processedPartsCount","Boolean","isSuccess","Buffer","from","expectedPartCount","Math","min","fragments","concat","slice"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/fountainDecoder.ts"],"sourcesContent":["import { arrayContains, arraysEqual, bufferXOR, getCRC, setDifference, split } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { FountainEncoderPart } from \"./fountainEncoder\";\nimport { InvalidChecksumError } from \"./errors\";\n\nexport class FountainDecoderPart {\n  constructor(\n    private _indexes: number[],\n    private _fragment: Buffer\n  ) { }\n\n  get indexes() { return this._indexes; }\n  get fragment() { return this._fragment; }\n\n  public static fromEncoderPart(encoderPart: FountainEncoderPart) {\n    const indexes = chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  public isSimple() {\n    return this.indexes.length === 1;\n  }\n}\n\ntype PartIndexes = number[];\ninterface PartDict {\n  key: PartIndexes;\n  value: FountainDecoderPart;\n}\n\nexport default class FountainDecoder {\n  private error: Error | undefined;\n  private result: Buffer | undefined = undefined;\n  private expectedMessageLength: number = 0;\n  private expectedChecksum: number = 0;\n  private expectedFragmentLength: number = 0;\n  private processedPartsCount: number = 0;\n  private expectedPartIndexes: PartIndexes = [];\n  private lastPartIndexes: PartIndexes = [];\n  private queuedParts: FountainDecoderPart[] = [];\n  private receivedPartIndexes: PartIndexes = [];\n  private mixedParts: PartDict[] = [];\n  private simpleParts: PartDict[] = [];\n\n\n  private validatePart(part: FountainEncoderPart) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)]\n        .forEach((_, index) => this.expectedPartIndexes.push(index));\n\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    }\n    else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n\n    // This part should be processed\n    return true;\n  }\n\n  private reducePartByPart(a: FountainDecoderPart, b: FountainDecoderPart): FountainDecoderPart {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = setDifference(a.indexes, b.indexes);\n      const newFragment = bufferXOR(a.fragment, b.fragment);\n\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  private reduceMixedBy(part: FountainDecoderPart): void {\n    const newMixed: PartDict[] = [];\n\n    this.mixedParts\n      .map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part))\n      .forEach(reducedPart => {\n        if (reducedPart.isSimple()) {\n          this.queuedParts.push(reducedPart)\n        } else {\n          newMixed.push({ key: reducedPart.indexes, value: reducedPart })\n        }\n      })\n\n    this.mixedParts = newMixed;\n  }\n\n  private processSimplePart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0]\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({ key: part.indexes, value: part });\n    this.receivedPartIndexes.push(fragmentIndex);\n\n    // If we've received all the parts\n    if (arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts\n        .map(({ value }) => value)\n        .sort((a, b) => (a.indexes[0] - b.indexes[0]))\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength)\n      const checksum = getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new InvalidChecksumError();\n      }\n    }\n    else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  private processMixedPart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({ key: indexes }) => arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part)\n    p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2)\n\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n\n      this.mixedParts.push({ key: p2.indexes, value: p2 });\n    }\n  }\n\n  private processQueuedItem(): void {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift()!;\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  public static joinFragments = (fragments: Buffer[], messageLength: number) => {\n    return Buffer.concat(fragments).slice(0, messageLength)\n  }\n\n  public receivePart(encoderPart: FountainEncoderPart): boolean {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    };\n\n    this.processedPartsCount += 1;\n\n    return true;\n  }\n\n  public isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  public isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  public resultMessage(): Buffer {\n    return this.isSuccess() ? this.result! : Buffer.from([]);\n  }\n\n  public isFailure() {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount(): number {\n    return this.expectedPartIndexes.length;\n  }\n\n  public getExpectedPartIndexes(): PartIndexes {\n    return [...this.expectedPartIndexes]\n  }\n\n  public getReceivedPartIndexes(): PartIndexes {\n    return [...this.receivedPartIndexes]\n  }\n\n  public getLastPartIndexes(): PartIndexes {\n    return [...this.lastPartIndexes]\n  }\n\n  public estimatedPercentComplete(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  public getProgress(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}