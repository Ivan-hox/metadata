{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BeetArgsStruct = exports.isBeetStruct = exports.BeetStruct = void 0;\nvar read_write_1 = require(\"./read-write\");\nvar utils_1 = require(\"./utils\");\n/**\n * Configures a class or any JavaScript object type for de/serialization aka\n * read/write. All fields of that class have to be of fixed size.\n * If a field requires a {@link FixableBeet} use the {@link FixableBeetStruct}\n * instead.\n *\n * @template Class the type to produce when deserializing\n * @template Args contains all fields, is typically a subset of Class and is\n * used to construct an instance of it\n *\n * @category beet/struct\n */\nvar BeetStruct = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of the BeetStruct.\n   *\n   * @param fields de/serializers for each field of the {@link Class}\n   * @param construct the function that creates an instance of {@link Class}\n   * from the args\n   * @param description identifies this struct for diagnostics/debugging\n   * purposes\n   */\n  function BeetStruct(fields, construct) {\n    var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BeetStruct.description;\n    _classCallCheck(this, BeetStruct);\n    this.fields = fields;\n    this.construct = construct;\n    this.description = description;\n    this.byteSize = this.getByteSize();\n    if (utils_1.logDebug.enabled) {\n      var flds = fields.map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          key = _ref2[0],\n          val = _ref2[1];\n        return \"\".concat(String(key), \": \").concat(val.description, \" \").concat((0, utils_1.beetBytes)(val));\n      }).join('\\n  ');\n      (0, utils_1.logDebug)(\"struct \".concat(description, \" {\\n  \").concat(flds, \"\\n} \").concat((0, utils_1.beetBytes)(this)));\n    }\n  }\n  /**\n   * Along with `write` this allows structs to be treated as {@link Beet}s and\n   * thus supports composing/nesting them the same way.\n   * @private\n   */\n  _createClass(BeetStruct, [{\n    key: \"read\",\n    value: function read(buf, offset) {\n      var _this$deserialize = this.deserialize(buf, offset),\n        _this$deserialize2 = _slicedToArray(_this$deserialize, 1),\n        value = _this$deserialize2[0];\n      return value;\n    }\n    /**\n     * Along with `read` this allows structs to be treated as {@link Beet}s and\n     * thus supports composing/nesting them the same way.\n     * @private\n     */\n  }, {\n    key: \"write\",\n    value: function write(buf, offset, value) {\n      var _this$serialize = this.serialize(value),\n        _this$serialize2 = _slicedToArray(_this$serialize, 2),\n        innerBuf = _this$serialize2[0],\n        innerOffset = _this$serialize2[1];\n      innerBuf.copy(buf, offset, 0, innerOffset);\n    }\n    /**\n     * Deserializes an instance of the Class from the provided buffer starting to\n     * read at the provided offset.\n     *\n     * @returns `[instance of Class, offset into buffer after deserialization completed]`\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(buffer) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (utils_1.logTrace.enabled) {\n        (0, utils_1.logTrace)('deserializing [%s] from %d bytes buffer', this.description, buffer.byteLength);\n        (0, utils_1.logTrace)(buffer);\n        (0, utils_1.logTrace)(buffer.toJSON().data);\n      }\n      var reader = new read_write_1.BeetReader(buffer, offset);\n      var args = reader.readStruct(this.fields);\n      return [this.construct(args), reader.offset];\n    }\n    /**\n     * Serializes the provided instance into a new {@link Buffer}\n     *\n     * @param instance of the struct to serialize\n     * @param byteSize allows to override the size fo the created Buffer and\n     * defaults to the size of the struct to serialize\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(instance) {\n      var byteSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteSize;\n      (0, utils_1.logTrace)('serializing [%s] %o to %d bytes buffer', this.description, instance, byteSize);\n      var writer = new read_write_1.BeetWriter(byteSize);\n      writer.writeStruct(instance, this.fields);\n      return [writer.buffer, writer.offset];\n    }\n  }, {\n    key: \"getByteSize\",\n    value: function getByteSize() {\n      return this.fields.reduce(function (acc, _ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          _ = _ref4[0],\n          beet = _ref4[1];\n        return acc + beet.byteSize;\n      }, 0);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return BeetStruct.TYPE;\n    }\n  }]);\n  return BeetStruct;\n}();\nexports.BeetStruct = BeetStruct;\nBeetStruct.description = 'BeetStruct';\nBeetStruct.TYPE = 'BeetStruct';\nfunction isBeetStruct(beet) {\n  return beet.type === BeetStruct.TYPE;\n}\nexports.isBeetStruct = isBeetStruct;\n/**\n * Convenience wrapper around {@link BeetStruct} which is used for plain JavasScript\n * objects, like are used for option args passed to functions.\n *\n * @category beet/struct\n */\nvar BeetArgsStruct = /*#__PURE__*/function (_BeetStruct) {\n  _inherits(BeetArgsStruct, _BeetStruct);\n  var _super = _createSuper(BeetArgsStruct);\n  function BeetArgsStruct(fields) {\n    var description = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BeetArgsStruct.description;\n    _classCallCheck(this, BeetArgsStruct);\n    return _super.call(this, fields, function (args) {\n      return args;\n    }, description);\n  }\n  return _createClass(BeetArgsStruct);\n}(BeetStruct);\nexports.BeetArgsStruct = BeetArgsStruct;\nBeetArgsStruct.description = 'BeetArgsStruct';","map":{"version":3,"mappings":"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","names":["BeetStruct","fields","construct","description","byteSize","getByteSize","utils_1","enabled","flds","map","key","val","String","join","buf","offset","deserialize","value","serialize","innerBuf","innerOffset","copy","buffer","byteLength","toJSON","data","reader","read_write_1","args","readStruct","instance","writer","writeStruct","reduce","acc","_","beet","TYPE","exports","isBeetStruct","type","BeetArgsStruct"],"sources":["../../../src/struct.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}