{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.chooseFragments = exports.shuffle = exports.chooseDegree = void 0;\nvar utils_1 = require(\"./utils\");\nvar xoshiro_1 = __importDefault(require(\"./xoshiro\"));\nvar randomSampler = require('@apocentre/alias-sampling');\nvar chooseDegree = function chooseDegree(seqLenth, rng) {\n  var degreeProbabilities = _toConsumableArray(new Array(seqLenth)).map(function (_, index) {\n    return 1 / (index + 1);\n  });\n  var degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n  return degreeChooser.next() + 1;\n};\nexports.chooseDegree = chooseDegree;\nvar shuffle = function shuffle(items, rng) {\n  var remaining = _toConsumableArray(items);\n  var result = [];\n  while (remaining.length > 0) {\n    var index = rng.nextInt(0, remaining.length - 1);\n    var item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n  return result;\n};\nexports.shuffle = shuffle;\nvar chooseFragments = function chooseFragments(seqNum, seqLength, checksum) {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    var seed = Buffer.concat([utils_1.intToBytes(seqNum), utils_1.intToBytes(checksum)]);\n    var rng = new xoshiro_1.default(seed);\n    var degree = exports.chooseDegree(seqLength, rng);\n    var indexes = _toConsumableArray(new Array(seqLength)).map(function (_, index) {\n      return index;\n    });\n    var shuffledIndexes = exports.shuffle(indexes, rng);\n    return shuffledIndexes.slice(0, degree);\n  }\n};\nexports.chooseFragments = chooseFragments;","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA;AACA;AACA,IAAMA,aAAa,GAAGC,OAAO,CAAC,2BAA2B,CAAC;AAEnD,IAAMC,YAAY,GAAG,SAAfA,YAAY,CAAIC,QAAgB,EAAEC,GAAY,EAAY;EACrE,IAAMC,mBAAmB,GAAG,mBAAI,IAAIC,KAAK,CAACH,QAAQ,CAAC,EAAEI,GAAG,CAAC,UAACC,CAAC,EAAEC,KAAK;IAAA,OAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,CAAC;EAAA,EAAC;EACvF,IAAMC,aAAa,GAAGV,aAAa,CAACK,mBAAmB,EAAE,IAAI,EAAED,GAAG,CAACO,UAAU,CAAC;EAE9E,OAAOD,aAAa,CAACE,IAAI,EAAE,GAAG,CAAC;AACjC,CAAC;AALYC,oBAAY;AAQlB,IAAMC,OAAO,GAAG,SAAVA,OAAO,CAAIC,KAAY,EAAEX,GAAY,EAAW;EAC3D,IAAIY,SAAS,sBAAOD,KAAK,CAAC;EAC1B,IAAIE,MAAM,GAAG,EAAE;EAEf,OAAOD,SAAS,CAACE,MAAM,GAAG,CAAC,EAAE;IAC3B,IAAIT,KAAK,GAAGL,GAAG,CAACe,OAAO,CAAC,CAAC,EAAEH,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;IAChD,IAAIE,IAAI,GAAGJ,SAAS,CAACP,KAAK,CAAC;IAC3B;IACAO,SAAS,CAACK,MAAM,CAACZ,KAAK,EAAE,CAAC,CAAC;IAC1BQ,MAAM,CAACK,IAAI,CAACF,IAAI,CAAC;;EAGnB,OAAOH,MAAM;AACf,CAAC;AAbYJ,eAAO;AAgBb,IAAMU,eAAe,GAAG,SAAlBA,eAAe,CAAIC,MAAc,EAAEC,SAAiB,EAAEC,QAAgB,EAAc;EAC/F;EACA;EACA;EACA,IAAIF,MAAM,IAAIC,SAAS,EAAE;IACvB,OAAO,CAACD,MAAM,GAAG,CAAC,CAAC;GACpB,MAAM;IACL,IAAMG,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,CAACC,kBAAU,CAACN,MAAM,CAAC,EAAEM,kBAAU,CAACJ,QAAQ,CAAC,CAAC,CAAC;IACtE,IAAMtB,GAAG,GAAG,IAAI2B,iBAAO,CAACJ,IAAI,CAAC;IAC7B,IAAMK,MAAM,GAAGnB,oBAAY,CAACY,SAAS,EAAErB,GAAG,CAAC;IAC3C,IAAM6B,OAAO,GAAG,mBAAI,IAAI3B,KAAK,CAACmB,SAAS,CAAC,EAAElB,GAAG,CAAC,UAACC,CAAC,EAAEC,KAAK;MAAA,OAAKA,KAAK;IAAA,EAAC;IAClE,IAAMyB,eAAe,GAAGrB,eAAO,CAACoB,OAAO,EAAE7B,GAAG,CAAC;IAE7C,OAAO8B,eAAe,CAACC,KAAK,CAAC,CAAC,EAAEH,MAAM,CAAC;;AAE3C,CAAC;AAfYnB,uBAAe","names":["randomSampler","require","chooseDegree","seqLenth","rng","degreeProbabilities","Array","map","_","index","degreeChooser","nextDouble","next","exports","shuffle","items","remaining","result","length","nextInt","item","splice","push","chooseFragments","seqNum","seqLength","checksum","seed","Buffer","concat","utils_1","xoshiro_1","degree","indexes","shuffledIndexes","slice"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/fountainUtils.ts"],"sourcesContent":["import { intToBytes } from \"./utils\";\nimport Xoshiro from \"./xoshiro\";\nconst randomSampler = require('@apocentre/alias-sampling');\n\nexport const chooseDegree = (seqLenth: number, rng: Xoshiro): number => {\n  const degreeProbabilities = [...new Array(seqLenth)].map((_, index) => 1 / (index + 1));\n  const degreeChooser = randomSampler(degreeProbabilities, null, rng.nextDouble);\n\n  return degreeChooser.next() + 1;\n}\n\n\nexport const shuffle = (items: any[], rng: Xoshiro): any[] => {\n  let remaining = [...items];\n  let result = [];\n\n  while (remaining.length > 0) {\n    let index = rng.nextInt(0, remaining.length - 1);\n    let item = remaining[index];\n    // remaining.erase(remaining.begin() + index);\n    remaining.splice(index, 1);\n    result.push(item);\n  }\n\n  return result;\n}\n\n\nexport const chooseFragments = (seqNum: number, seqLength: number, checksum: number): number[] => {\n  // The first `seqLenth` parts are the \"pure\" fragments, not mixed with any\n  // others. This means that if you only generate the first `seqLenth` parts,\n  // then you have all the parts you need to decode the message.\n  if (seqNum <= seqLength) {\n    return [seqNum - 1];\n  } else {\n    const seed = Buffer.concat([intToBytes(seqNum), intToBytes(checksum)]);\n    const rng = new Xoshiro(seed);\n    const degree = chooseDegree(seqLength, rng);\n    const indexes = [...new Array(seqLength)].map((_, index) => index);\n    const shuffledIndexes = shuffle(indexes, rng);\n\n    return shuffledIndexes.slice(0, degree);\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}