{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar fountainDecoder_1 = __importDefault(require(\"./fountainDecoder\"));\nvar bytewords_1 = __importDefault(require(\"./bytewords\"));\nvar assert_1 = __importDefault(require(\"assert\"));\nvar utils_1 = require(\"./utils\");\nvar errors_1 = require(\"./errors\");\nvar ur_1 = __importDefault(require(\"./ur\"));\nvar fountainEncoder_1 = require(\"./fountainEncoder\");\nvar URDecoder = /*#__PURE__*/function () {\n  function URDecoder() {\n    var fountainDecoder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new fountainDecoder_1.default();\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes';\n    _classCallCheck(this, URDecoder);\n    this.fountainDecoder = fountainDecoder;\n    this.type = type;\n    assert_1.default(utils_1.isURType(type), 'Invalid UR type');\n    this.expected_type = '';\n  }\n  _createClass(URDecoder, [{\n    key: \"validatePart\",\n    value: function validatePart(type) {\n      if (this.expected_type) {\n        return this.expected_type === type;\n      }\n      if (!utils_1.isURType(type)) {\n        return false;\n      }\n      this.expected_type = type;\n      return true;\n    }\n  }, {\n    key: \"receivePart\",\n    value: function receivePart(s) {\n      if (this.result !== undefined) {\n        return false;\n      }\n      var _URDecoder$parse = URDecoder.parse(s),\n        _URDecoder$parse2 = _slicedToArray(_URDecoder$parse, 2),\n        type = _URDecoder$parse2[0],\n        components = _URDecoder$parse2[1];\n      if (!this.validatePart(type)) {\n        return false;\n      }\n      // If this is a single-part UR then we're done\n      if (components.length === 1) {\n        this.result = URDecoder.decodeBody(type, components[0]);\n        return true;\n      }\n      if (components.length !== 2) {\n        throw new errors_1.InvalidPathLengthError();\n      }\n      var _components = _slicedToArray(components, 2),\n        seq = _components[0],\n        fragment = _components[1];\n      var _URDecoder$parseSeque = URDecoder.parseSequenceComponent(seq),\n        _URDecoder$parseSeque2 = _slicedToArray(_URDecoder$parseSeque, 2),\n        seqNum = _URDecoder$parseSeque2[0],\n        seqLength = _URDecoder$parseSeque2[1];\n      var cbor = bytewords_1.default.decode(fragment, bytewords_1.default.STYLES.MINIMAL);\n      var part = fountainEncoder_1.FountainEncoderPart.fromCBOR(cbor);\n      if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n        return false;\n      }\n      if (!this.fountainDecoder.receivePart(part)) {\n        return false;\n      }\n      if (this.fountainDecoder.isSuccess()) {\n        this.result = new ur_1.default(this.fountainDecoder.resultMessage(), type);\n      } else if (this.fountainDecoder.isFailure()) {\n        this.error = new errors_1.InvalidSchemeError();\n      }\n      return true;\n    }\n  }, {\n    key: \"resultUR\",\n    value: function resultUR() {\n      return this.result ? this.result : new ur_1.default(Buffer.from([]));\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return this.result && this.result.cbor.length > 0;\n    }\n  }, {\n    key: \"isSuccess\",\n    value: function isSuccess() {\n      return !this.error && this.isComplete();\n    }\n  }, {\n    key: \"isError\",\n    value: function isError() {\n      return this.error !== undefined;\n    }\n  }, {\n    key: \"resultError\",\n    value: function resultError() {\n      return this.error ? this.error.message : '';\n    }\n  }, {\n    key: \"expectedPartCount\",\n    value: function expectedPartCount() {\n      return this.fountainDecoder.expectedPartCount();\n    }\n  }, {\n    key: \"expectedPartIndexes\",\n    value: function expectedPartIndexes() {\n      return this.fountainDecoder.getExpectedPartIndexes();\n    }\n  }, {\n    key: \"receivedPartIndexes\",\n    value: function receivedPartIndexes() {\n      return this.fountainDecoder.getReceivedPartIndexes();\n    }\n  }, {\n    key: \"lastPartIndexes\",\n    value: function lastPartIndexes() {\n      return this.fountainDecoder.getLastPartIndexes();\n    }\n  }, {\n    key: \"estimatedPercentComplete\",\n    value: function estimatedPercentComplete() {\n      return this.fountainDecoder.estimatedPercentComplete();\n    }\n  }, {\n    key: \"getProgress\",\n    value: function getProgress() {\n      return this.fountainDecoder.getProgress();\n    }\n  }], [{\n    key: \"decodeBody\",\n    value: function decodeBody(type, message) {\n      var cbor = bytewords_1.default.decode(message, bytewords_1.default.STYLES.MINIMAL);\n      return new ur_1.default(Buffer.from(cbor, 'hex'), type);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(message) {\n      var _this$parse = this.parse(message),\n        _this$parse2 = _slicedToArray(_this$parse, 2),\n        type = _this$parse2[0],\n        components = _this$parse2[1];\n      if (components.length === 0) {\n        throw new errors_1.InvalidPathLengthError();\n      }\n      var body = components[0];\n      return URDecoder.decodeBody(type, body);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(message) {\n      var lowercase = message.toLowerCase();\n      var prefix = lowercase.slice(0, 3);\n      if (prefix !== 'ur:') {\n        throw new errors_1.InvalidSchemeError();\n      }\n      var components = lowercase.slice(3).split('/');\n      var type = components[0];\n      if (components.length < 2) {\n        throw new errors_1.InvalidPathLengthError();\n      }\n      if (!utils_1.isURType(type)) {\n        throw new errors_1.InvalidTypeError();\n      }\n      return [type, components.slice(1)];\n    }\n  }, {\n    key: \"parseSequenceComponent\",\n    value: function parseSequenceComponent(s) {\n      var components = s.split('-');\n      if (components.length !== 2) {\n        throw new errors_1.InvalidSequenceComponentError();\n      }\n      var seqNum = utils_1.toUint32(Number(components[0]));\n      var seqLength = Number(components[1]);\n      if (seqNum < 1 || seqLength < 1) {\n        throw new errors_1.InvalidSequenceComponentError();\n      }\n      return [seqNum, seqLength];\n    }\n  }]);\n  return URDecoder;\n}();\nexports.default = URDecoder;","map":{"version":3,"mappings":"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","names":["URDecoder","fountainDecoder","fountainDecoder_1","type","assert_1","utils_1","expected_type","s","result","undefined","parse","components","validatePart","length","decodeBody","errors_1","seq","fragment","parseSequenceComponent","seqNum","seqLength","cbor","bytewords_1","decode","STYLES","MINIMAL","part","fountainEncoder_1","fromCBOR","receivePart","isSuccess","ur_1","resultMessage","isFailure","error","Buffer","from","isComplete","message","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","getProgress","body","lowercase","toLowerCase","prefix","slice","split","Number","exports"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/urDecoder.ts"],"sourcesContent":["import FountainDecoder from './fountainDecoder';\nimport bytewords from './bytewords';\nimport assert from 'assert';\nimport { isURType, toUint32 } from './utils';\nimport { InvalidSchemeError, InvalidPathLengthError, InvalidTypeError, InvalidSequenceComponentError } from './errors';\nimport UR from './ur';\nimport { FountainEncoderPart } from './fountainEncoder';\n\nexport default class URDecoder {\n  private expected_type: string;\n  private result: UR | undefined;\n  private error: Error | undefined;\n\n  constructor(\n    private fountainDecoder: FountainDecoder = new FountainDecoder(),\n    public type: string = 'bytes'\n  ) {\n    assert(isURType(type), 'Invalid UR type');\n\n    this.expected_type = '';\n  }\n\n  private static decodeBody(type: string, message: string): UR {\n    const cbor = bytewords.decode(message, bytewords.STYLES.MINIMAL);\n\n    return new UR(Buffer.from(cbor, 'hex'), type);\n  }\n\n  private validatePart(type: string): boolean {\n    if (this.expected_type) {\n      return this.expected_type === type;\n    }\n\n    if (!isURType(type)) {\n      return false;\n    }\n\n    this.expected_type = type;\n\n    return true;\n  }\n\n  public static decode(message: string): UR {\n    const [type, components] = this.parse(message);\n\n    if (components.length === 0) {\n      throw new InvalidPathLengthError();\n    }\n\n    const body = components[0];\n\n    return URDecoder.decodeBody(type, body);\n  }\n\n  public static parse(message: string): [string, string[]] {\n    const lowercase = message.toLowerCase();\n    const prefix = lowercase.slice(0, 3);\n\n    if (prefix !== 'ur:') {\n      throw new InvalidSchemeError();\n    }\n\n    const components = lowercase.slice(3).split('/')\n    const type = components[0];\n\n    if (components.length < 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    if (!isURType(type)) {\n      throw new InvalidTypeError();\n    }\n\n    return [type, components.slice(1)]\n  }\n\n  public static parseSequenceComponent(s: string) {\n    const components = s.split('-');\n\n    if (components.length !== 2) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    const seqNum = toUint32(Number(components[0]));\n    const seqLength = Number(components[1]);\n\n    if (seqNum < 1 || seqLength < 1) {\n      throw new InvalidSequenceComponentError();\n    }\n\n    return [seqNum, seqLength];\n  }\n\n  public receivePart(s: string): boolean {\n    if (this.result !== undefined) {\n      return false;\n    }\n\n    const [type, components] = URDecoder.parse(s)\n\n    if (!this.validatePart(type)) {\n      return false;\n    }\n\n    // If this is a single-part UR then we're done\n    if (components.length === 1) {\n      this.result = URDecoder.decodeBody(type, components[0])\n\n      return true;\n    }\n\n    if (components.length !== 2) {\n      throw new InvalidPathLengthError();\n    }\n\n    const [seq, fragment] = components;\n    const [seqNum, seqLength] = URDecoder.parseSequenceComponent(seq);\n    const cbor = bytewords.decode(fragment, bytewords.STYLES.MINIMAL);\n    const part = FountainEncoderPart.fromCBOR(cbor);\n\n    if (seqNum !== part.seqNum || seqLength !== part.seqLength) {\n      return false;\n    }\n\n    if (!this.fountainDecoder.receivePart(part)) {\n      return false;\n    }\n\n    if (this.fountainDecoder.isSuccess()) {\n      this.result = new UR(this.fountainDecoder.resultMessage(), type);\n    }\n    else if (this.fountainDecoder.isFailure()) {\n      this.error = new InvalidSchemeError();\n    }\n\n    return true;\n  }\n\n  public resultUR(): UR {\n    return this.result ? this.result : new UR(Buffer.from([]));\n  }\n\n  public isComplete(): boolean {\n    return this.result && this.result.cbor.length > 0;\n  }\n\n  public isSuccess(): boolean {\n    return !this.error && this.isComplete();\n  }\n\n  public isError(): boolean {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount() {\n    return this.fountainDecoder.expectedPartCount();\n  }\n\n  public expectedPartIndexes() {\n    return this.fountainDecoder.getExpectedPartIndexes();\n  }\n\n  public receivedPartIndexes() {\n    return this.fountainDecoder.getReceivedPartIndexes();\n  }\n\n  public lastPartIndexes() {\n    return this.fountainDecoder.getLastPartIndexes();\n  }\n\n  public estimatedPercentComplete() {\n    return this.fountainDecoder.estimatedPercentComplete();\n  }\n\n  public getProgress() {\n    return this.fountainDecoder.getProgress();\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}