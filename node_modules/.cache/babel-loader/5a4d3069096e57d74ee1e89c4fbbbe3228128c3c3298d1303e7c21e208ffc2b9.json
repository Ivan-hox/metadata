{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoECKey = void 0;\nvar lib_1 = require(\"./lib\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"curve\"] = 1] = \"curve\";\n  Keys[Keys[\"private\"] = 2] = \"private\";\n  Keys[Keys[\"data\"] = 3] = \"data\";\n})(Keys || (Keys = {}));\nvar CryptoECKey = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoECKey, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoECKey);\n  function CryptoECKey(args) {\n    var _this;\n    _classCallCheck(this, CryptoECKey);\n    _this = _super.call(this);\n    _this.isECKey = function () {\n      return true;\n    };\n    _this.getCurve = function () {\n      return _this.curve || 0;\n    };\n    _this.isPrivateKey = function () {\n      return _this.privateKey || false;\n    };\n    _this.getData = function () {\n      return _this.data;\n    };\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_ECKEY;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      if (_this.curve) {\n        map[Keys.curve] = _this.curve;\n      }\n      if (_this.privateKey !== undefined) {\n        map[Keys.private] = _this.privateKey;\n      }\n      map[Keys.data] = _this.data;\n      return new lib_1.DataItem(map);\n    };\n    _this.getOutputDescriptorContent = function () {\n      return _this.data.toString('hex');\n    };\n    _this.data = args.data;\n    _this.curve = args.curve;\n    _this.privateKey = args.privateKey || undefined;\n    return _this;\n  }\n  return _createClass(CryptoECKey);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoECKey = CryptoECKey;\nCryptoECKey.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var curve = map[Keys.curve];\n  var privateKey = map[Keys.private];\n  var data = map[Keys.data];\n  if (!data) {\n    throw new Error(\"#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: \".concat(dataItem));\n  }\n  return new CryptoECKey({\n    data: data,\n    curve: curve,\n    privateKey: privateKey\n  });\n};\nCryptoECKey.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoECKey.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AACA;AAGA,IAAKA,IAIJ;AAJD,WAAKA,IAAI;EACPA,iCAAS;EACTA,qCAAO;EACPA,+BAAI;AACN,CAAC,EAJIA,IAAI,KAAJA,IAAI;AAIR,IAEYC,WAAY;EAAA;EAAA;EAIvB,qBAAYC,IAA4D;IAAA;IAAA;IACtE;IAMF,aAAO,GAAG,YAAK;MACb,OAAO,IAAI;IACb,CAAC;IAEM,cAAQ,GAAG;MAAA,OAAM,MAAKC,KAAK,IAAI,CAAC;IAAA;IAChC,kBAAY,GAAG;MAAA,OAAM,MAAKC,UAAU,IAAI,KAAK;IAAA;IAC7C,aAAO,GAAG;MAAA,OAAM,MAAKC,IAAI;IAAA;IAEhC,qBAAe,GAAG,YAAK;MACrB,OAAOC,4BAAa,CAACC,YAAY;IACnC,CAAC;IAED,gBAAU,GAAG,YAAK;MAChB,IAAMC,GAAG,GAAgB,EAAE;MAC3B,IAAI,MAAKL,KAAK,EAAE;QACdK,GAAG,CAACR,IAAI,CAACG,KAAK,CAAC,GAAG,MAAKA,KAAK;;MAE9B,IAAI,MAAKC,UAAU,KAAKK,SAAS,EAAE;QACjCD,GAAG,CAACR,IAAI,CAACU,OAAO,CAAC,GAAG,MAAKN,UAAU;;MAErCI,GAAG,CAACR,IAAI,CAACK,IAAI,CAAC,GAAG,MAAKA,IAAI;MAC1B,OAAO,IAAIM,cAAQ,CAACH,GAAG,CAAC;IAC1B,CAAC;IAED,gCAA0B,GAAG,YAAK;MAChC,OAAO,MAAKH,IAAI,CAACO,QAAQ,CAAC,KAAK,CAAC;IAClC,CAAC;IA/BC,MAAKP,IAAI,GAAGH,IAAI,CAACG,IAAI;IACrB,MAAKF,KAAK,GAAGD,IAAI,CAACC,KAAK;IACvB,MAAKC,UAAU,GAAGF,IAAI,CAACE,UAAU,IAAIK,SAAS;IAAC;EACjD;EAAC;AAAA,EAT8BI,2BAAY;AAA7CC;AAuCSb,wBAAY,GAAG,UAACc,QAAkB,EAAI;EAC3C,IAAMP,GAAG,GAAGO,QAAQ,CAACC,OAAO,EAAE;EAC9B,IAAMb,KAAK,GAAGK,GAAG,CAACR,IAAI,CAACG,KAAK,CAAC;EAC7B,IAAMC,UAAU,GAAGI,GAAG,CAACR,IAAI,CAACU,OAAO,CAAC;EACpC,IAAML,IAAI,GAAGG,GAAG,CAACR,IAAI,CAACK,IAAI,CAAC;EAC3B,IAAI,CAACA,IAAI,EAAE;IACT,MAAM,IAAIY,KAAK,sGACiFF,QAAQ,EACvG;;EAEH,OAAO,IAAId,WAAW,CAAC;IAAEI,IAAI,EAAJA,IAAI;IAAEF,KAAK,EAALA,KAAK;IAAEC,UAAU,EAAVA;EAAU,CAAE,CAAC;AACrD,CAAC;AAEaH,oBAAQ,GAAG,UAACiB,YAAoB,EAAI;EAChD,IAAMH,QAAQ,GAAG,0BAAgB,EAACG,YAAY,CAAC;EAC/C,OAAOjB,WAAW,CAACkB,YAAY,CAACJ,QAAQ,CAAC;AAC3C,CAAC","names":["Keys","CryptoECKey","args","curve","privateKey","data","RegistryType_1","CRYPTO_ECKEY","map","undefined","private","lib_1","toString","RegistryItem_1","exports","dataItem","getData","Error","_cborPayload","fromDataItem"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoECKey.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap, ICryptoKey } from './types';\n\nenum Keys {\n  curve = 1,\n  private,\n  data,\n}\n\nexport class CryptoECKey extends RegistryItem implements ICryptoKey {\n  private data: Buffer;\n  private curve: number | undefined;\n  private privateKey: boolean | undefined;\n  constructor(args: { data: Buffer; curve?: number; privateKey?: boolean }) {\n    super();\n    this.data = args.data;\n    this.curve = args.curve;\n    this.privateKey = args.privateKey || undefined;\n  }\n\n  isECKey = () => {\n    return true;\n  };\n\n  public getCurve = () => this.curve || 0;\n  public isPrivateKey = () => this.privateKey || false;\n  public getData = () => this.data;\n\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_ECKEY;\n  };\n\n  toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.curve) {\n      map[Keys.curve] = this.curve;\n    }\n    if (this.privateKey !== undefined) {\n      map[Keys.private] = this.privateKey;\n    }\n    map[Keys.data] = this.data;\n    return new DataItem(map);\n  };\n\n  getOutputDescriptorContent = () => {\n    return this.data.toString('hex');\n  }\n\n  static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const curve = map[Keys.curve];\n    const privateKey = map[Keys.private];\n    const data = map[Keys.data];\n    if (!data) {\n      throw new Error(\n        `#[ur-registry][CryptoECKey][fn.fromDataItem]: decoded [dataItem][#data.data] is undefined: ${dataItem}`,\n      );\n    }\n    return new CryptoECKey({ data, curve, privateKey });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoECKey.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}