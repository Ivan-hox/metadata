{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapsTypeMap = exports.map = void 0;\nvar types_1 = require(\"../types\");\nvar numbers_1 = require(\"./numbers\");\nvar utils_1 = require(\"../utils\");\nvar assert_1 = require(\"assert\");\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * NOTE: that it is not exported as no fixed size map exists but will have to\n * be derived from data or value instead.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the De/Serializers for the key element types\n * @param valElement the De/Serializers for the value element types\n * @param len amount of entries in the map\n *\n * @category beet/composite\n * @private\n */\nfunction fixedSizeMap(keyElement, valElement, fixedElements, len) {\n  var keyElementFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  var valElementFixed = (0, types_1.isFixedSizeBeet)(valElement);\n  function determineSizes() {\n    if (keyElementFixed && valElementFixed) {\n      var _elementByteSize = keyElement.byteSize + valElement.byteSize;\n      return {\n        elementByteSize: _elementByteSize,\n        byteSize: 4 + len * _elementByteSize\n      };\n    } else if (keyElementFixed) {\n      var valsByteSize = 0;\n      var _iterator = _createForOfIteratorHelper(fixedElements.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            _ = _step$value[0],\n            v = _step$value[1];\n          valsByteSize += v.byteSize;\n        }\n        // If any element has a dynamic size all we can do here is take an average\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _elementByteSize2 = keyElement.byteSize + Math.ceil(valsByteSize / len);\n      return {\n        elementByteSize: _elementByteSize2,\n        byteSize: 4 + keyElement.byteSize * len + valsByteSize\n      };\n    } else if (valElementFixed) {\n      var keysByteSize = 0;\n      var _iterator2 = _createForOfIteratorHelper(fixedElements.values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            k = _step2$value[0],\n            _2 = _step2$value[1];\n          keysByteSize += k.byteSize;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _elementByteSize3 = Math.ceil(keysByteSize / len) + valElement.byteSize;\n      return {\n        elementByteSize: _elementByteSize3,\n        byteSize: 4 + keysByteSize + valElement.byteSize * len\n      };\n    } else {\n      var _keysByteSize = 0;\n      var _valsByteSize = 0;\n      var _iterator3 = _createForOfIteratorHelper(fixedElements.values()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            _k = _step3$value[0],\n            _v = _step3$value[1];\n          _keysByteSize += _k.byteSize;\n          _valsByteSize += _v.byteSize;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _elementByteSize4 = Math.ceil(_keysByteSize / len + _valsByteSize / len);\n      return {\n        elementByteSize: _elementByteSize4,\n        byteSize: 4 + _keysByteSize + _valsByteSize\n      };\n    }\n  }\n  var _determineSizes = determineSizes(),\n    elementByteSize = _determineSizes.elementByteSize,\n    byteSize = _determineSizes.byteSize;\n  return {\n    write: function write(buf, offset, map) {\n      // Write the values first and then the size as it comes clear while we do the former\n      var cursor = offset + 4;\n      var size = 0;\n      var _iterator4 = _createForOfIteratorHelper(map.entries()),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n            k = _step4$value[0],\n            v = _step4$value[1];\n          var fixedKey = keyElementFixed ? keyElement : null;\n          var fixedVal = valElementFixed ? valElement : null;\n          if (fixedKey == null || fixedVal == null) {\n            // When we write the value we know the key and an just pull the\n            // matching fixed beet for key/val from the provided map which is\n            // faster than fixing it by value\n            var els = fixedElements.get(k);\n            (0, assert_1.strict)(els != null, \"Should be able to find beet els for \".concat((0, utils_1.stringify)(k), \", but could not\"));\n            fixedKey !== null && fixedKey !== void 0 ? fixedKey : fixedKey = els[0];\n            fixedVal !== null && fixedVal !== void 0 ? fixedVal : fixedVal = els[1];\n          }\n          fixedKey.write(buf, cursor, k);\n          cursor += fixedKey.byteSize;\n          fixedVal.write(buf, cursor, v);\n          cursor += fixedVal.byteSize;\n          size++;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      numbers_1.u32.write(buf, offset, size);\n      assert_1.strict.equal(size, len, \"Expected map to have size \".concat(len, \", but has \").concat(size, \".\"));\n    },\n    read: function read(buf, offset) {\n      var size = numbers_1.u32.read(buf, offset);\n      assert_1.strict.equal(size, len, \"Expected map to have size \".concat(len, \", but has \").concat(size, \".\"));\n      var cursor = offset + 4;\n      var map = new Map();\n      for (var i = 0; i < size; i++) {\n        // When we read the value from a buffer we don't know the key we're\n        // reading yet and thus cannot use the provided map of fixed\n        // de/serializers.\n        // Therefore we obtain it by fixing it by data instead.\n        var fixedKey = keyElementFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        var k = fixedKey.read(buf, cursor);\n        cursor += fixedKey.byteSize;\n        var fixedVal = valElementFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n        var v = fixedVal.read(buf, cursor);\n        cursor += fixedVal.byteSize;\n        map.set(k, v);\n      }\n      return map;\n    },\n    elementByteSize: elementByteSize,\n    byteSize: byteSize,\n    length: len,\n    lenPrefixByteSize: 4,\n    description: \"Map<\".concat(keyElement.description, \", \").concat(valElement.description, \">\")\n  };\n}\n/**\n * De/Serializes a map with a specific number of key/values of type {@link K}\n * and {@link V} respectively.\n *\n * @template K type of key elements held in the map\n * @template V type of value elements held in the map\n *\n * @param keyElement the _fixable_ or _fixed_ de/serializers for the key element types\n * @param valElement the _fixable_ or _fixed_ de/serializers for the value element types\n *\n * @category beet/composite\n */\nfunction map(keyElement, valElement) {\n  var keyIsFixed = (0, types_1.isFixedSizeBeet)(keyElement);\n  var valIsFixed = (0, types_1.isFixedSizeBeet)(valElement);\n  return {\n    toFixedFromData: function toFixedFromData(buf, offset) {\n      var len = numbers_1.u32.read(buf, offset);\n      var cursor = offset + 4;\n      // Shortcut for the case that both key and value are fixed size beets\n      if (keyIsFixed && valIsFixed) {\n        return fixedSizeMap(keyElement, valElement, new Map(), len);\n      }\n      // If either key or val are not fixed size beets we need to determine the\n      // fixed versions and add them to a map by key\n      var fixedBeets = new Map();\n      for (var i = 0; i < len; i++) {\n        var keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromData(buf, cursor);\n        var key = keyFixed.read(buf, cursor);\n        cursor += keyFixed.byteSize;\n        var valFixed = valIsFixed ? valElement : valElement.toFixedFromData(buf, cursor);\n        cursor += valFixed.byteSize;\n        fixedBeets.set(key, [keyFixed, valFixed]);\n      }\n      return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n    },\n    toFixedFromValue: function toFixedFromValue(mapVal) {\n      var len = mapVal.size;\n      // As above shortcut for the optimal case and build a map for all others\n      if (keyIsFixed && valIsFixed) {\n        return fixedSizeMap(keyElement, valElement, new Map(), len);\n      }\n      var fixedBeets = new Map();\n      var _iterator5 = _createForOfIteratorHelper(mapVal),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n            k = _step5$value[0],\n            v = _step5$value[1];\n          var keyFixed = keyIsFixed ? keyElement : keyElement.toFixedFromValue(k);\n          var valFixed = valIsFixed ? valElement : valElement.toFixedFromValue(v);\n          fixedBeets.set(k, [keyFixed, valFixed]);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return fixedSizeMap(keyElement, valElement, fixedBeets, len);\n    },\n    description: \"FixableMap<\".concat(keyElement.description, \", \").concat(valElement.description, \">\")\n  };\n}\nexports.map = map;\n/**\n * Maps maps beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.mapsTypeMap = {\n  Map: {\n    beet: 'map',\n    isFixable: true,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'Map'\n  }\n};","map":{"version":3,"mappings":"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","names":["fixedSizeMap","keyElement","valElement","fixedElements","len","keyElementFixed","valElementFixed","determineSizes","elementByteSize","byteSize","valsByteSize","values","_","v","Math","ceil","keysByteSize","k","write","buf","offset","map","cursor","size","entries","fixedKey","fixedVal","els","get","numbers_1","assert_1","equal","read","Map","i","toFixedFromData","set","length","lenPrefixByteSize","description","keyIsFixed","valIsFixed","fixedBeets","keyFixed","key","valFixed","toFixedFromValue","mapVal","exports","beet","isFixable","sourcePack","types_1","ts"],"sources":["../../../../src/beets/maps.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}