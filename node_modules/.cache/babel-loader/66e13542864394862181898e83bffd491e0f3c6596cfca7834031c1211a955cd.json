{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"signers\"];\nimport { BaseWalletAdapter } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction } from './types.js';\nexport var BaseSignerWalletAdapter = /*#__PURE__*/function (_BaseWalletAdapter) {\n  _inherits(BaseSignerWalletAdapter, _BaseWalletAdapter);\n  var _super = _createSuper(BaseSignerWalletAdapter);\n  function BaseSignerWalletAdapter() {\n    _classCallCheck(this, BaseSignerWalletAdapter);\n    return _super.apply(this, arguments);\n  }\n  _createClass(BaseSignerWalletAdapter, [{\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(transaction, connection) {\n        var options,\n          emit,\n          rawTransaction,\n          _transaction,\n          signers,\n          sendOptions,\n          _rawTransaction,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n                emit = true;\n                _context.prev = 2;\n                if (!isVersionedTransaction(transaction)) {\n                  _context.next = 26;\n                  break;\n                }\n                if (this.supportedTransactionVersions) {\n                  _context.next = 6;\n                  break;\n                }\n                throw new WalletSendTransactionError(\"Sending versioned transactions isn't supported by this wallet\");\n              case 6:\n                if (this.supportedTransactionVersions.has(transaction.version)) {\n                  _context.next = 8;\n                  break;\n                }\n                throw new WalletSendTransactionError(\"Sending transaction version \".concat(transaction.version, \" isn't supported by this wallet\"));\n              case 8:\n                _context.prev = 8;\n                _context.next = 11;\n                return this.signTransaction(transaction);\n              case 11:\n                transaction = _context.sent;\n                rawTransaction = transaction.serialize();\n                _context.next = 15;\n                return connection.sendRawTransaction(rawTransaction, options);\n              case 15:\n                return _context.abrupt(\"return\", _context.sent);\n              case 18:\n                _context.prev = 18;\n                _context.t0 = _context[\"catch\"](8);\n                if (!(_context.t0 instanceof WalletSignTransactionError)) {\n                  _context.next = 23;\n                  break;\n                }\n                emit = false;\n                throw _context.t0;\n              case 23:\n                throw new WalletSendTransactionError(_context.t0 === null || _context.t0 === void 0 ? void 0 : _context.t0.message, _context.t0);\n              case 24:\n                _context.next = 47;\n                break;\n              case 26:\n                _context.prev = 26;\n                signers = options.signers, sendOptions = _objectWithoutProperties(options, _excluded);\n                _context.next = 30;\n                return this.prepareTransaction(transaction, connection, sendOptions);\n              case 30:\n                transaction = _context.sent;\n                (signers === null || signers === void 0 ? void 0 : signers.length) && (_transaction = transaction).partialSign.apply(_transaction, _toConsumableArray(signers));\n                _context.next = 34;\n                return this.signTransaction(transaction);\n              case 34:\n                transaction = _context.sent;\n                _rawTransaction = transaction.serialize();\n                _context.next = 38;\n                return connection.sendRawTransaction(_rawTransaction, sendOptions);\n              case 38:\n                return _context.abrupt(\"return\", _context.sent);\n              case 41:\n                _context.prev = 41;\n                _context.t1 = _context[\"catch\"](26);\n                if (!(_context.t1 instanceof WalletSignTransactionError)) {\n                  _context.next = 46;\n                  break;\n                }\n                emit = false;\n                throw _context.t1;\n              case 46:\n                throw new WalletSendTransactionError(_context.t1 === null || _context.t1 === void 0 ? void 0 : _context.t1.message, _context.t1);\n              case 47:\n                _context.next = 53;\n                break;\n              case 49:\n                _context.prev = 49;\n                _context.t2 = _context[\"catch\"](2);\n                if (emit) {\n                  this.emit('error', _context.t2);\n                }\n                throw _context.t2;\n              case 53:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 49], [8, 18], [26, 41]]);\n      }));\n      function sendTransaction(_x, _x2) {\n        return _sendTransaction.apply(this, arguments);\n      }\n      return sendTransaction;\n    }()\n  }, {\n    key: \"signAllTransactions\",\n    value: function () {\n      var _signAllTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transactions) {\n        var _iterator, _step, transaction, signedTransactions, _iterator2, _step2, _transaction2;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(transactions);\n                _context2.prev = 1;\n                _iterator.s();\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context2.next = 12;\n                  break;\n                }\n                transaction = _step.value;\n                if (!isVersionedTransaction(transaction)) {\n                  _context2.next = 10;\n                  break;\n                }\n                if (this.supportedTransactionVersions) {\n                  _context2.next = 8;\n                  break;\n                }\n                throw new WalletSignTransactionError(\"Signing versioned transactions isn't supported by this wallet\");\n              case 8:\n                if (this.supportedTransactionVersions.has(transaction.version)) {\n                  _context2.next = 10;\n                  break;\n                }\n                throw new WalletSignTransactionError(\"Signing transaction version \".concat(transaction.version, \" isn't supported by this wallet\"));\n              case 10:\n                _context2.next = 3;\n                break;\n              case 12:\n                _context2.next = 17;\n                break;\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](1);\n                _iterator.e(_context2.t0);\n              case 17:\n                _context2.prev = 17;\n                _iterator.f();\n                return _context2.finish(17);\n              case 20:\n                signedTransactions = [];\n                _iterator2 = _createForOfIteratorHelper(transactions);\n                _context2.prev = 22;\n                _iterator2.s();\n              case 24:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context2.next = 33;\n                  break;\n                }\n                _transaction2 = _step2.value;\n                _context2.t1 = signedTransactions;\n                _context2.next = 29;\n                return this.signTransaction(_transaction2);\n              case 29:\n                _context2.t2 = _context2.sent;\n                _context2.t1.push.call(_context2.t1, _context2.t2);\n              case 31:\n                _context2.next = 24;\n                break;\n              case 33:\n                _context2.next = 38;\n                break;\n              case 35:\n                _context2.prev = 35;\n                _context2.t3 = _context2[\"catch\"](22);\n                _iterator2.e(_context2.t3);\n              case 38:\n                _context2.prev = 38;\n                _iterator2.f();\n                return _context2.finish(38);\n              case 41:\n                return _context2.abrupt(\"return\", signedTransactions);\n              case 42:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 14, 17, 20], [22, 35, 38, 41]]);\n      }));\n      function signAllTransactions(_x3) {\n        return _signAllTransactions.apply(this, arguments);\n      }\n      return signAllTransactions;\n    }()\n  }]);\n  return BaseSignerWalletAdapter;\n}(BaseWalletAdapter);\nexport var BaseMessageSignerWalletAdapter = /*#__PURE__*/function (_BaseSignerWalletAdap) {\n  _inherits(BaseMessageSignerWalletAdapter, _BaseSignerWalletAdap);\n  var _super2 = _createSuper(BaseMessageSignerWalletAdapter);\n  function BaseMessageSignerWalletAdapter() {\n    _classCallCheck(this, BaseMessageSignerWalletAdapter);\n    return _super2.apply(this, arguments);\n  }\n  return _createClass(BaseMessageSignerWalletAdapter);\n}(BaseSignerWalletAdapter);","map":{"version":3,"mappings":"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","names":["BaseWalletAdapter","WalletSendTransactionError","WalletSignTransactionError","isVersionedTransaction","BaseSignerWalletAdapter","transaction","connection","options","emit","supportedTransactionVersions","has","version","signTransaction","rawTransaction","serialize","sendRawTransaction","message","signers","sendOptions","prepareTransaction","length","partialSign","transactions","signedTransactions","push","BaseMessageSignerWalletAdapter"],"sources":["/Users/ivan/Metadata/node_modules/@solana/wallet-adapter-base/src/signer.ts"],"sourcesContent":["import type { Connection, TransactionSignature } from '@solana/web3.js';\nimport type { SendTransactionOptions, WalletAdapter, WalletAdapterProps } from './adapter.js';\nimport { BaseWalletAdapter } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport type { TransactionOrVersionedTransaction } from './types.js';\nimport { isVersionedTransaction } from './types.js';\n\nexport interface SignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n    signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]>;\n}\n\nexport type SignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> & SignerWalletAdapterProps<Name>;\n\nexport abstract class BaseSignerWalletAdapter<Name extends string = string>\n    extends BaseWalletAdapter<Name>\n    implements SignerWalletAdapter<Name>\n{\n    async sendTransaction(\n        transaction: TransactionOrVersionedTransaction<this['supportedTransactionVersions']>,\n        connection: Connection,\n        options: SendTransactionOptions = {}\n    ): Promise<TransactionSignature> {\n        let emit = true;\n        try {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(\n                        `Sending versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(\n                        `Sending transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n\n                try {\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            } else {\n                try {\n                    const { signers, ...sendOptions } = options;\n\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n\n                    signers?.length && transaction.partialSign(...signers);\n\n                    transaction = await this.signTransaction(transaction);\n\n                    const rawTransaction = transaction.serialize();\n\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                } catch (error: any) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        } catch (error: any) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n\n    abstract signTransaction<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transaction: T\n    ): Promise<T>;\n\n    async signAllTransactions<T extends TransactionOrVersionedTransaction<this['supportedTransactionVersions']>>(\n        transactions: T[]\n    ): Promise<T[]> {\n        for (const transaction of transactions) {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(\n                        `Signing versioned transactions isn't supported by this wallet`\n                    );\n\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(\n                        `Signing transaction version ${transaction.version} isn't supported by this wallet`\n                    );\n            }\n        }\n\n        const signedTransactions: T[] = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\n\nexport interface MessageSignerWalletAdapterProps<Name extends string = string> extends WalletAdapterProps<Name> {\n    signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n\nexport type MessageSignerWalletAdapter<Name extends string = string> = WalletAdapter<Name> &\n    MessageSignerWalletAdapterProps<Name>;\n\nexport abstract class BaseMessageSignerWalletAdapter<Name extends string = string>\n    extends BaseSignerWalletAdapter<Name>\n    implements MessageSignerWalletAdapter<Name>\n{\n    abstract signMessage(message: Uint8Array): Promise<Uint8Array>;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}