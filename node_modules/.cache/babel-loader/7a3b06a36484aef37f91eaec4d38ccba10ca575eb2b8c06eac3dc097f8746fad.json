{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoMultiAccounts = void 0;\nvar RegistryType_1 = require(\"../RegistryType\");\nvar CryptoHDKey_1 = require(\"../CryptoHDKey\");\nvar RegistryItem_1 = require(\"../RegistryItem\");\nvar lib_1 = require(\"../lib\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n  Keys[Keys[\"keys\"] = 2] = \"keys\";\n  Keys[Keys[\"device\"] = 3] = \"device\";\n})(Keys || (Keys = {}));\nvar CryptoMultiAccounts = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoMultiAccounts, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoMultiAccounts);\n  function CryptoMultiAccounts(masterFingerprint, keys, device) {\n    var _this;\n    _classCallCheck(this, CryptoMultiAccounts);\n    _this = _super.call(this);\n    _this.masterFingerprint = masterFingerprint;\n    _this.keys = keys;\n    _this.device = device;\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_MULTI_ACCOUNTS;\n    };\n    _this.getMasterFingerprint = function () {\n      return _this.masterFingerprint;\n    };\n    _this.getKeys = function () {\n      return _this.keys;\n    };\n    _this.getDevice = function () {\n      return _this.device;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      if (_this.masterFingerprint) {\n        map[Keys.masterFingerprint] = _this.masterFingerprint.readUInt32BE(0);\n      }\n      if (_this.keys) {\n        map[Keys.keys] = _this.keys.map(function (item) {\n          var dataItem = item.toDataItem();\n          dataItem.setTag(item.getRegistryType().getTag());\n          return dataItem;\n        });\n      }\n      if (_this.device) {\n        map[Keys.device] = _this.device;\n      }\n      return new lib_1.DataItem(map);\n    };\n    return _this;\n  }\n  return _createClass(CryptoMultiAccounts);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoMultiAccounts = CryptoMultiAccounts;\nCryptoMultiAccounts.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var masterFingerprint = Buffer.alloc(4);\n  var _masterFingerprint = map[Keys.masterFingerprint];\n  if (_masterFingerprint) {\n    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n  }\n  var keys = map[Keys.keys];\n  var cryptoHDKeys = keys.map(function (item) {\n    return CryptoHDKey_1.CryptoHDKey.fromDataItem(item);\n  });\n  var device = map[Keys.device];\n  return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);\n};\nCryptoMultiAccounts.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoMultiAccounts.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA,IAAKA,IAIJ;AAJD,WAAKA,IAAI;EACPA,yDAAqB;EACrBA,+BAAI;EACJA,mCAAM;AACR,CAAC,EAJIA,IAAI,KAAJA,IAAI;AAIR,IAEYC,mBAAoB;EAAA;EAAA;EAG/B,6BACUC,iBAAyB,EACzBC,IAAmB,EACnBC,MAAe;IAAA;IAAA;IAEvB;IAJQ,uBAAiB,GAAjBF,iBAAiB;IACjB,UAAI,GAAJC,IAAI;IACJ,YAAM,GAANC,MAAM;IALhB,qBAAe,GAAG;MAAA,OAAMC,4BAAa,CAACC,qBAAqB;IAAA;IAUpD,0BAAoB,GAAG;MAAA,OAAM,MAAKJ,iBAAiB;IAAA;IACnD,aAAO,GAAG;MAAA,OAAM,MAAKC,IAAI;IAAA;IACzB,eAAS,GAAG;MAAA,OAAM,MAAKC,MAAM;IAAA;IAE7B,gBAAU,GAAG,YAAe;MACjC,IAAMG,GAAG,GAAgB,EAAE;MAC3B,IAAI,MAAKL,iBAAiB,EAAE;QAC1BK,GAAG,CAACP,IAAI,CAACE,iBAAiB,CAAC,GAAG,MAAKA,iBAAiB,CAACM,YAAY,CAAC,CAAC,CAAC;;MAEtE,IAAI,MAAKL,IAAI,EAAE;QACbI,GAAG,CAACP,IAAI,CAACG,IAAI,CAAC,GAAG,MAAKA,IAAI,CAACI,GAAG,CAAC,UAACE,IAAI,EAAI;UACtC,IAAMC,QAAQ,GAAGD,IAAI,CAACE,UAAU,EAAE;UAClCD,QAAQ,CAACE,MAAM,CAACH,IAAI,CAACI,eAAe,EAAE,CAACC,MAAM,EAAE,CAAC;UAChD,OAAOJ,QAAQ;QACjB,CAAC,CAAC;;MAEJ,IAAI,MAAKN,MAAM,EAAE;QACfG,GAAG,CAACP,IAAI,CAACI,MAAM,CAAC,GAAG,MAAKA,MAAM;;MAEhC,OAAO,IAAIW,cAAQ,CAACR,GAAG,CAAC;IAC1B,CAAC;IAAC;EAtBF;EAAC;AAAA,EATsCS,2BAAY;AAArDC;AAiCgBhB,gCAAY,GAAG,UAACS,QAAkB,EAAI;EAClD,IAAMH,GAAG,GAAGG,QAAQ,CAACQ,OAAO,EAAE;EAC9B,IAAMhB,iBAAiB,GAAGiB,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACzC,IAAMC,kBAAkB,GAAGd,GAAG,CAACP,IAAI,CAACE,iBAAiB,CAAC;EACtD,IAAImB,kBAAkB,EAAE;IACtBnB,iBAAiB,CAACoB,aAAa,CAACD,kBAAkB,EAAE,CAAC,CAAC;;EAExD,IAAMlB,IAAI,GAAGI,GAAG,CAACP,IAAI,CAACG,IAAI,CAAe;EACzC,IAAMoB,YAAY,GAAGpB,IAAI,CAACI,GAAG,CAAC,UAACE,IAAI;IAAA,OAAKe,yBAAW,CAACC,YAAY,CAAChB,IAAI,CAAC;EAAA,EAAC;EACvE,IAAML,MAAM,GAAGG,GAAG,CAACP,IAAI,CAACI,MAAM,CAAC;EAC/B,OAAO,IAAIH,mBAAmB,CAACC,iBAAiB,EAAEqB,YAAY,EAAEnB,MAAM,CAAC;AACzE,CAAC;AAEaH,4BAAQ,GAAG,UAACyB,YAAoB,EAAI;EAChD,IAAMhB,QAAQ,GAAG,0BAAgB,EAACgB,YAAY,CAAC;EAC/C,OAAOzB,mBAAmB,CAACwB,YAAY,CAACf,QAAQ,CAAC;AACnD,CAAC","names":["Keys","CryptoMultiAccounts","masterFingerprint","keys","device","RegistryType_1","CRYPTO_MULTI_ACCOUNTS","map","readUInt32BE","item","dataItem","toDataItem","setTag","getRegistryType","getTag","lib_1","RegistryItem_1","exports","getData","Buffer","alloc","_masterFingerprint","writeUInt32BE","cryptoHDKeys","CryptoHDKey_1","fromDataItem","_cborPayload"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/extended/CryptoMultiAccounts.ts"],"sourcesContent":["import {RegistryTypes} from \"../RegistryType\";\nimport {CryptoHDKey} from \"../CryptoHDKey\";\nimport {RegistryItem} from \"../RegistryItem\";\nimport {decodeToDataItem,DataItem} from '../lib';\nimport {DataItemMap} from '../types';\nenum Keys {\n  masterFingerprint = 1,\n  keys,\n  device,\n}\n\nexport class CryptoMultiAccounts extends RegistryItem {\n  getRegistryType = () => RegistryTypes.CRYPTO_MULTI_ACCOUNTS;\n\n  constructor(\n    private masterFingerprint: Buffer,\n    private keys: CryptoHDKey[],\n    private device?: string\n  ) {\n    super();\n  }\n\n  public getMasterFingerprint = () => this.masterFingerprint;\n  public getKeys = () => this.keys;\n  public getDevice = () => this.device;\n\n  public toDataItem = (): DataItem => {\n    const map: DataItemMap = {};\n    if (this.masterFingerprint) {\n      map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n    }\n    if (this.keys) {\n      map[Keys.keys] = this.keys.map((item) => {\n        const dataItem = item.toDataItem();\n        dataItem.setTag(item.getRegistryType().getTag());\n        return dataItem;\n      });\n    }\n    if (this.device) {\n      map[Keys.device] = this.device;\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const masterFingerprint = Buffer.alloc(4);\n    const _masterFingerprint = map[Keys.masterFingerprint];\n    if (_masterFingerprint) {\n      masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n    }\n    const keys = map[Keys.keys] as DataItem[];\n    const cryptoHDKeys = keys.map((item) => CryptoHDKey.fromDataItem(item));\n    const device = map[Keys.device];\n    return new CryptoMultiAccounts(masterFingerprint, cryptoHDKeys, device);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoMultiAccounts.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}