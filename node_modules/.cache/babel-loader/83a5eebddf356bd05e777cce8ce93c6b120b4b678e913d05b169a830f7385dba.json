{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar t = require(\"@keystonehq/bc-ur-registry\"),\n  e = require(\"uuid\");\nvar s = {\n    SOL_SIGN_REQUEST: new t.RegistryType(\"sol-sign-request\", 1101),\n    SOL_SIGNATURE: new t.RegistryType(\"sol-signature\", 1102),\n    SOL_NFT_ITEM: new t.RegistryType(\"sol-nft-item\", 1104)\n  },\n  _t$extend = t.extend,\n  i = _t$extend.decodeToDataItem,\n  a = _t$extend.RegistryTypes;\nvar r, n;\n(r = exports.SignType || (exports.SignType = {}))[r.Transaction = 1] = \"Transaction\", r[r.Message = 2] = \"Message\", function (t) {\n  t[t.requestId = 1] = \"requestId\", t[t.signData = 2] = \"signData\", t[t.derivationPath = 3] = \"derivationPath\", t[t.address = 4] = \"address\", t[t.origin = 5] = \"origin\", t[t.signType = 6] = \"signType\";\n}(n || (n = {}));\nvar o = /*#__PURE__*/function (_t$RegistryItem) {\n  _inherits(o, _t$RegistryItem);\n  var _super = _createSuper(o);\n  function o(e) {\n    var _this;\n    _classCallCheck(this, o);\n    _this = _super.call(this), _this.getRegistryType = function () {\n      return s.SOL_SIGN_REQUEST;\n    }, _this.getRequestId = function () {\n      return _this.requestId;\n    }, _this.getSignData = function () {\n      return _this.signData;\n    }, _this.getDerivationPath = function () {\n      return _this.derivationPath.getPath();\n    }, _this.getSignRequestAddress = function () {\n      return _this.address;\n    }, _this.getOrigin = function () {\n      return _this.origin;\n    }, _this.getSignType = function () {\n      return _this.signType;\n    }, _this.toDataItem = function () {\n      var e = {};\n      _this.requestId && (e[n.requestId] = new t.DataItem(_this.requestId, a.UUID.getTag())), _this.address && (e[n.address] = _this.address), _this.origin && (e[n.origin] = _this.origin), e[n.signData] = _this.signData, e[n.signType] = _this.signType;\n      var s = _this.derivationPath.toDataItem();\n      return s.setTag(_this.derivationPath.getRegistryType().getTag()), e[n.derivationPath] = s, new t.DataItem(e);\n    }, _this.requestId = e.requestId, _this.signData = e.signData, _this.derivationPath = e.derivationPath, _this.address = e.address, _this.origin = e.origin, _this.signType = e.signType;\n    return _this;\n  }\n  _createClass(o, null, [{\n    key: \"constructSOLRequest\",\n    value: function constructSOLRequest(s, i, a, r, n, d, g) {\n      var m = i.replace(/[m|M]\\//, \"\").split(\"/\"),\n        h = new t.CryptoKeypath(m.map(function (e) {\n          var s = parseInt(e.replace(\"'\", \"\"));\n          var i = !1;\n          return e.endsWith(\"'\") && (i = !0), new t.PathComponent({\n            index: s,\n            hardened: i\n          });\n        }), Buffer.from(a, \"hex\"));\n      return new o({\n        requestId: n ? Buffer.from(e.parse(n)) : void 0,\n        signData: s,\n        derivationPath: h,\n        address: d ? Buffer.from(d.replace(\"0x\", \"\"), \"hex\") : void 0,\n        origin: g || void 0,\n        signType: r\n      });\n    }\n  }]);\n  return o;\n}(t.RegistryItem);\no.fromDataItem = function (e) {\n  var s = e.getData(),\n    i = s[n.signData],\n    a = t.CryptoKeypath.fromDataItem(s[n.derivationPath]),\n    r = s[n.address] ? s[n.address] : void 0,\n    d = s[n.requestId] ? s[n.requestId].getData() : void 0;\n  return new o({\n    requestId: d,\n    signData: i,\n    derivationPath: a,\n    address: r,\n    origin: s[n.origin] ? s[n.origin] : void 0,\n    signType: s[n.signType]\n  });\n}, o.fromCBOR = function (t) {\n  var e = i(t);\n  return o.fromDataItem(e);\n};\nvar _t$extend2 = t.extend,\n  d = _t$extend2.RegistryTypes,\n  g = _t$extend2.decodeToDataItem;\nvar m;\n!function (t) {\n  t[t.requestId = 1] = \"requestId\", t[t.signature = 2] = \"signature\";\n}(m || (m = {}));\nvar h = /*#__PURE__*/function (_t$RegistryItem2) {\n  _inherits(h, _t$RegistryItem2);\n  var _super2 = _createSuper(h);\n  function h(e, i) {\n    var _this2;\n    _classCallCheck(this, h);\n    _this2 = _super2.call(this), _this2.getRegistryType = function () {\n      return s.SOL_SIGNATURE;\n    }, _this2.getRequestId = function () {\n      return _this2.requestId;\n    }, _this2.getSignature = function () {\n      return _this2.signature;\n    }, _this2.toDataItem = function () {\n      var e = {};\n      return _this2.requestId && (e[m.requestId] = new t.DataItem(_this2.requestId, d.UUID.getTag())), e[m.signature] = _this2.signature, new t.DataItem(e);\n    }, _this2.signature = e, _this2.requestId = i;\n    return _this2;\n  }\n  return _createClass(h);\n}(t.RegistryItem);\nh.fromDataItem = function (t) {\n  var e = t.getData(),\n    s = e[m.signature],\n    i = e[m.requestId] ? e[m.requestId].getData() : void 0;\n  return new h(s, i);\n}, h.fromCBOR = function (t) {\n  var e = g(t);\n  return h.fromDataItem(e);\n};\nvar u = t.extend.decodeToDataItem;\nvar c;\n!function (t) {\n  t[t.mintAddress = 1] = \"mintAddress\", t[t.collectionName = 2] = \"collectionName\", t[t.name = 3] = \"name\", t[t.mediaData = 4] = \"mediaData\";\n}(c || (c = {}));\nvar I = /*#__PURE__*/function (_t$RegistryItem3) {\n  _inherits(I, _t$RegistryItem3);\n  var _super3 = _createSuper(I);\n  function I(e) {\n    var _this3;\n    _classCallCheck(this, I);\n    _this3 = _super3.call(this), _this3.getRegistryType = function () {\n      return s.SOL_NFT_ITEM;\n    }, _this3.getName = function () {\n      return _this3.name;\n    }, _this3.getMediaData = function () {\n      return _this3.mediaData;\n    }, _this3.getMintAddress = function () {\n      return _this3.mintAddress;\n    }, _this3.getCollectionName = function () {\n      return _this3.collectionName;\n    }, _this3.toDataItem = function () {\n      var e = {};\n      return e[c.name] = _this3.name, e[c.mintAddress] = _this3.mintAddress, e[c.collectionName] = _this3.collectionName, e[c.mediaData] = _this3.mediaData, new t.DataItem(e);\n    }, _this3.name = e.name, _this3.mintAddress = e.mintAddress, _this3.collectionName = e.collectionName, _this3.mediaData = e.mediaData;\n    return _this3;\n  }\n  _createClass(I, null, [{\n    key: \"constructETHNFTItem\",\n    value: function constructETHNFTItem(t, e, s, i) {\n      return new I({\n        mintAddress: t,\n        collectionName: e,\n        mediaData: i,\n        name: s\n      });\n    }\n  }]);\n  return I;\n}(t.RegistryItem);\nI.fromDataItem = function (t) {\n  var e = t.getData();\n  return new I({\n    name: e[c.name],\n    mintAddress: e[c.mintAddress],\n    collectionName: e[c.collectionName],\n    mediaData: e[c.mediaData]\n  });\n}, I.fromCBOR = function (t) {\n  var e = u(t);\n  return I.fromDataItem(e);\n}, t.patchTags(Object.values(s).filter(function (t) {\n  return !!t.getTag();\n}).map(function (t) {\n  return t.getTag();\n})), Object.keys(t).forEach(function (e) {\n  \"default\" !== e && Object.defineProperty(exports, e, {\n    enumerable: !0,\n    get: function get() {\n      return t[e];\n    }\n  });\n}), exports.SOLNFTItem = I, exports.SolSignRequest = o, exports.SolSignature = h;","map":{"version":3,"mappings":"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","names":["ExtendedRegistryTypes","SOL_SIGN_REQUEST","RegistryType","SOL_SIGNATURE","SOL_NFT_ITEM","extend","decodeToDataItem","RegistryTypes","SignType","Keys","SolSignRequest","constructor","args","this","requestId","signData","derivationPath","getPath","address","origin","signType","map","DataItem","UUID","getTag","keyPath","toDataItem","setTag","getRegistryType","hdPath","xfp","uuidString","paths","replace","split","hdpathObject","CryptoKeypath","path","index","parseInt","isHardened","endsWith","PathComponent","hardened","Buffer","from","uuid","undefined","RegistryItem","dataItem","getData","fromDataItem","_cborPayload","SolSignature","signature","SOLNFTItem","name","mediaData","mintAddress","collectionName","patchTags","Object","values","filter","rt"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry-sol/src/RegistryType.ts","/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry-sol/src/SolSignRequest.ts","/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry-sol/src/SolSignature.ts","/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry-sol/src/SOLNFTItem.ts","/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry-sol/src/index.ts"],"sourcesContent":["import { RegistryType } from \"@keystonehq/bc-ur-registry\";\n\nexport const ExtendedRegistryTypes = {\n  SOL_SIGN_REQUEST: new RegistryType(\"sol-sign-request\", 1101),\n  SOL_SIGNATURE: new RegistryType(\"sol-signature\", 1102),\n  SOL_NFT_ITEM: new RegistryType(\"sol-nft-item\", 1104),\n};\n","import {\n  CryptoKeypath,\n  extend,\n  DataItem,\n  PathComponent,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nimport * as uuid from \"uuid\";\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nexport enum SignType {\n  Transaction = 1,\n  Message = 2,\n}\n\nenum Keys {\n  requestId = 1,\n  signData,\n  derivationPath,\n  address,\n  origin,\n  signType ,\n}\n\ntype signRequestProps = {\n  requestId?: Buffer;\n  signData: Buffer;\n  derivationPath: CryptoKeypath;\n  address?: Buffer;\n  origin?: string;\n  signType: SignType;\n};\n\nexport class SolSignRequest extends RegistryItem {\n  private requestId?: Buffer;\n  private signData: Buffer;\n  private derivationPath: CryptoKeypath;\n  private address?: Buffer;\n  private origin?: string;\n  private signType: SignType;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_SIGN_REQUEST;\n\n  constructor(args: signRequestProps) {\n    super();\n    this.requestId = args.requestId;\n    this.signData = args.signData;\n    this.derivationPath = args.derivationPath;\n    this.address = args.address;\n    this.origin = args.origin;\n    this.signType = args.signType;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignData = () => this.signData;\n  public getDerivationPath = () => this.derivationPath.getPath();\n  public getSignRequestAddress = () => this.address;\n  public getOrigin = () => this.origin;\n  public getSignType = () => this.signType;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    if (this.address) {\n      map[Keys.address] = this.address;\n    }\n\n    if (this.origin) {\n      map[Keys.origin] = this.origin;\n    }\n\n    map[Keys.signData] = this.signData;\n    map[Keys.signType] = this.signType;\n\n    const keyPath = this.derivationPath.toDataItem();\n    keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n    map[Keys.derivationPath] = keyPath;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signData = map[Keys.signData];\n    const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n    const address = map[Keys.address] ? map[Keys.address] : undefined;\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n    const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n    const signType = map[Keys.signType];\n\n    return new SolSignRequest({\n      requestId,\n      signData,\n      derivationPath,\n      address,\n      origin,\n      signType\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SolSignRequest.fromDataItem(dataItem);\n  };\n\n  public static constructSOLRequest(\n    signData: Buffer,\n    hdPath: string,\n    xfp: string,\n    signType: SignType,\n    uuidString?: string,\n    address?: string,\n    origin?: string\n  ) {\n    const paths = hdPath.replace(/[m|M]\\//, \"\").split(\"/\");\n    const hdpathObject = new CryptoKeypath(\n      paths.map((path) => {\n        const index = parseInt(path.replace(\"'\", \"\"));\n        let isHardened = false;\n        if (path.endsWith(\"'\")) {\n          isHardened = true;\n        }\n        return new PathComponent({ index, hardened: isHardened });\n      }),\n      Buffer.from(xfp, \"hex\")\n    );\n\n    return new SolSignRequest({\n      requestId: uuidString\n        ? Buffer.from(uuid.parse(uuidString) as Uint8Array)\n        : undefined,\n      signData,\n      derivationPath: hdpathObject,\n      address: address\n        ? Buffer.from(address.replace(\"0x\", \"\"), \"hex\")\n        : undefined,\n      origin: origin || undefined,\n      signType,\n    });\n  }\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n  requestId = 1,\n  signature,\n}\n\nexport class SolSignature extends RegistryItem {\n  private requestId?: Buffer;\n  private signature: Buffer;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_SIGNATURE;\n\n  constructor(signature: Buffer, requestId?: Buffer) {\n    super();\n    this.signature = signature;\n    this.requestId = requestId;\n  }\n\n  public getRequestId = () => this.requestId;\n  public getSignature = () => this.signature;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.requestId) {\n      map[Keys.requestId] = new DataItem(\n        this.requestId,\n        RegistryTypes.UUID.getTag()\n      );\n    }\n    map[Keys.signature] = this.signature;\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const signature = map[Keys.signature];\n    const requestId = map[Keys.requestId]\n      ? map[Keys.requestId].getData()\n      : undefined;\n\n    return new SolSignature(signature, requestId);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SolSignature.fromDataItem(dataItem);\n  };\n}\n","import {\n  extend,\n  DataItem,\n  RegistryItem,\n  DataItemMap,\n} from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\n\nconst { decodeToDataItem } = extend;\n\nenum Keys {\n  mintAddress = 1,\n  collectionName,\n  name,\n  mediaData,\n}\n\ntype NFTProps = {\n  mintAddress: string;\n  collectionName: string;\n  name: string;\n  mediaData: string;\n};\n\nexport class SOLNFTItem extends RegistryItem {\n  private name: string;\n  private mintAddress: string;\n  private collectionName: string;\n  private mediaData: string;\n\n  getRegistryType = () => ExtendedRegistryTypes.SOL_NFT_ITEM;\n\n  constructor(args: NFTProps) {\n    super();\n    this.name = args.name;\n    this.mintAddress = args.mintAddress;\n    this.collectionName = args.collectionName;\n    this.mediaData = args.mediaData; // remove the data perfix for android usage\n  }\n\n  public getName = () => this.name;\n  public getMediaData = () => this.mediaData;\n  public getMintAddress = () => this.mintAddress;\n  public getCollectionName = () => this.collectionName;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    map[Keys.name] = this.name;\n    map[Keys.mintAddress] = this.mintAddress;\n    map[Keys.collectionName] = this.collectionName;\n    map[Keys.mediaData] = this.mediaData;\n\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const name = map[Keys.name];\n    const mediaData = map[Keys.mediaData];\n    const mintAddress = map[Keys.mintAddress];\n    const collectionName = map[Keys.collectionName];\n\n    return new SOLNFTItem({\n      name,\n      mintAddress,\n      collectionName,\n      mediaData,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return SOLNFTItem.fromDataItem(dataItem);\n  };\n\n  public static constructETHNFTItem(\n    mintAddress: string,\n    collectionName: string,\n    name: string,\n    mediaData: string\n  ) {\n    return new SOLNFTItem({\n      mintAddress,\n      collectionName,\n      mediaData,\n      name,\n    });\n  }\n}\n","import { patchTags } from \"@keystonehq/bc-ur-registry\";\nimport { ExtendedRegistryTypes } from \"./RegistryType\";\nexport * from \"@keystonehq/bc-ur-registry\";\n\npatchTags(\n  Object.values(ExtendedRegistryTypes)\n    .filter((rt) => !!rt.getTag())\n    .map((rt) => rt.getTag()) as number[]\n);\n\nexport { SolSignRequest, SignType } from \"./SolSignRequest\";\nexport { SolSignature } from \"./SolSignature\";\nexport { SOLNFTItem } from \"./SOLNFTItem\";\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}