{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _excluded = [\"__kind\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enumsTypeMap = exports.dataEnum = exports.uniformDataEnum = exports.fixedScalarEnum = void 0;\nvar types_1 = require(\"../types\");\nvar numbers_1 = require(\"./numbers\");\nvar assert_1 = require(\"assert\");\nvar struct_1 = require(\"../struct\");\nvar struct_fixable_1 = require(\"../struct.fixable\");\nvar unit_1 = require(\"./unit\");\n// -----------------\n// Fixed Scalar Enum\n// -----------------\nfunction resolveEnumVariant(value, isNumVariant) {\n  return isNumVariant ? \"\".concat(value) : value;\n}\n/**\n * De/serializer for enums with up to 255 less variants which have no data.\n *\n * @param enumType type of enum to process, i.e. Color or Direction\n *\n * @category beet/enum\n */\nfunction fixedScalarEnum(enumType) {\n  var keys = Object.keys(enumType);\n  return {\n    write: function write(buf, offset, value) {\n      var isNumVariant = typeof value === 'number';\n      var variantKey = resolveEnumVariant(value, isNumVariant);\n      if (!keys.includes(variantKey)) {\n        assert_1.strict.fail(\"\".concat(value, \" should be a variant of the provided enum type, i.e. [ \").concat(Object.values(enumType).join(', '), \" ], but isn't\"));\n      }\n      if (isNumVariant) {\n        numbers_1.u8.write(buf, offset, value);\n      } else {\n        var enumValue = enumType[variantKey];\n        numbers_1.u8.write(buf, offset, enumValue);\n      }\n    },\n    read: function read(buf, offset) {\n      var value = numbers_1.u8.read(buf, offset);\n      var isNumVariant = typeof value === 'number';\n      var variantKey = resolveEnumVariant(value, isNumVariant);\n      if (!keys.includes(variantKey)) {\n        assert_1.strict.fail(\"\".concat(value, \" should be a of a variant of the provided enum type, i.e. [ \").concat(Object.values(enumType).join(', '), \" ], but isn't\"));\n      }\n      return isNumVariant ? value : enumType[variantKey];\n    },\n    byteSize: numbers_1.u8.byteSize,\n    description: 'Enum'\n  };\n}\nexports.fixedScalarEnum = fixedScalarEnum;\n/**\n * De/Serializes an {@link Enum} that contains a type of data, i.e. a {@link Struct}.\n * The main difference to a Rust enum is that the type of data has to be the\n * same for all enum variants.\n *\n * @template T inner enum data type\n *\n * @param inner the De/Serializer for the data type\n *\n * @category beet/enum\n */\nfunction uniformDataEnum(inner) {\n  return {\n    write: function write(buf, offset, value) {\n      numbers_1.u8.write(buf, offset, value.kind);\n      inner.write(buf, offset + 1, value.data);\n    },\n    read: function read(buf, offset) {\n      var kind = numbers_1.u8.read(buf, offset);\n      var data = inner.read(buf, offset + 1);\n      return {\n        kind: kind,\n        data: data\n      };\n    },\n    byteSize: 1 + inner.byteSize,\n    description: \"UniformDataEnum<\".concat(inner.description, \">\")\n  };\n}\nexports.uniformDataEnum = uniformDataEnum;\nfunction enumDataVariantBeet(inner, discriminant, kind) {\n  return {\n    write: function write(buf, offset, value) {\n      numbers_1.u8.write(buf, offset, discriminant);\n      inner.write(buf, offset + numbers_1.u8.byteSize, value);\n    },\n    read: function read(buf, offset) {\n      var val = inner.read(buf, offset + numbers_1.u8.byteSize);\n      return _objectSpread({\n        __kind: kind\n      }, val);\n    },\n    byteSize: inner.byteSize + numbers_1.u8.byteSize,\n    description: \"EnumData<\".concat(inner.description, \">\")\n  };\n}\n/**\n * De/serializes Data Enums.\n * They are represented as a discriminated unions in TypeScript.\n *\n * NOTE: only structs, i.e. {@link BeetArgsStruct} and\n * {@link FixableBeetArgsStruct} are supported as the data of each enum variant.\n *\n * ## Example\n *\n * ```ts\n * type Simple = {\n *   First: { n1: number }\n *   Second: { n2: number }\n * }\n *\n * const beet = dataEnum<Simple>([\n *   ['First', new BeetArgsStruct<Simple['First']>([['n1', u32]])],\n *   ['Second', new BeetArgsStruct<Simple['Second']>([['n2', u32]])],\n * ])\n * ```\n *\n * @category beet/enum\n * @param variants an array of {@link DataEnumBeet}s each a tuple of `[ kind, data ]`\n */\nfunction dataEnum(variants) {\n  var _iterator = _createForOfIteratorHelper(variants),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        _ = _step$value[0],\n        beet = _step$value[1];\n      (0, assert_1.strict)((0, struct_1.isBeetStruct)(beet) || (0, struct_fixable_1.isFixableBeetStruct)(beet) ||\n      // scalar variant\n      beet === unit_1.unit, 'dataEnum: variants must be a data beet struct or a scalar unit');\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    toFixedFromData: function toFixedFromData(buf, offset) {\n      var discriminant = numbers_1.u8.read(buf, offset);\n      var variant = variants[discriminant];\n      (0, assert_1.strict)(variant != null, \"Discriminant \".concat(discriminant, \" out of range for \").concat(variants.length, \" variants\"));\n      var _variant = _slicedToArray(variant, 2),\n        __kind = _variant[0],\n        dataBeet = _variant[1];\n      var fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromData(buf, offset + 1);\n      return enumDataVariantBeet(fixed, discriminant, __kind);\n    },\n    toFixedFromValue: function toFixedFromValue(val) {\n      if (val.__kind == null) {\n        var keys = Object.keys(val).join(', ');\n        var validKinds = variants.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n            __kind = _ref2[0];\n          return __kind;\n        }).join(', ');\n        assert_1.strict.fail(\"Value with fields [ \".concat(keys, \" ] is missing __kind, \") + \"which needs to be set to one of [ \".concat(validKinds, \" ]\"));\n      }\n      var discriminant = variants.findIndex(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n          __kind = _ref4[0];\n        return __kind === val.__kind;\n      });\n      if (discriminant < 0) {\n        var _validKinds = variants.map(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 1),\n            __kind = _ref6[0];\n          return __kind;\n        }).join(', ');\n        assert_1.strict.fail(\"\".concat(val.__kind, \" is not a valid kind, needs to be one of [ \").concat(_validKinds, \" ]\"));\n      }\n      var variant = variants[discriminant];\n      var __kind = val.__kind,\n        dataValue = _objectWithoutProperties(val, _excluded);\n      var _variant2 = _slicedToArray(variant, 2),\n        __variantKind = _variant2[0],\n        dataBeet = _variant2[1];\n      var fixed = (0, types_1.isFixedSizeBeet)(dataBeet) ? dataBeet : dataBeet.toFixedFromValue(dataValue);\n      return enumDataVariantBeet(fixed, discriminant, __variantKind);\n    },\n    description: \"DataEnum<\".concat(variants.length, \" variants>\")\n  };\n}\nexports.dataEnum = dataEnum;\n/**\n * Maps composite beet exports to metadata which describes in which package it\n * is defined as well as which TypeScript type is used to represent the\n * deserialized value in JavaScript.\n *\n * @category TypeDefinition\n */\nexports.enumsTypeMap = {\n  fixedScalarEnum: {\n    beet: 'fixedScalarEnum',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: '<TypeName>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_1.BEET_PACKAGE\n  },\n  dataEnum: {\n    beet: 'dataEnum',\n    isFixable: false,\n    sourcePack: types_1.BEET_PACKAGE,\n    ts: 'DataEnum<Kind, Inner>',\n    arg: types_1.BEET_TYPE_ARG_INNER,\n    pack: types_1.BEET_PACKAGE\n  }\n};","map":{"version":3,"mappings":"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","names":["resolveEnumVariant","value","isNumVariant","fixedScalarEnum","enumType","keys","Object","write","buf","offset","variantKey","includes","assert_1","fail","values","join","numbers_1","enumValue","read","byteSize","description","exports","uniformDataEnum","inner","kind","data","enumDataVariantBeet","discriminant","val","__kind","dataEnum","variants","_","beet","unit_1","toFixedFromData","variant","length","dataBeet","fixed","toFixedFromValue","validKinds","map","findIndex","dataValue","__variantKind","isFixable","sourcePack","types_1","ts","arg","pack"],"sources":["../../../../src/beets/enums.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}