{"ast":null,"code":"\"use strict\";\n\nvar _toArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeHarvestWithheldTokensToMintInstructionUnchecked = exports.decodeHarvestWithheldTokensToMintInstruction = exports.createHarvestWithheldTokensToMintInstruction = exports.harvestWithheldTokensToMintInstructionData = exports.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = exports.decodeWithdrawWithheldTokensFromAccountsInstruction = exports.createWithdrawWithheldTokensFromAccountsInstruction = exports.withdrawWithheldTokensFromAccountsInstructionData = exports.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = exports.decodeWithdrawWithheldTokensFromMintInstruction = exports.createWithdrawWithheldTokensFromMintInstruction = exports.withdrawWithheldTokensFromMintInstructionData = exports.decodeTransferCheckedWithFeeInstructionUnchecked = exports.decodeTransferCheckedWithFeeInstruction = exports.createTransferCheckedWithFeeInstruction = exports.transferCheckedWithFeeInstructionData = exports.decodeInitializeTransferFeeConfigInstructionUnchecked = exports.decodeInitializeTransferFeeConfigInstruction = exports.createInitializeTransferFeeConfigInstruction = exports.initializeTransferFeeConfigInstructionData = exports.TransferFeeInstruction = void 0;\nvar buffer_layout_1 = require(\"@solana/buffer-layout\");\nvar buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar constants_js_1 = require(\"../../constants.js\");\nvar errors_js_1 = require(\"../../errors.js\");\nvar types_js_1 = require(\"../../instructions/types.js\");\nvar TransferFeeInstruction;\n(function (TransferFeeInstruction) {\n  TransferFeeInstruction[TransferFeeInstruction[\"InitializeTransferFeeConfig\"] = 0] = \"InitializeTransferFeeConfig\";\n  TransferFeeInstruction[TransferFeeInstruction[\"TransferCheckedWithFee\"] = 1] = \"TransferCheckedWithFee\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromMint\"] = 2] = \"WithdrawWithheldTokensFromMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"WithdrawWithheldTokensFromAccounts\"] = 3] = \"WithdrawWithheldTokensFromAccounts\";\n  TransferFeeInstruction[TransferFeeInstruction[\"HarvestWithheldTokensToMint\"] = 4] = \"HarvestWithheldTokensToMint\";\n  TransferFeeInstruction[TransferFeeInstruction[\"SetTransferFee\"] = 5] = \"SetTransferFee\";\n})(TransferFeeInstruction = exports.TransferFeeInstruction || (exports.TransferFeeInstruction = {}));\n/** TODO: docs */\nexports.initializeTransferFeeConfigInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferFeeInstruction'), (0, buffer_layout_1.u8)('transferFeeConfigAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('transferFeeConfigAuthority'), (0, buffer_layout_1.u8)('withdrawWithheldAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('withdrawWithheldAuthority'), (0, buffer_layout_1.u16)('transferFeeBasisPoints'), (0, buffer_layout_utils_1.u64)('maximumFee')]);\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createInitializeTransferFeeConfigInstruction(mint, transferFeeConfigAuthority, withdrawWithheldAuthority, transferFeeBasisPoints, maximumFee) {\n  var programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : constants_js_1.TOKEN_2022_PROGRAM_ID;\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  var keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  var data = Buffer.alloc(exports.initializeTransferFeeConfigInstructionData.span);\n  exports.initializeTransferFeeConfigInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n    transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n    transferFeeConfigAuthority: transferFeeConfigAuthority || new web3_js_1.PublicKey(0),\n    withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n    withdrawWithheldAuthority: withdrawWithheldAuthority || new web3_js_1.PublicKey(0),\n    transferFeeBasisPoints: transferFeeBasisPoints,\n    maximumFee: maximumFee\n  }, data);\n  return new web3_js_1.TransactionInstruction({\n    keys: keys,\n    programId: programId,\n    data: data\n  });\n}\nexports.createInitializeTransferFeeConfigInstruction = createInitializeTransferFeeConfigInstruction;\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nfunction decodeInitializeTransferFeeConfigInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new errors_js_1.TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== exports.initializeTransferFeeConfigInstructionData.span) throw new errors_js_1.TokenInvalidInstructionDataError();\n  var _decodeInitializeTran = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction),\n    mint = _decodeInitializeTran.keys.mint,\n    data = _decodeInitializeTran.data;\n  if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig) throw new errors_js_1.TokenInvalidInstructionTypeError();\n  if (!mint) throw new errors_js_1.TokenInvalidInstructionKeysError();\n  return {\n    programId: programId,\n    keys: {\n      mint: mint\n    },\n    data: data\n  };\n}\nexports.decodeInitializeTransferFeeConfigInstruction = decodeInitializeTransferFeeConfigInstruction;\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nfunction decodeInitializeTransferFeeConfigInstructionUnchecked(_ref) {\n  var programId = _ref.programId,\n    _ref$keys = _slicedToArray(_ref.keys, 1),\n    mint = _ref$keys[0],\n    data = _ref.data;\n  var _exports$initializeTr = exports.initializeTransferFeeConfigInstructionData.decode(data),\n    instruction = _exports$initializeTr.instruction,\n    transferFeeInstruction = _exports$initializeTr.transferFeeInstruction,\n    transferFeeConfigAuthorityOption = _exports$initializeTr.transferFeeConfigAuthorityOption,\n    transferFeeConfigAuthority = _exports$initializeTr.transferFeeConfigAuthority,\n    withdrawWithheldAuthorityOption = _exports$initializeTr.withdrawWithheldAuthorityOption,\n    withdrawWithheldAuthority = _exports$initializeTr.withdrawWithheldAuthority,\n    transferFeeBasisPoints = _exports$initializeTr.transferFeeBasisPoints,\n    maximumFee = _exports$initializeTr.maximumFee;\n  return {\n    programId: programId,\n    keys: {\n      mint: mint\n    },\n    data: {\n      instruction: instruction,\n      transferFeeInstruction: transferFeeInstruction,\n      transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n      withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n      transferFeeBasisPoints: transferFeeBasisPoints,\n      maximumFee: maximumFee\n    }\n  };\n}\nexports.decodeInitializeTransferFeeConfigInstructionUnchecked = decodeInitializeTransferFeeConfigInstructionUnchecked;\nexports.transferCheckedWithFeeInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferFeeInstruction'), (0, buffer_layout_utils_1.u64)('amount'), (0, buffer_layout_1.u8)('decimals'), (0, buffer_layout_utils_1.u64)('fee')]);\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee) {\n  var multiSigners = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n  var programId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : constants_js_1.TOKEN_2022_PROGRAM_ID;\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  var data = Buffer.alloc(exports.transferCheckedWithFeeInstructionData.span);\n  exports.transferCheckedWithFeeInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n    amount: amount,\n    decimals: decimals,\n    fee: fee\n  }, data);\n  var keys = [];\n  keys.push({\n    pubkey: source,\n    isSigner: false,\n    isWritable: true\n  });\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: false\n  });\n  keys.push({\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  });\n  keys.push({\n    pubkey: authority,\n    isSigner: !multiSigners.length,\n    isWritable: false\n  });\n  var _iterator = _createForOfIteratorHelper(multiSigners),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var signer = _step.value;\n      keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return new web3_js_1.TransactionInstruction({\n    keys: keys,\n    programId: programId,\n    data: data\n  });\n}\nexports.createTransferCheckedWithFeeInstruction = createTransferCheckedWithFeeInstruction;\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nfunction decodeTransferCheckedWithFeeInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new errors_js_1.TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== exports.transferCheckedWithFeeInstructionData.span) throw new errors_js_1.TokenInvalidInstructionDataError();\n  var _decodeTransferChecke = decodeTransferCheckedWithFeeInstructionUnchecked(instruction),\n    _decodeTransferChecke2 = _decodeTransferChecke.keys,\n    source = _decodeTransferChecke2.source,\n    mint = _decodeTransferChecke2.mint,\n    destination = _decodeTransferChecke2.destination,\n    authority = _decodeTransferChecke2.authority,\n    signers = _decodeTransferChecke2.signers,\n    data = _decodeTransferChecke.data;\n  if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee) throw new errors_js_1.TokenInvalidInstructionTypeError();\n  if (!mint) throw new errors_js_1.TokenInvalidInstructionKeysError();\n  return {\n    programId: programId,\n    keys: {\n      source: source,\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers ? signers : null\n    },\n    data: data\n  };\n}\nexports.decodeTransferCheckedWithFeeInstruction = decodeTransferCheckedWithFeeInstruction;\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nfunction decodeTransferCheckedWithFeeInstructionUnchecked(_ref2) {\n  var programId = _ref2.programId,\n    _ref2$keys = _toArray(_ref2.keys),\n    source = _ref2$keys[0],\n    mint = _ref2$keys[1],\n    destination = _ref2$keys[2],\n    authority = _ref2$keys[3],\n    signers = _ref2$keys.slice(4),\n    data = _ref2.data;\n  var _exports$transferChec = exports.transferCheckedWithFeeInstructionData.decode(data),\n    instruction = _exports$transferChec.instruction,\n    transferFeeInstruction = _exports$transferChec.transferFeeInstruction,\n    amount = _exports$transferChec.amount,\n    decimals = _exports$transferChec.decimals,\n    fee = _exports$transferChec.fee;\n  return {\n    programId: programId,\n    keys: {\n      source: source,\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers\n    },\n    data: {\n      instruction: instruction,\n      transferFeeInstruction: transferFeeInstruction,\n      amount: amount,\n      decimals: decimals,\n      fee: fee\n    }\n  };\n}\nexports.decodeTransferCheckedWithFeeInstructionUnchecked = decodeTransferCheckedWithFeeInstructionUnchecked;\nexports.withdrawWithheldTokensFromMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferFeeInstruction')]);\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createWithdrawWithheldTokensFromMintInstruction(mint, destination, authority) {\n  var signers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var programId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : constants_js_1.TOKEN_2022_PROGRAM_ID;\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  var data = Buffer.alloc(exports.withdrawWithheldTokensFromMintInstructionData.span);\n  exports.withdrawWithheldTokensFromMintInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint\n  }, data);\n  var keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: authority,\n    isSigner: !signers.length,\n    isWritable: false\n  });\n  var _iterator2 = _createForOfIteratorHelper(signers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var signer = _step2.value;\n      keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return new web3_js_1.TransactionInstruction({\n    keys: keys,\n    programId: programId,\n    data: data\n  });\n}\nexports.createWithdrawWithheldTokensFromMintInstruction = createWithdrawWithheldTokensFromMintInstruction;\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nfunction decodeWithdrawWithheldTokensFromMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new errors_js_1.TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== exports.withdrawWithheldTokensFromMintInstructionData.span) throw new errors_js_1.TokenInvalidInstructionDataError();\n  var _decodeWithdrawWithhe = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction),\n    _decodeWithdrawWithhe2 = _decodeWithdrawWithhe.keys,\n    mint = _decodeWithdrawWithhe2.mint,\n    destination = _decodeWithdrawWithhe2.destination,\n    authority = _decodeWithdrawWithhe2.authority,\n    signers = _decodeWithdrawWithhe2.signers,\n    data = _decodeWithdrawWithhe.data;\n  if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint) throw new errors_js_1.TokenInvalidInstructionTypeError();\n  if (!mint) throw new errors_js_1.TokenInvalidInstructionKeysError();\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers ? signers : null\n    },\n    data: data\n  };\n}\nexports.decodeWithdrawWithheldTokensFromMintInstruction = decodeWithdrawWithheldTokensFromMintInstruction;\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nfunction decodeWithdrawWithheldTokensFromMintInstructionUnchecked(_ref3) {\n  var programId = _ref3.programId,\n    _ref3$keys = _toArray(_ref3.keys),\n    mint = _ref3$keys[0],\n    destination = _ref3$keys[1],\n    authority = _ref3$keys[2],\n    signers = _ref3$keys.slice(3),\n    data = _ref3.data;\n  var _exports$withdrawWith = exports.withdrawWithheldTokensFromMintInstructionData.decode(data),\n    instruction = _exports$withdrawWith.instruction,\n    transferFeeInstruction = _exports$withdrawWith.transferFeeInstruction;\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers\n    },\n    data: {\n      instruction: instruction,\n      transferFeeInstruction: transferFeeInstruction\n    }\n  };\n}\nexports.decodeWithdrawWithheldTokensFromMintInstructionUnchecked = decodeWithdrawWithheldTokensFromMintInstructionUnchecked;\nexports.withdrawWithheldTokensFromAccountsInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferFeeInstruction'), (0, buffer_layout_1.u8)('numTokenAccounts')]);\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createWithdrawWithheldTokensFromAccountsInstruction(mint, destination, authority, signers, sources) {\n  var programId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : constants_js_1.TOKEN_2022_PROGRAM_ID;\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  var data = Buffer.alloc(exports.withdrawWithheldTokensFromAccountsInstructionData.span);\n  exports.withdrawWithheldTokensFromAccountsInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n    numTokenAccounts: sources.length\n  }, data);\n  var keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: destination,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: authority,\n    isSigner: !signers.length,\n    isWritable: false\n  });\n  var _iterator3 = _createForOfIteratorHelper(signers),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var signer = _step3.value;\n      keys.push({\n        pubkey: signer.publicKey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(sources),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var source = _step4.value;\n      keys.push({\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      });\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return new web3_js_1.TransactionInstruction({\n    keys: keys,\n    programId: programId,\n    data: data\n  });\n}\nexports.createWithdrawWithheldTokensFromAccountsInstruction = createWithdrawWithheldTokensFromAccountsInstruction;\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nfunction decodeWithdrawWithheldTokensFromAccountsInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new errors_js_1.TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== exports.withdrawWithheldTokensFromAccountsInstructionData.span) throw new errors_js_1.TokenInvalidInstructionDataError();\n  var _decodeWithdrawWithhe3 = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction),\n    _decodeWithdrawWithhe4 = _decodeWithdrawWithhe3.keys,\n    mint = _decodeWithdrawWithhe4.mint,\n    destination = _decodeWithdrawWithhe4.destination,\n    authority = _decodeWithdrawWithhe4.authority,\n    signers = _decodeWithdrawWithhe4.signers,\n    sources = _decodeWithdrawWithhe4.sources,\n    data = _decodeWithdrawWithhe3.data;\n  if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts) throw new errors_js_1.TokenInvalidInstructionTypeError();\n  if (!mint) throw new errors_js_1.TokenInvalidInstructionKeysError();\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers ? signers : null,\n      sources: sources ? sources : null\n    },\n    data: data\n  };\n}\nexports.decodeWithdrawWithheldTokensFromAccountsInstruction = decodeWithdrawWithheldTokensFromAccountsInstruction;\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nfunction decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(_ref4) {\n  var programId = _ref4.programId,\n    keys = _ref4.keys,\n    data = _ref4.data;\n  var _exports$withdrawWith2 = exports.withdrawWithheldTokensFromAccountsInstructionData.decode(data),\n    instruction = _exports$withdrawWith2.instruction,\n    transferFeeInstruction = _exports$withdrawWith2.transferFeeInstruction,\n    numTokenAccounts = _exports$withdrawWith2.numTokenAccounts;\n  var _ref5 = [keys[0], keys[1], keys[2], keys.slice(3, 3 + numTokenAccounts), keys.slice(-1 * numTokenAccounts)],\n    mint = _ref5[0],\n    destination = _ref5[1],\n    authority = _ref5[2],\n    signers = _ref5[3],\n    sources = _ref5[4];\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      destination: destination,\n      authority: authority,\n      signers: signers,\n      sources: sources\n    },\n    data: {\n      instruction: instruction,\n      transferFeeInstruction: transferFeeInstruction,\n      numTokenAccounts: numTokenAccounts\n    }\n  };\n}\nexports.decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked;\nexports.harvestWithheldTokensToMintInstructionData = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u8)('instruction'), (0, buffer_layout_1.u8)('transferFeeInstruction')]);\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nfunction createHarvestWithheldTokensToMintInstruction(mint, sources) {\n  var programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_js_1.TOKEN_2022_PROGRAM_ID;\n  if (!(0, constants_js_1.programSupportsExtensions)(programId)) {\n    throw new errors_js_1.TokenUnsupportedInstructionError();\n  }\n  var data = Buffer.alloc(exports.harvestWithheldTokensToMintInstructionData.span);\n  exports.harvestWithheldTokensToMintInstructionData.encode({\n    instruction: types_js_1.TokenInstruction.TransferFeeExtension,\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint\n  }, data);\n  var keys = [];\n  keys.push({\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  });\n  var _iterator5 = _createForOfIteratorHelper(sources),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var source = _step5.value;\n      keys.push({\n        pubkey: source,\n        isSigner: false,\n        isWritable: true\n      });\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return new web3_js_1.TransactionInstruction({\n    keys: keys,\n    programId: programId,\n    data: data\n  });\n}\nexports.createHarvestWithheldTokensToMintInstruction = createHarvestWithheldTokensToMintInstruction;\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nfunction decodeHarvestWithheldTokensToMintInstruction(instruction, programId) {\n  if (!instruction.programId.equals(programId)) throw new errors_js_1.TokenInvalidInstructionProgramError();\n  if (instruction.data.length !== exports.harvestWithheldTokensToMintInstructionData.span) throw new errors_js_1.TokenInvalidInstructionDataError();\n  var _decodeHarvestWithhel = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction),\n    _decodeHarvestWithhel2 = _decodeHarvestWithhel.keys,\n    mint = _decodeHarvestWithhel2.mint,\n    sources = _decodeHarvestWithhel2.sources,\n    data = _decodeHarvestWithhel.data;\n  if (data.instruction !== types_js_1.TokenInstruction.TransferFeeExtension || data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint) throw new errors_js_1.TokenInvalidInstructionTypeError();\n  if (!mint) throw new errors_js_1.TokenInvalidInstructionKeysError();\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      sources: sources\n    },\n    data: data\n  };\n}\nexports.decodeHarvestWithheldTokensToMintInstruction = decodeHarvestWithheldTokensToMintInstruction;\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nfunction decodeHarvestWithheldTokensToMintInstructionUnchecked(_ref6) {\n  var programId = _ref6.programId,\n    _ref6$keys = _toArray(_ref6.keys),\n    mint = _ref6$keys[0],\n    sources = _ref6$keys.slice(1),\n    data = _ref6.data;\n  var _exports$harvestWithh = exports.harvestWithheldTokensToMintInstructionData.decode(data),\n    instruction = _exports$harvestWithh.instruction,\n    transferFeeInstruction = _exports$harvestWithh.transferFeeInstruction;\n  return {\n    programId: programId,\n    keys: {\n      mint: mint,\n      sources: sources\n    },\n    data: {\n      instruction: instruction,\n      transferFeeInstruction: transferFeeInstruction\n    }\n  };\n}\nexports.decodeHarvestWithheldTokensToMintInstructionUnchecked = decodeHarvestWithheldTokensToMintInstructionUnchecked;","map":{"version":3,"mappings":"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","names":["TransferFeeInstruction","exports","createInitializeTransferFeeConfigInstruction","mint","transferFeeConfigAuthority","withdrawWithheldAuthority","transferFeeBasisPoints","maximumFee","programId","constants_js_1","errors_js_1","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","types_js_1","TransferFeeExtension","transferFeeInstruction","InitializeTransferFeeConfig","transferFeeConfigAuthorityOption","web3_js_1","withdrawWithheldAuthorityOption","decodeInitializeTransferFeeConfigInstruction","equals","length","decodeInitializeTransferFeeConfigInstructionUnchecked","decode","createTransferCheckedWithFeeInstruction","source","destination","authority","amount","decimals","fee","multiSigners","TransferCheckedWithFee","push","signer","publicKey","decodeTransferCheckedWithFeeInstruction","decodeTransferCheckedWithFeeInstructionUnchecked","signers","createWithdrawWithheldTokensFromMintInstruction","WithdrawWithheldTokensFromMint","decodeWithdrawWithheldTokensFromMintInstruction","decodeWithdrawWithheldTokensFromMintInstructionUnchecked","createWithdrawWithheldTokensFromAccountsInstruction","sources","WithdrawWithheldTokensFromAccounts","numTokenAccounts","decodeWithdrawWithheldTokensFromAccountsInstruction","decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked","slice","createHarvestWithheldTokensToMintInstruction","HarvestWithheldTokensToMint","decodeHarvestWithheldTokensToMintInstruction","decodeHarvestWithheldTokensToMintInstructionUnchecked"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/extensions/transferFee/instructions.ts"],"sourcesContent":["import { struct, u16, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountMeta, Signer } from '@solana/web3.js';\nimport { PublicKey, TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID } from '../../constants.js';\nimport {\n    TokenInvalidInstructionDataError,\n    TokenInvalidInstructionKeysError,\n    TokenInvalidInstructionProgramError,\n    TokenInvalidInstructionTypeError,\n    TokenUnsupportedInstructionError,\n} from '../../errors.js';\nimport { TokenInstruction } from '../../instructions/types.js';\n\nexport enum TransferFeeInstruction {\n    InitializeTransferFeeConfig = 0,\n    TransferCheckedWithFee = 1,\n    WithdrawWithheldTokensFromMint = 2,\n    WithdrawWithheldTokensFromAccounts = 3,\n    HarvestWithheldTokensToMint = 4,\n    SetTransferFee = 5,\n}\n\n// InitializeTransferFeeConfig\n\n/** TODO: docs */\nexport interface InitializeTransferFeeConfigInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n    transferFeeConfigAuthorityOption: 1 | 0;\n    transferFeeConfigAuthority: PublicKey;\n    withdrawWithheldAuthorityOption: 1 | 0;\n    withdrawWithheldAuthority: PublicKey;\n    transferFeeBasisPoints: number;\n    maximumFee: bigint;\n}\n\n/** TODO: docs */\nexport const initializeTransferFeeConfigInstructionData = struct<InitializeTransferFeeConfigInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u8('transferFeeConfigAuthorityOption'),\n    publicKey('transferFeeConfigAuthority'),\n    u8('withdrawWithheldAuthorityOption'),\n    publicKey('withdrawWithheldAuthority'),\n    u16('transferFeeBasisPoints'),\n    u64('maximumFee'),\n]);\n\n/**\n * Construct an InitializeTransferFeeConfig instruction\n *\n * @param mint            Token mint account\n * @param transferFeeConfigAuthority  Optional authority that can update the fees\n * @param withdrawWithheldAuthority Optional authority that can withdraw fees\n * @param transferFeeBasisPoints Amount of transfer collected as fees, expressed as basis points of the transfer amount\n * @param maximumFee        Maximum fee assessed on transfers\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferFeeConfigInstruction(\n    mint: PublicKey,\n    transferFeeConfigAuthority: PublicKey | null,\n    withdrawWithheldAuthority: PublicKey | null,\n    transferFeeBasisPoints: number,\n    maximumFee: bigint,\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferFeeConfigInstructionData.span);\n    initializeTransferFeeConfigInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig,\n            transferFeeConfigAuthorityOption: transferFeeConfigAuthority ? 1 : 0,\n            transferFeeConfigAuthority: transferFeeConfigAuthority || new PublicKey(0),\n            withdrawWithheldAuthorityOption: withdrawWithheldAuthority ? 1 : 0,\n            withdrawWithheldAuthority: withdrawWithheldAuthority || new PublicKey(0),\n            transferFeeBasisPoints: transferFeeBasisPoints,\n            maximumFee: maximumFee,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeInitializeTransferFeeConfigInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedInitializeTransferFeeConfigInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== initializeTransferFeeConfigInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint },\n        data,\n    } = decodeInitializeTransferFeeConfigInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.InitializeTransferFeeConfig\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated InitializeTransferFeeConfig instruction */\nexport interface DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.InitializeTransferFeeConfig;\n        transferFeeConfigAuthority: PublicKey | null;\n        withdrawWithheldAuthority: PublicKey | null;\n        transferFeeBasisPoints: number;\n        maximumFee: bigint;\n    };\n}\n\n/**\n * Decode an InitializeTransferFeeConfig instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeInitializeTransferFeeConfigInstructionUnchecked({\n    programId,\n    keys: [mint],\n    data,\n}: TransactionInstruction): DecodedInitializeTransferFeeConfigInstructionUnchecked {\n    const {\n        instruction,\n        transferFeeInstruction,\n        transferFeeConfigAuthorityOption,\n        transferFeeConfigAuthority,\n        withdrawWithheldAuthorityOption,\n        withdrawWithheldAuthority,\n        transferFeeBasisPoints,\n        maximumFee,\n    } = initializeTransferFeeConfigInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            transferFeeConfigAuthority: transferFeeConfigAuthorityOption ? transferFeeConfigAuthority : null,\n            withdrawWithheldAuthority: withdrawWithheldAuthorityOption ? withdrawWithheldAuthority : null,\n            transferFeeBasisPoints,\n            maximumFee,\n        },\n    };\n}\n\n// TransferCheckedWithFee\nexport interface TransferCheckedWithFeeInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n    amount: bigint;\n    decimals: number;\n    fee: bigint;\n}\n\nexport const transferCheckedWithFeeInstructionData = struct<TransferCheckedWithFeeInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n    u64('amount'),\n    u8('decimals'),\n    u64('fee'),\n]);\n\n/**\n * Construct an TransferCheckedWithFee instruction\n *\n * @param source          The source account\n * @param mint            The token mint\n * @param destination     The destination account\n * @param authority       The source account's owner/delegate\n * @param signers         The signer account(s)\n * @param amount          The amount of tokens to transfer\n * @param decimals        The expected number of base 10 digits to the right of the decimal place\n * @param fee             The expected fee assesed on this transfer, calculated off-chain based on the transferFeeBasisPoints and maximumFee of the mint.\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createTransferCheckedWithFeeInstruction(\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: Signer[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(transferCheckedWithFeeInstructionData.span);\n    transferCheckedWithFeeInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee,\n            amount,\n            decimals,\n            fee,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    keys.push({ pubkey: mint, isSigner: false, isWritable: false });\n    keys.push({ pubkey: destination, isSigner: false, isWritable: true });\n    keys.push({ pubkey: authority, isSigner: !multiSigners.length, isWritable: false });\n    for (const signer of multiSigners) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid TransferCheckedWithFee instruction */\nexport interface DecodedTransferCheckedWithFeeInstruction {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFee instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeTransferCheckedWithFeeInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedTransferCheckedWithFeeInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== transferCheckedWithFeeInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { source, mint, destination, authority, signers },\n        data,\n    } = decodeTransferCheckedWithFeeInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.TransferCheckedWithFee\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, non-validated TransferCheckedWithFees instruction */\nexport interface DecodedTransferCheckedWithFeeInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        source: AccountMeta;\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | undefined;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.TransferCheckedWithFee;\n        amount: bigint;\n        decimals: number;\n        fee: bigint;\n    };\n}\n\n/**\n * Decode a TransferCheckedWithFees instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeTransferCheckedWithFeeInstructionUnchecked({\n    programId,\n    keys: [source, mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedTransferCheckedWithFeeInstructionUnchecked {\n    const { instruction, transferFeeInstruction, amount, decimals, fee } =\n        transferCheckedWithFeeInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            source,\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            amount,\n            decimals,\n            fee,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromMint\nexport interface WithdrawWithheldTokensFromMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n}\n\nexport const withdrawWithheldTokensFromMintInstructionData = struct<WithdrawWithheldTokensFromMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a WithdrawWithheldTokensFromMint instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromMintInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: Signer[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromMintInstructionData.span);\n    withdrawWithheldTokensFromMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push(\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n        { pubkey: authority, isSigner: !signers.length, isWritable: false }\n    );\n    for (const signer of signers) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers },\n        data,\n    } = decodeWithdrawWithheldTokensFromMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromMint instruction */\nexport interface DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromMint;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromMintInstructionUnchecked({\n    programId,\n    keys: [mint, destination, authority, ...signers],\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = withdrawWithheldTokensFromMintInstructionData.decode(data);\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n\n// WithdrawWithheldTokensFromAccounts\nexport interface WithdrawWithheldTokensFromAccountsInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n    numTokenAccounts: number;\n}\n\nexport const withdrawWithheldTokensFromAccountsInstructionData =\n    struct<WithdrawWithheldTokensFromAccountsInstructionData>([\n        u8('instruction'),\n        u8('transferFeeInstruction'),\n        u8('numTokenAccounts'),\n    ]);\n\n/**\n * Construct a WithdrawWithheldTokensFromAccounts instruction\n *\n * @param mint              The token mint\n * @param destination       The destination account\n * @param authority         The source account's owner/delegate\n * @param signers           The signer account(s)\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createWithdrawWithheldTokensFromAccountsInstruction(\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    signers: Signer[],\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(withdrawWithheldTokensFromAccountsInstructionData.span);\n    withdrawWithheldTokensFromAccountsInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts,\n            numTokenAccounts: sources.length,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push(\n        { pubkey: mint, isSigner: false, isWritable: true },\n        { pubkey: destination, isSigner: false, isWritable: true },\n        { pubkey: authority, isSigner: !signers.length, isWritable: false }\n    );\n    for (const signer of signers) {\n        keys.push({ pubkey: signer.publicKey, isSigner: true, isWritable: false });\n    }\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccounts instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedWithdrawWithheldTokensFromAccountsInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== withdrawWithheldTokensFromAccountsInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, destination, authority, signers, sources },\n        data,\n    } = decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.WithdrawWithheldTokensFromAccounts\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers: signers ? signers : null,\n            sources: sources ? sources : null,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid WithdrawWithheldTokensFromAccounts instruction */\nexport interface DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        destination: AccountMeta;\n        authority: AccountMeta;\n        signers: AccountMeta[] | null;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.WithdrawWithheldTokensFromAccounts;\n        numTokenAccounts: number;\n    };\n}\n\n/**\n * Decode a WithdrawWithheldTokensFromAccount instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeWithdrawWithheldTokensFromAccountsInstructionUnchecked({\n    programId,\n    keys,\n    data,\n}: TransactionInstruction): DecodedWithdrawWithheldTokensFromAccountsInstructionUnchecked {\n    const { instruction, transferFeeInstruction, numTokenAccounts } =\n        withdrawWithheldTokensFromAccountsInstructionData.decode(data);\n    const [mint, destination, authority, signers, sources] = [\n        keys[0],\n        keys[1],\n        keys[2],\n        keys.slice(3, 3 + numTokenAccounts),\n        keys.slice(-1 * numTokenAccounts),\n    ];\n    return {\n        programId,\n        keys: {\n            mint,\n            destination,\n            authority,\n            signers,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n            numTokenAccounts,\n        },\n    };\n}\n\n// HarvestWithheldTokensToMint\n\nexport interface HarvestWithheldTokensToMintInstructionData {\n    instruction: TokenInstruction.TransferFeeExtension;\n    transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n}\n\nexport const harvestWithheldTokensToMintInstructionData = struct<HarvestWithheldTokensToMintInstructionData>([\n    u8('instruction'),\n    u8('transferFeeInstruction'),\n]);\n\n/**\n * Construct a HarvestWithheldTokensToMint instruction\n *\n * @param mint              The token mint\n * @param sources           The source accounts to withdraw from\n * @param programID         SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createHarvestWithheldTokensToMintInstruction(\n    mint: PublicKey,\n    sources: PublicKey[],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const data = Buffer.alloc(harvestWithheldTokensToMintInstructionData.span);\n    harvestWithheldTokensToMintInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferFeeExtension,\n            transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint,\n        },\n        data\n    );\n    const keys: AccountMeta[] = [];\n    keys.push({ pubkey: mint, isSigner: false, isWritable: true });\n    for (const source of sources) {\n        keys.push({ pubkey: source, isSigner: false, isWritable: true });\n    }\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstruction {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction and validate it\n *\n * @param instruction Transaction instruction to decode\n * @param programId   SPL Token program account\n *\n * @return Decoded, valid instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstruction(\n    instruction: TransactionInstruction,\n    programId: PublicKey\n): DecodedHarvestWithheldTokensToMintInstruction {\n    if (!instruction.programId.equals(programId)) throw new TokenInvalidInstructionProgramError();\n    if (instruction.data.length !== harvestWithheldTokensToMintInstructionData.span)\n        throw new TokenInvalidInstructionDataError();\n\n    const {\n        keys: { mint, sources },\n        data,\n    } = decodeHarvestWithheldTokensToMintInstructionUnchecked(instruction);\n    if (\n        data.instruction !== TokenInstruction.TransferFeeExtension ||\n        data.transferFeeInstruction !== TransferFeeInstruction.HarvestWithheldTokensToMint\n    )\n        throw new TokenInvalidInstructionTypeError();\n    if (!mint) throw new TokenInvalidInstructionKeysError();\n\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data,\n    };\n}\n\n/** A decoded, valid HarvestWithheldTokensToMint instruction */\nexport interface DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    programId: PublicKey;\n    keys: {\n        mint: AccountMeta;\n        sources: AccountMeta[] | null;\n    };\n    data: {\n        instruction: TokenInstruction.TransferFeeExtension;\n        transferFeeInstruction: TransferFeeInstruction.HarvestWithheldTokensToMint;\n    };\n}\n\n/**\n * Decode a HarvestWithheldTokensToMint instruction without validating it\n *\n * @param instruction Transaction instruction to decode\n *\n * @return Decoded, non-validated instruction\n */\nexport function decodeHarvestWithheldTokensToMintInstructionUnchecked({\n    programId,\n    keys: [mint, ...sources],\n    data,\n}: TransactionInstruction): DecodedHarvestWithheldTokensToMintInstructionUnchecked {\n    const { instruction, transferFeeInstruction } = harvestWithheldTokensToMintInstructionData.decode(data);\n    return {\n        programId,\n        keys: {\n            mint,\n            sources,\n        },\n        data: {\n            instruction,\n            transferFeeInstruction,\n        },\n    };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}