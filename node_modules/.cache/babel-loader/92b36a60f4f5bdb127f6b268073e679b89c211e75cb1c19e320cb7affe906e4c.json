{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoAccount = void 0;\nvar _1 = require(\".\");\nvar lib_1 = require(\"./lib\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"masterFingerprint\"] = 1] = \"masterFingerprint\";\n  Keys[Keys[\"outputDescriptors\"] = 2] = \"outputDescriptors\";\n})(Keys || (Keys = {}));\nvar CryptoAccount = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoAccount, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoAccount);\n  function CryptoAccount(masterFingerprint, outputDescriptors) {\n    var _this;\n    _classCallCheck(this, CryptoAccount);\n    _this = _super.call(this);\n    _this.masterFingerprint = masterFingerprint;\n    _this.outputDescriptors = outputDescriptors;\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_ACCOUNT;\n    };\n    _this.getMasterFingerprint = function () {\n      return _this.masterFingerprint;\n    };\n    _this.getOutputDescriptors = function () {\n      return _this.outputDescriptors;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      if (_this.masterFingerprint) {\n        map[Keys.masterFingerprint] = _this.masterFingerprint.readUInt32BE(0);\n      }\n      if (_this.outputDescriptors) {\n        map[Keys.outputDescriptors] = _this.outputDescriptors.map(function (item) {\n          return item.toDataItem();\n        });\n      }\n      return new lib_1.DataItem(map);\n    };\n    return _this;\n  }\n  return _createClass(CryptoAccount);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoAccount = CryptoAccount;\nCryptoAccount.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var masterFingerprint = Buffer.alloc(4);\n  var _masterFingerprint = map[Keys.masterFingerprint];\n  if (_masterFingerprint) {\n    masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n  }\n  var outputDescriptors = map[Keys.outputDescriptors];\n  var cryptoOutputs = outputDescriptors.map(function (item) {\n    return _1.CryptoOutput.fromDataItem(item);\n  });\n  return new CryptoAccount(masterFingerprint, cryptoOutputs);\n};\nCryptoAccount.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoAccount.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AAGA,IAAKA,IAGJ;AAHD,WAAKA,IAAI;EACPA,yDAAqB;EACrBA,yDAAiB;AACnB,CAAC,EAHIA,IAAI,KAAJA,IAAI;AAGR,IAEYC,aAAc;EAAA;EAAA;EAKzB,uBACUC,iBAAyB,EACzBC,iBAAiC;IAAA;IAAA;IAEzC;IAHQ,uBAAiB,GAAjBD,iBAAiB;IACjB,uBAAiB,GAAjBC,iBAAiB;IAN3B,qBAAe,GAAG,YAAK;MACrB,OAAOC,4BAAa,CAACC,cAAc;IACrC,CAAC;IASM,0BAAoB,GAAG;MAAA,OAAM,MAAKH,iBAAiB;IAAA;IACnD,0BAAoB,GAAG;MAAA,OAAM,MAAKC,iBAAiB;IAAA;IAEnD,gBAAU,GAAG,YAAK;MACvB,IAAMG,GAAG,GAAgB,EAAE;MAC3B,IAAI,MAAKJ,iBAAiB,EAAE;QAC1BI,GAAG,CAACN,IAAI,CAACE,iBAAiB,CAAC,GAAG,MAAKA,iBAAiB,CAACK,YAAY,CAAC,CAAC,CAAC;;MAEtE,IAAI,MAAKJ,iBAAiB,EAAE;QAC1BG,GAAG,CAACN,IAAI,CAACG,iBAAiB,CAAC,GAAG,MAAKA,iBAAiB,CAACG,GAAG,CAAC,UAACE,IAAI;UAAA,OAC5DA,IAAI,CAACC,UAAU,EAAE;QAAA,EAClB;;MAEH,OAAO,IAAIC,cAAQ,CAACJ,GAAG,CAAC;IAC1B,CAAC;IAAC;EAhBF;EAAC;AAAA,EAVgCK,2BAAY;AAA/CC;AA4BgBX,0BAAY,GAAG,UAACY,QAAkB,EAAI;EAClD,IAAMP,GAAG,GAAGO,QAAQ,CAACC,OAAO,EAAE;EAC9B,IAAMZ,iBAAiB,GAAGa,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;EACzC,IAAMC,kBAAkB,GAAGX,GAAG,CAACN,IAAI,CAACE,iBAAiB,CAAC;EACtD,IAAIe,kBAAkB,EAAE;IACtBf,iBAAiB,CAACgB,aAAa,CAACD,kBAAkB,EAAE,CAAC,CAAC;;EAExD,IAAMd,iBAAiB,GAAGG,GAAG,CAACN,IAAI,CAACG,iBAAiB,CAAe;EACnE,IAAMgB,aAAa,GAAGhB,iBAAiB,CAACG,GAAG,CAAC,UAACE,IAAI;IAAA,OAC/CY,eAAY,CAACC,YAAY,CAACb,IAAI,CAAC;EAAA,EAChC;EACD,OAAO,IAAIP,aAAa,CAACC,iBAAiB,EAAEiB,aAAa,CAAC;AAC5D,CAAC;AAEalB,sBAAQ,GAAG,UAACqB,YAAoB,EAAI;EAChD,IAAMT,QAAQ,GAAG,0BAAgB,EAACS,YAAY,CAAC;EAC/C,OAAOrB,aAAa,CAACoB,YAAY,CAACR,QAAQ,CAAC;AAC7C,CAAC","names":["Keys","CryptoAccount","masterFingerprint","outputDescriptors","RegistryType_1","CRYPTO_ACCOUNT","map","readUInt32BE","item","toDataItem","lib_1","RegistryItem_1","exports","dataItem","getData","Buffer","alloc","_masterFingerprint","writeUInt32BE","cryptoOutputs","_1","fromDataItem","_cborPayload"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoAccount.ts"],"sourcesContent":["import { CryptoOutput } from '.';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  masterFingerprint = 1,\n  outputDescriptors,\n}\n\nexport class CryptoAccount extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_ACCOUNT;\n  };\n\n  constructor(\n    private masterFingerprint: Buffer,\n    private outputDescriptors: CryptoOutput[],\n  ) {\n    super();\n  }\n\n  public getMasterFingerprint = () => this.masterFingerprint;\n  public getOutputDescriptors = () => this.outputDescriptors;\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.masterFingerprint) {\n      map[Keys.masterFingerprint] = this.masterFingerprint.readUInt32BE(0);\n    }\n    if (this.outputDescriptors) {\n      map[Keys.outputDescriptors] = this.outputDescriptors.map((item) =>\n        item.toDataItem(),\n      );\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const masterFingerprint = Buffer.alloc(4);\n    const _masterFingerprint = map[Keys.masterFingerprint];\n    if (_masterFingerprint) {\n      masterFingerprint.writeUInt32BE(_masterFingerprint, 0);\n    }\n    const outputDescriptors = map[Keys.outputDescriptors] as DataItem[];\n    const cryptoOutputs = outputDescriptors.map((item) =>\n      CryptoOutput.fromDataItem(item),\n    );\n    return new CryptoAccount(masterFingerprint, cryptoOutputs);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoAccount.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}