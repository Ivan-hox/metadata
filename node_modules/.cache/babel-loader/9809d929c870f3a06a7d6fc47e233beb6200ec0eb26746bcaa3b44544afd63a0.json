{"ast":null,"code":"import _toConsumableArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  var _32n = BigInt(32);\n  var _u32_max = BigInt(0xffffffff);\n  var wh = Number(value >> _32n & _u32_max);\n  var wl = Number(value & _u32_max);\n  var h = isLE ? 4 : 0;\n  var l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport var SHA2 = /*#__PURE__*/function (_Hash) {\n  _inherits(SHA2, _Hash);\n  var _super = _createSuper(SHA2);\n  function SHA2(blockLen, outputLen, padOffset, isLE) {\n    var _this;\n    _classCallCheck(this, SHA2);\n    _this = _super.call(this);\n    _this.blockLen = blockLen;\n    _this.outputLen = outputLen;\n    _this.padOffset = padOffset;\n    _this.isLE = isLE;\n    _this.finished = false;\n    _this.length = 0;\n    _this.pos = 0;\n    _this.destroyed = false;\n    _this.buffer = new Uint8Array(blockLen);\n    _this.view = createView(_this.buffer);\n    return _this;\n  }\n  _createClass(SHA2, [{\n    key: \"update\",\n    value: function update(data) {\n      assert.exists(this);\n      var view = this.view,\n        buffer = this.buffer,\n        blockLen = this.blockLen;\n      data = toBytes(data);\n      var len = data.length;\n      for (var pos = 0; pos < len;) {\n        var take = Math.min(blockLen - this.pos, len - pos);\n        // Fast path: we have at least one block in input, cast it to view and process\n        if (take === blockLen) {\n          var dataView = createView(data);\n          for (; blockLen <= len - pos; pos += blockLen) {\n            this.process(dataView, pos);\n          }\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n  }, {\n    key: \"digestInto\",\n    value: function digestInto(out) {\n      assert.exists(this);\n      assert.output(out, this);\n      this.finished = true;\n      // Padding\n      // We can avoid allocation of buffer for padding completely if it\n      // was previously not allocated here. But it won't change performance.\n      var buffer = this.buffer,\n        view = this.view,\n        blockLen = this.blockLen,\n        isLE = this.isLE;\n      var pos = this.pos;\n      // append the bit '1' to the message\n      buffer[pos++] = 128;\n      this.buffer.subarray(pos).fill(0);\n      // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      // Pad until full block byte with zeros\n      for (var i = pos; i < blockLen; i++) {\n        buffer[i] = 0;\n      }\n      // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n      // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n      // So we just write lowest 64 bits of that value.\n      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n      this.process(view, 0);\n      var oview = createView(out);\n      this.get().forEach(function (v, i) {\n        return oview.setUint32(4 * i, v, isLE);\n      });\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var buffer = this.buffer,\n        outputLen = this.outputLen;\n      this.digestInto(buffer);\n      var res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n  }, {\n    key: \"_cloneInto\",\n    value: function _cloneInto(to) {\n      var _to;\n      to || (to = new this.constructor());\n      (_to = to).set.apply(_to, _toConsumableArray(this.get()));\n      var blockLen = this.blockLen,\n        buffer = this.buffer,\n        length = this.length,\n        finished = this.finished,\n        destroyed = this.destroyed,\n        pos = this.pos;\n      to.length = length;\n      to.pos = pos;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      if (length % blockLen) to.buffer.set(buffer);\n      return to;\n    }\n  }]);\n  return SHA2;\n}(Hash);","map":{"version":3,"names":["assert","Hash","createView","toBytes","setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","SHA2","blockLen","outputLen","padOffset","finished","length","pos","destroyed","buffer","Uint8Array","data","exists","len","take","Math","min","dataView","process","set","subarray","roundClean","out","output","fill","i","oview","get","forEach","v","digestInto","res","slice","destroy","to","constructor"],"sources":["/Users/ivan/Metadata/node_modules/@noble/hashes/esm/_sha2.js"],"sourcesContent":["import assert from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        assert.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        assert.exists(this);\n        assert.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}