{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoKeypath = void 0;\nvar lib_1 = require(\"./lib\");\nvar PathComponent_1 = require(\"./PathComponent\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"components\"] = 1] = \"components\";\n  Keys[Keys[\"source_fingerprint\"] = 2] = \"source_fingerprint\";\n  Keys[Keys[\"depth\"] = 3] = \"depth\";\n})(Keys || (Keys = {}));\nvar CryptoKeypath = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoKeypath, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoKeypath);\n  function CryptoKeypath() {\n    var _this;\n    var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var sourceFingerprint = arguments.length > 1 ? arguments[1] : undefined;\n    var depth = arguments.length > 2 ? arguments[2] : undefined;\n    _classCallCheck(this, CryptoKeypath);\n    _this = _super.call(this);\n    _this.components = components;\n    _this.sourceFingerprint = sourceFingerprint;\n    _this.depth = depth;\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_KEYPATH;\n    };\n    _this.getPath = function () {\n      if (_this.components.length === 0) {\n        return undefined;\n      }\n      var components = _this.components.map(function (component) {\n        return \"\".concat(component.isWildcard() ? '*' : component.getIndex()).concat(component.isHardened() ? \"'\" : '');\n      });\n      return components.join('/');\n    };\n    _this.getComponents = function () {\n      return _this.components;\n    };\n    _this.getSourceFingerprint = function () {\n      return _this.sourceFingerprint;\n    };\n    _this.getDepth = function () {\n      return _this.depth;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      var components = [];\n      _this.components && _this.components.forEach(function (component) {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex());\n        }\n        components.push(component.isHardened());\n      });\n      map[Keys.components] = components;\n      if (_this.sourceFingerprint) {\n        map[Keys.source_fingerprint] = _this.sourceFingerprint.readUInt32BE(0);\n      }\n      if (_this.depth !== undefined) {\n        map[Keys.depth] = _this.depth;\n      }\n      return new lib_1.DataItem(map);\n    };\n    return _this;\n  }\n  return _createClass(CryptoKeypath);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoKeypath = CryptoKeypath;\nCryptoKeypath.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var pathComponents = [];\n  var components = map[Keys.components];\n  if (components) {\n    for (var i = 0; i < components.length; i += 2) {\n      var isHardened = components[i + 1];\n      var path = components[i];\n      if (typeof path === 'number') {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          index: path,\n          hardened: isHardened\n        }));\n      } else {\n        pathComponents.push(new PathComponent_1.PathComponent({\n          hardened: isHardened\n        }));\n      }\n    }\n  }\n  var _sourceFingerprint = map[Keys.source_fingerprint];\n  var sourceFingerprint;\n  if (_sourceFingerprint) {\n    sourceFingerprint = Buffer.alloc(4);\n    sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n  }\n  var depth = map[Keys.depth];\n  return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n};\nCryptoKeypath.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoKeypath.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["Keys","CryptoKeypath","components","sourceFingerprint","depth","RegistryType_1","CRYPTO_KEYPATH","length","undefined","map","component","isWildcard","getIndex","isHardened","join","forEach","push","source_fingerprint","readUInt32BE","lib_1","RegistryItem_1","exports","dataItem","getData","pathComponents","i","path","PathComponent_1","index","hardened","_sourceFingerprint","Buffer","alloc","writeUInt32BE","_cborPayload","fromDataItem"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoKeypath.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { PathComponent } from './PathComponent';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  components = 1,\n  source_fingerprint,\n  depth,\n}\n\nexport class CryptoKeypath extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_KEYPATH;\n  };\n\n  constructor(\n    private components: PathComponent[] = [],\n    private sourceFingerprint?: Buffer,\n    private depth?: number,\n  ) {\n    super();\n  }\n\n  public getPath = () => {\n    if (this.components.length === 0) {\n      return undefined;\n    }\n\n    const components = this.components.map((component) => {\n      return `${component.isWildcard() ? '*' : component.getIndex()}${\n        component.isHardened() ? \"'\" : ''\n      }`;\n    });\n    return components.join('/');\n  };\n\n  public getComponents = () => this.components;\n  public getSourceFingerprint = () => this.sourceFingerprint;\n  public getDepth = () => this.depth;\n\n  toDataItem = () => {\n    const map: DataItemMap = {};\n    const components: (number | boolean | any[])[] = [];\n    this.components &&\n      this.components.forEach((component) => {\n        if (component.isWildcard()) {\n          components.push([]);\n        } else {\n          components.push(component.getIndex() as number);\n        }\n        components.push(component.isHardened());\n      });\n    map[Keys.components] = components;\n    if (this.sourceFingerprint) {\n      map[Keys.source_fingerprint] = this.sourceFingerprint.readUInt32BE(0);\n    }\n    if (this.depth !== undefined) {\n      map[Keys.depth] = this.depth;\n    }\n    return new DataItem(map);\n  };\n\n  static fromDataItem = (dataItem: DataItem) => {\n    const map: Record<string, any> = dataItem.getData();\n    const pathComponents: PathComponent[] = [];\n    const components = map[Keys.components] as any[];\n    if (components) {\n      for (let i = 0; i < components.length; i += 2) {\n        const isHardened = components[i + 1];\n        const path = components[i];\n        if (typeof path === 'number') {\n          pathComponents.push(\n            new PathComponent({ index: path, hardened: isHardened }),\n          );\n        } else {\n          pathComponents.push(new PathComponent({ hardened: isHardened }));\n        }\n      }\n    }\n    const _sourceFingerprint = map[Keys.source_fingerprint];\n    let sourceFingerprint: Buffer | undefined;\n    if (_sourceFingerprint) {\n      sourceFingerprint = Buffer.alloc(4);\n      sourceFingerprint.writeUInt32BE(_sourceFingerprint, 0);\n    }\n    const depth = map[Keys.depth];\n    return new CryptoKeypath(pathComponents, sourceFingerprint, depth);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoKeypath.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}