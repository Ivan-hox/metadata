{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoHDKey = void 0;\nvar bs58check_1 = require(\"bs58check\");\nvar CryptoCoinInfo_1 = require(\"./CryptoCoinInfo\");\nvar CryptoKeypath_1 = require(\"./CryptoKeypath\");\nvar lib_1 = require(\"./lib\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[Keys[\"is_master\"] = 1] = \"is_master\";\n  Keys[Keys[\"is_private\"] = 2] = \"is_private\";\n  Keys[Keys[\"key_data\"] = 3] = \"key_data\";\n  Keys[Keys[\"chain_code\"] = 4] = \"chain_code\";\n  Keys[Keys[\"use_info\"] = 5] = \"use_info\";\n  Keys[Keys[\"origin\"] = 6] = \"origin\";\n  Keys[Keys[\"children\"] = 7] = \"children\";\n  Keys[Keys[\"parent_fingerprint\"] = 8] = \"parent_fingerprint\";\n  Keys[Keys[\"name\"] = 9] = \"name\";\n  Keys[Keys[\"note\"] = 10] = \"note\";\n})(Keys || (Keys = {}));\nvar CryptoHDKey = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoHDKey, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoHDKey);\n  function CryptoHDKey(args) {\n    var _this;\n    _classCallCheck(this, CryptoHDKey);\n    _this = _super.call(this);\n    _this.isECKey = function () {\n      return false;\n    };\n    _this.getKey = function () {\n      return _this.key;\n    };\n    _this.getChainCode = function () {\n      return _this.chainCode;\n    };\n    _this.isMaster = function () {\n      return _this.master;\n    };\n    _this.isPrivateKey = function () {\n      return !!_this.privateKey;\n    };\n    _this.getUseInfo = function () {\n      return _this.useInfo;\n    };\n    _this.getOrigin = function () {\n      return _this.origin;\n    };\n    _this.getChildren = function () {\n      return _this.children;\n    };\n    _this.getParentFingerprint = function () {\n      return _this.parentFingerprint;\n    };\n    _this.getName = function () {\n      return _this.name;\n    };\n    _this.getNote = function () {\n      return _this.note;\n    };\n    _this.getBip32Key = function () {\n      var _a, _b, _c;\n      var version;\n      var depth;\n      var index = 0;\n      var parentFingerprint = Buffer.alloc(4).fill(0);\n      if (_this.isMaster()) {\n        version = Buffer.from('0488ADE4', 'hex');\n        depth = 0;\n        index = 0;\n      } else {\n        depth = ((_a = _this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getComponents().length) || ((_b = _this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getDepth());\n        var paths = (_c = _this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getComponents();\n        var lastPath = paths[paths.length - 1];\n        if (lastPath) {\n          index = lastPath.isHardened() ? lastPath.getIndex() + 0x80000000 : lastPath.getIndex();\n          if (_this.getParentFingerprint()) {\n            parentFingerprint = _this.getParentFingerprint();\n          }\n        }\n        if (_this.isPrivateKey()) {\n          version = Buffer.from('0488ADE4', 'hex');\n        } else {\n          version = Buffer.from('0488B21E', 'hex');\n        }\n      }\n      var depthBuffer = Buffer.alloc(1);\n      depthBuffer.writeUInt8(depth, 0);\n      var indexBuffer = Buffer.alloc(4);\n      indexBuffer.writeUInt32BE(index, 0);\n      var chainCode = _this.getChainCode();\n      var key = _this.getKey();\n      return (0, bs58check_1.encode)(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode, key]));\n    };\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_HDKEY;\n    };\n    _this.getOutputDescriptorContent = function () {\n      var _a, _b, _c, _d, _e, _f, _g;\n      var result = '';\n      if (_this.getOrigin()) {\n        if (((_a = _this.getOrigin()) === null || _a === void 0 ? void 0 : _a.getSourceFingerprint()) && ((_b = _this.getOrigin()) === null || _b === void 0 ? void 0 : _b.getPath())) {\n          result += \"\".concat((_d = (_c = _this.getOrigin()) === null || _c === void 0 ? void 0 : _c.getSourceFingerprint()) === null || _d === void 0 ? void 0 : _d.toString('hex'), \"/\").concat((_e = _this.getOrigin()) === null || _e === void 0 ? void 0 : _e.getPath());\n        }\n      }\n      result += _this.getBip32Key();\n      if (_this.getChildren()) {\n        if ((_f = _this.getChildren()) === null || _f === void 0 ? void 0 : _f.getPath()) {\n          result += \"/\".concat((_g = _this.getChildren()) === null || _g === void 0 ? void 0 : _g.getPath());\n        }\n      }\n      return result;\n    };\n    _this.setupMasterKey = function (args) {\n      _this.master = true;\n      _this.key = args.key;\n      _this.chainCode = args.chainCode;\n    };\n    _this.setupDeriveKey = function (args) {\n      _this.master = false;\n      _this.privateKey = args.isPrivateKey;\n      _this.key = args.key;\n      _this.chainCode = args.chainCode;\n      _this.useInfo = args.useInfo;\n      _this.origin = args.origin;\n      _this.children = args.children;\n      _this.parentFingerprint = args.parentFingerprint;\n      _this.name = args.name;\n      _this.note = args.note;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      if (_this.master) {\n        map[Keys.is_master] = true;\n        map[Keys.key_data] = _this.key;\n        map[Keys.chain_code] = _this.chainCode;\n      } else {\n        if (_this.privateKey !== undefined) {\n          map[Keys.is_private] = _this.privateKey;\n        }\n        map[Keys.key_data] = _this.key;\n        if (_this.chainCode) {\n          map[Keys.chain_code] = _this.chainCode;\n        }\n        if (_this.useInfo) {\n          var useInfo = _this.useInfo.toDataItem();\n          useInfo.setTag(_this.useInfo.getRegistryType().getTag());\n          map[Keys.use_info] = useInfo;\n        }\n        if (_this.origin) {\n          var origin = _this.origin.toDataItem();\n          origin.setTag(_this.origin.getRegistryType().getTag());\n          map[Keys.origin] = origin;\n        }\n        if (_this.children) {\n          var children = _this.children.toDataItem();\n          children.setTag(_this.children.getRegistryType().getTag());\n          map[Keys.children] = children;\n        }\n        if (_this.parentFingerprint) {\n          map[Keys.parent_fingerprint] = _this.parentFingerprint.readUInt32BE(0);\n        }\n        if (_this.name !== undefined) {\n          map[Keys.name] = _this.name;\n        }\n        if (_this.note !== undefined) {\n          map[Keys.note] = _this.note;\n        }\n      }\n      return new lib_1.DataItem(map);\n    };\n    if (args.isMaster) {\n      _this.setupMasterKey(args);\n    } else {\n      _this.setupDeriveKey(args);\n    }\n    return _this;\n  }\n  return _createClass(CryptoHDKey);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoHDKey = CryptoHDKey;\nCryptoHDKey.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var isMaster = !!map[Keys.is_master];\n  var isPrivateKey = map[Keys.is_private];\n  var key = map[Keys.key_data];\n  var chainCode = map[Keys.chain_code];\n  var useInfo = map[Keys.use_info] ? CryptoCoinInfo_1.CryptoCoinInfo.fromDataItem(map[Keys.use_info]) : undefined;\n  var origin = map[Keys.origin] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.origin]) : undefined;\n  var children = map[Keys.children] ? CryptoKeypath_1.CryptoKeypath.fromDataItem(map[Keys.children]) : undefined;\n  var _parentFingerprint = map[Keys.parent_fingerprint];\n  var parentFingerprint = undefined;\n  if (_parentFingerprint) {\n    parentFingerprint = Buffer.alloc(4);\n    parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n  }\n  var name = map[Keys.name];\n  var note = map[Keys.note];\n  return new CryptoHDKey({\n    isMaster: isMaster,\n    isPrivateKey: isPrivateKey,\n    key: key,\n    chainCode: chainCode,\n    useInfo: useInfo,\n    origin: origin,\n    children: children,\n    parentFingerprint: parentFingerprint,\n    name: name,\n    note: note\n  });\n};\nCryptoHDKey.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoHDKey.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":"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","names":["Keys","CryptoHDKey","args","key","chainCode","master","privateKey","useInfo","origin","children","parentFingerprint","name","note","version","depth","index","Buffer","alloc","fill","isMaster","from","getOrigin","getComponents","length","getDepth","paths","lastPath","isHardened","getIndex","getParentFingerprint","isPrivateKey","depthBuffer","writeUInt8","indexBuffer","writeUInt32BE","getChainCode","getKey","concat","RegistryType_1","CRYPTO_HDKEY","result","getSourceFingerprint","getPath","toString","getBip32Key","getChildren","map","is_master","key_data","chain_code","undefined","is_private","toDataItem","setTag","getRegistryType","getTag","use_info","parent_fingerprint","readUInt32BE","lib_1","setupMasterKey","setupDeriveKey","RegistryItem_1","exports","dataItem","getData","CryptoCoinInfo_1","fromDataItem","CryptoKeypath_1","_parentFingerprint","_cborPayload"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoHDKey.ts"],"sourcesContent":["import { encode } from 'bs58check';\nimport { CryptoCoinInfo } from './CryptoCoinInfo';\nimport { CryptoKeypath } from './CryptoKeypath';\nimport { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap, ICryptoKey } from './types';\nimport { PathComponent } from './PathComponent';\n\nenum Keys {\n  is_master = 1,\n  is_private,\n  key_data,\n  chain_code,\n  use_info,\n  origin,\n  children,\n  parent_fingerprint,\n  name,\n  note,\n}\n\ntype MasterKeyProps = {\n  isMaster: true;\n  key: Buffer;\n  chainCode: Buffer;\n};\n\ntype DeriveKeyProps = {\n  isMaster: false;\n  isPrivateKey?: boolean;\n  key: Buffer;\n  chainCode?: Buffer;\n  useInfo?: CryptoCoinInfo;\n  origin?: CryptoKeypath;\n  children?: CryptoKeypath;\n  parentFingerprint?: Buffer;\n  name?: string;\n  note?: string;\n};\n\nexport class CryptoHDKey extends RegistryItem implements ICryptoKey {\n  private master?: boolean;\n  private privateKey?: boolean;\n  private key?: Buffer;\n  private chainCode?: Buffer;\n  private useInfo?: CryptoCoinInfo;\n  private origin?: CryptoKeypath;\n  private children?: CryptoKeypath;\n  private parentFingerprint?: Buffer;\n  private name?: string;\n  private note?: string;\n\n  isECKey = () => {\n    return false;\n  };\n\n  public getKey = () => this.key;\n  public getChainCode = () => this.chainCode;\n  public isMaster = () => this.master;\n  public isPrivateKey = () => !!this.privateKey;\n  public getUseInfo = () => this.useInfo;\n  public getOrigin = () => this.origin;\n  public getChildren = () => this.children;\n  public getParentFingerprint = () => this.parentFingerprint;\n  public getName = () => this.name;\n  public getNote = () => this.note;\n  public getBip32Key = () => {\n    let version: Buffer;\n    let depth: number;\n    let index = 0;\n    let parentFingerprint: Buffer = Buffer.alloc(4).fill(0);\n    if (this.isMaster()) {\n      // version bytes defined on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format\n      version = Buffer.from('0488ADE4', 'hex');\n      depth = 0;\n      index = 0;\n    } else {\n      depth = this.getOrigin()?.getComponents().length || this.getOrigin()?.getDepth() as number;\n      const paths = this.getOrigin()?.getComponents() as PathComponent[];\n      const lastPath = paths[paths.length - 1];\n      if (lastPath) {\n        index = lastPath.isHardened() ? lastPath.getIndex()! + 0x80000000 : lastPath.getIndex()!;\n        if (this.getParentFingerprint()) {\n          parentFingerprint = this.getParentFingerprint() as Buffer;\n        }\n      }\n      if (this.isPrivateKey()) {\n        version = Buffer.from('0488ADE4', 'hex');\n      } else {\n        version = Buffer.from('0488B21E', 'hex');\n      }\n    }\n    const depthBuffer = Buffer.alloc(1);\n    depthBuffer.writeUInt8(depth, 0);\n    const indexBuffer = Buffer.alloc(4);\n    indexBuffer.writeUInt32BE(index, 0);\n    const chainCode = this.getChainCode();\n    const key = this.getKey();\n    return encode(Buffer.concat([version, depthBuffer, parentFingerprint, indexBuffer, chainCode as Buffer, key as Buffer]));\n  };\n\n  public getRegistryType = () => {\n    return RegistryTypes.CRYPTO_HDKEY;\n  };\n\n  public getOutputDescriptorContent = () => {\n    let result = '';\n    if (this.getOrigin()) {\n      if (this.getOrigin()?.getSourceFingerprint() && this.getOrigin()?.getPath()) {\n        result += `${this.getOrigin()?.getSourceFingerprint()?.toString('hex')}/${this.getOrigin()?.getPath()}`;\n      }\n    }\n    result += this.getBip32Key();\n    if (this.getChildren()) {\n      if (this.getChildren()?.getPath()) {\n        result += `/${this.getChildren()?.getPath()}`;\n      }\n    }\n    return result;\n  };\n\n  constructor(args: DeriveKeyProps | MasterKeyProps) {\n    super();\n    if (args.isMaster) {\n      this.setupMasterKey(args);\n    } else {\n      this.setupDeriveKey(args as DeriveKeyProps);\n    }\n  }\n\n  private setupMasterKey = (args: MasterKeyProps) => {\n    this.master = true;\n    this.key = args.key;\n    this.chainCode = args.chainCode;\n  };\n\n  private setupDeriveKey = (args: DeriveKeyProps) => {\n    this.master = false;\n    this.privateKey = args.isPrivateKey;\n    this.key = args.key;\n    this.chainCode = args.chainCode;\n    this.useInfo = args.useInfo;\n    this.origin = args.origin;\n    this.children = args.children;\n    this.parentFingerprint = args.parentFingerprint;\n    this.name = args.name;\n    this.note = args.note;\n  };\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.master) {\n      map[Keys.is_master] = true;\n      map[Keys.key_data] = this.key;\n      map[Keys.chain_code] = this.chainCode;\n    } else {\n      if (this.privateKey !== undefined) {\n        map[Keys.is_private] = this.privateKey;\n      }\n      map[Keys.key_data] = this.key;\n      if (this.chainCode) {\n        map[Keys.chain_code] = this.chainCode;\n      }\n      if (this.useInfo) {\n        const useInfo = this.useInfo.toDataItem();\n        useInfo.setTag(this.useInfo.getRegistryType().getTag());\n        map[Keys.use_info] = useInfo;\n      }\n      if (this.origin) {\n        const origin = this.origin.toDataItem();\n        origin.setTag(this.origin.getRegistryType().getTag());\n        map[Keys.origin] = origin;\n      }\n      if (this.children) {\n        const children = this.children.toDataItem();\n        children.setTag(this.children.getRegistryType().getTag());\n        map[Keys.children] = children;\n      }\n      if (this.parentFingerprint) {\n        map[Keys.parent_fingerprint] = this.parentFingerprint.readUInt32BE(0);\n      }\n      if (this.name !== undefined) {\n        map[Keys.name] = this.name;\n      }\n      if (this.note !== undefined) {\n        map[Keys.note] = this.note;\n      }\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const isMaster = !!map[Keys.is_master];\n    const isPrivateKey = map[Keys.is_private];\n    const key = map[Keys.key_data];\n    const chainCode = map[Keys.chain_code];\n    const useInfo = map[Keys.use_info]\n      ? CryptoCoinInfo.fromDataItem(map[Keys.use_info])\n      : undefined;\n    const origin = map[Keys.origin]\n      ? CryptoKeypath.fromDataItem(map[Keys.origin])\n      : undefined;\n    const children = map[Keys.children]\n      ? CryptoKeypath.fromDataItem(map[Keys.children])\n      : undefined;\n    const _parentFingerprint = map[Keys.parent_fingerprint];\n    let parentFingerprint: Buffer | undefined = undefined;\n    if (_parentFingerprint) {\n      parentFingerprint = Buffer.alloc(4);\n      parentFingerprint.writeUInt32BE(_parentFingerprint, 0);\n    }\n    const name = map[Keys.name];\n    const note = map[Keys.note];\n\n    return new CryptoHDKey({\n      isMaster,\n      isPrivateKey,\n      key,\n      chainCode,\n      useInfo,\n      origin,\n      children,\n      parentFingerprint,\n      name,\n      note,\n    });\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoHDKey.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}