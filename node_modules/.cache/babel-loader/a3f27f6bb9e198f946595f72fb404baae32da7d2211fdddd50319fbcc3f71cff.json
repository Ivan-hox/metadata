{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOrCreateAssociatedTokenAccount = void 0;\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar constants_js_1 = require(\"../constants.js\");\nvar errors_js_1 = require(\"../errors.js\");\nvar associatedTokenAccount_js_1 = require(\"../instructions/associatedTokenAccount.js\");\nvar account_js_1 = require(\"../state/account.js\");\nvar mint_js_1 = require(\"../state/mint.js\");\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nfunction getOrCreateAssociatedTokenAccount(connection, payer, mint, owner) {\n  var allowOwnerOffCurve = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var commitment = arguments.length > 5 ? arguments[5] : undefined;\n  var confirmOptions = arguments.length > 6 ? arguments[6] : undefined;\n  var programId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : constants_js_1.TOKEN_PROGRAM_ID;\n  var associatedTokenProgramId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var associatedToken, account, transaction;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return (0, mint_js_1.getAssociatedTokenAddress)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n          case 2:\n            associatedToken = _context.sent;\n            _context.prev = 3;\n            _context.next = 6;\n            return (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);\n          case 6:\n            account = _context.sent;\n            _context.next = 26;\n            break;\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](3);\n            if (!(_context.t0 instanceof errors_js_1.TokenAccountNotFoundError || _context.t0 instanceof errors_js_1.TokenInvalidAccountOwnerError)) {\n              _context.next = 25;\n              break;\n            }\n            _context.prev = 12;\n            transaction = new web3_js_1.Transaction().add((0, associatedTokenAccount_js_1.createAssociatedTokenAccountInstruction)(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n            _context.next = 16;\n            return (0, web3_js_1.sendAndConfirmTransaction)(connection, transaction, [payer], confirmOptions);\n          case 16:\n            _context.next = 20;\n            break;\n          case 18:\n            _context.prev = 18;\n            _context.t1 = _context[\"catch\"](12);\n          case 20:\n            _context.next = 22;\n            return (0, account_js_1.getAccount)(connection, associatedToken, commitment, programId);\n          case 22:\n            account = _context.sent;\n            _context.next = 26;\n            break;\n          case 25:\n            throw _context.t0;\n          case 26:\n            if (account.mint.equals(mint)) {\n              _context.next = 28;\n              break;\n            }\n            throw new errors_js_1.TokenInvalidMintError();\n          case 28:\n            if (account.owner.equals(owner)) {\n              _context.next = 30;\n              break;\n            }\n            throw new errors_js_1.TokenInvalidOwnerError();\n          case 30:\n            return _context.abrupt(\"return\", account);\n          case 31:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3, 9], [12, 18]]);\n  }));\n}\nexports.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AAMA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;AAeA,SAAsBA,iCAAiC,CACnDC,UAAsB,EACtBC,KAAa,EACbC,IAAe,EACfC,KAAgB,EAKsC;EAAA,IAJtDC,kBAAkB,uEAAG,KAAK;EAAA,IAC1BC,UAAuB;EAAA,IACvBC,cAA+B;EAAA,IAC/BC,SAAS,uEAAGC,+BAAgB;EAAA,IAC5BC,wBAAwB,uEAAGD,0CAA2B;;;;;;;;YAE9B,OAAM,uCAAyB,EACnDN,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBG,SAAS,EACTE,wBAAwB,CAC3B;UAAA;YANKC,eAAe;YAAA;YAAA;YAYP,OAAM,2BAAU,EAACV,UAAU,EAAEU,eAAe,EAAEL,UAAU,EAAEE,SAAS,CAAC;UAAA;YAA9EI,OAAO;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA,MAKH,uBAAiBC,qCAAyB,IAAI,uBAAiBA,yCAA6B;cAAA;cAAA;YAAA;YAAA;YAGlFC,WAAW,GAAG,IAAIC,qBAAW,EAAE,CAACC,GAAG,CACrC,uEAAuC,EACnCd,KAAK,CAACe,SAAS,EACfN,eAAe,EACfP,KAAK,EACLD,IAAI,EACJK,SAAS,EACTE,wBAAwB,CAC3B,CACJ;YAAA;YAED,OAAM,uCAAyB,EAACT,UAAU,EAAEa,WAAW,EAAE,CAACZ,KAAK,CAAC,EAAEK,cAAc,CAAC;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAO3E,OAAM,2BAAU,EAACN,UAAU,EAAEU,eAAe,EAAEL,UAAU,EAAEE,SAAS,CAAC;UAAA;YAA9EI,OAAO;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA,IAMVA,OAAO,CAACT,IAAI,CAACe,MAAM,CAACf,IAAI,CAAC;cAAA;cAAA;YAAA;YAAA,MAAQ,IAAIU,iCAAqB,EAAE;UAAA;YAAA,IAC5DD,OAAO,CAACR,KAAK,CAACc,MAAM,CAACd,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MAAQ,IAAIS,kCAAsB,EAAE;UAAA;YAAA,iCAE7DD,OAAO;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACjB;;AA3DDO","names":["getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","constants_js_1","associatedTokenProgramId","associatedToken","account","errors_js_1","transaction","web3_js_1","add","publicKey","equals","exports"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}