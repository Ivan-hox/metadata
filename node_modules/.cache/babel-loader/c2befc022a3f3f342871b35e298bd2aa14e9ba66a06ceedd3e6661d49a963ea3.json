{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar fountainEncoder_1 = __importDefault(require(\"./fountainEncoder\"));\nvar bytewords_1 = __importDefault(require(\"./bytewords\"));\nvar UREncoder = /*#__PURE__*/function () {\n  function UREncoder(_ur, maxFragmentLength, firstSeqNum, minFragmentLength) {\n    _classCallCheck(this, UREncoder);\n    this.ur = _ur;\n    this.fountainEncoder = new fountainEncoder_1.default(_ur.cbor, maxFragmentLength, firstSeqNum, minFragmentLength);\n  }\n  _createClass(UREncoder, [{\n    key: \"fragmentsLength\",\n    get: function get() {\n      return this.fountainEncoder.fragmentsLength;\n    }\n  }, {\n    key: \"fragments\",\n    get: function get() {\n      return this.fountainEncoder.fragments;\n    }\n  }, {\n    key: \"messageLength\",\n    get: function get() {\n      return this.fountainEncoder.messageLength;\n    }\n  }, {\n    key: \"cbor\",\n    get: function get() {\n      return this.ur.cbor;\n    }\n  }, {\n    key: \"encodeWhole\",\n    value: function encodeWhole() {\n      var _this = this;\n      return _toConsumableArray(new Array(this.fragmentsLength)).map(function () {\n        return _this.nextPart();\n      });\n    }\n  }, {\n    key: \"nextPart\",\n    value: function nextPart() {\n      var part = this.fountainEncoder.nextPart();\n      if (this.fountainEncoder.isSinglePart()) {\n        return UREncoder.encodeSinglePart(this.ur);\n      } else {\n        return UREncoder.encodePart(this.ur.type, part);\n      }\n    }\n  }], [{\n    key: \"encodeUri\",\n    value: function encodeUri(scheme, pathComponents) {\n      var path = pathComponents.join('/');\n      return [scheme, path].join(':');\n    }\n  }, {\n    key: \"encodeUR\",\n    value: function encodeUR(pathComponents) {\n      return UREncoder.encodeUri('ur', pathComponents);\n    }\n  }, {\n    key: \"encodePart\",\n    value: function encodePart(type, part) {\n      var seq = \"\".concat(part.seqNum, \"-\").concat(part.seqLength);\n      var body = bytewords_1.default.encode(part.cbor().toString('hex'), bytewords_1.default.STYLES.MINIMAL);\n      return UREncoder.encodeUR([type, seq, body]);\n    }\n  }, {\n    key: \"encodeSinglePart\",\n    value: function encodeSinglePart(ur) {\n      var body = bytewords_1.default.encode(ur.cbor.toString('hex'), bytewords_1.default.STYLES.MINIMAL);\n      return UREncoder.encodeUR([ur.type, body]);\n    }\n  }]);\n  return UREncoder;\n}();\nexports.default = UREncoder;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AACA;AAAoC,IAGfA,SAAS;EAI5B,mBACEC,GAAO,EACPC,iBAA0B,EAC1BC,WAAoB,EACpBC,iBAA0B;IAAA;IAE1B,IAAI,CAACC,EAAE,GAAGJ,GAAG;IACb,IAAI,CAACK,eAAe,GAAG,IAAIC,yBAAe,CAACN,GAAG,CAACO,IAAI,EAAEN,iBAAiB,EAAEC,WAAW,EAAEC,iBAAiB,CAAC;EACzG;EAAC;IAAA;IAAA,KAED,eAA0B;MAAK,OAAO,IAAI,CAACE,eAAe,CAACG,eAAe;IAAE;EAAC;IAAA;IAAA,KAC7E,eAAoB;MAAK,OAAO,IAAI,CAACH,eAAe,CAACI,SAAS;IAAE;EAAC;IAAA;IAAA,KACjE,eAAwB;MAAK,OAAO,IAAI,CAACJ,eAAe,CAACK,aAAa;IAAE;EAAC;IAAA;IAAA,KACzE,eAAe;MAAK,OAAO,IAAI,CAACN,EAAE,CAACG,IAAI;IAAE;EAAC;IAAA;IAAA,OAEnC,uBAAW;MAAA;MAChB,OAAO,mBAAI,IAAII,KAAK,CAAC,IAAI,CAACH,eAAe,CAAC,EAAEI,GAAG,CAAC;QAAA,OAAM,KAAI,CAACC,QAAQ,EAAE;MAAA,EAAC;IACxE;EAAC;IAAA;IAAA,OAEM,oBAAQ;MACb,IAAMC,IAAI,GAAG,IAAI,CAACT,eAAe,CAACQ,QAAQ,EAAE;MAE5C,IAAI,IAAI,CAACR,eAAe,CAACU,YAAY,EAAE,EAAE;QACvC,OAAOhB,SAAS,CAACiB,gBAAgB,CAAC,IAAI,CAACZ,EAAE,CAAC;OAC3C,MACI;QACH,OAAOL,SAAS,CAACkB,UAAU,CAAC,IAAI,CAACb,EAAE,CAACc,IAAI,EAAEJ,IAAI,CAAC;;IAEnD;EAAC;IAAA;IAAA,OAEO,mBAAiBK,MAAc,EAAEC,cAAwB;MAC/D,IAAMC,IAAI,GAAGD,cAAc,CAACE,IAAI,CAAC,GAAG,CAAC;MACrC,OAAO,CAACH,MAAM,EAAEE,IAAI,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;IACjC;EAAC;IAAA;IAAA,OAEO,kBAAgBF,cAAwB;MAC9C,OAAOrB,SAAS,CAACwB,SAAS,CAAC,IAAI,EAAEH,cAAc,CAAC;IAClD;EAAC;IAAA;IAAA,OAEO,oBAAkBF,IAAY,EAAEJ,IAAyB;MAC/D,IAAMU,GAAG,aAAMV,IAAI,CAACW,MAAM,cAAIX,IAAI,CAACY,SAAS,CAAE;MAC9C,IAAMC,IAAI,GAAGC,mBAAS,CAACC,MAAM,CAACf,IAAI,CAACP,IAAI,EAAE,CAACuB,QAAQ,CAAC,KAAK,CAAC,EAAEF,mBAAS,CAACG,MAAM,CAACC,OAAO,CAAC;MAEpF,OAAOjC,SAAS,CAACkC,QAAQ,CAAC,CAACf,IAAI,EAAEM,GAAG,EAAEG,IAAI,CAAC,CAAC;IAC9C;EAAC;IAAA;IAAA,OAEM,0BAAwBvB,EAAM;MACnC,IAAMuB,IAAI,GAAGC,mBAAS,CAACC,MAAM,CAACzB,EAAE,CAACG,IAAI,CAACuB,QAAQ,CAAC,KAAK,CAAC,EAAEF,mBAAS,CAACG,MAAM,CAACC,OAAO,CAAC;MAEhF,OAAOjC,SAAS,CAACkC,QAAQ,CAAC,CAAC7B,EAAE,CAACc,IAAI,EAAES,IAAI,CAAC,CAAC;IAC5C;EAAC;EAAA;AAAA;AAtDHO","names":["UREncoder","_ur","maxFragmentLength","firstSeqNum","minFragmentLength","ur","fountainEncoder","fountainEncoder_1","cbor","fragmentsLength","fragments","messageLength","Array","map","nextPart","part","isSinglePart","encodeSinglePart","encodePart","type","scheme","pathComponents","path","join","encodeUri","seq","seqNum","seqLength","body","bytewords_1","encode","toString","STYLES","MINIMAL","encodeUR","exports"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/urEncoder.ts"],"sourcesContent":["import FountainEncoder, { FountainEncoderPart } from './fountainEncoder';\nimport bytewords from './bytewords';\nimport UR from './ur';\n\nexport default class UREncoder {\n  private ur: UR;\n  private fountainEncoder: FountainEncoder;\n\n  constructor(\n    _ur: UR,\n    maxFragmentLength?: number,\n    firstSeqNum?: number,\n    minFragmentLength?: number,\n  ) {\n    this.ur = _ur;\n    this.fountainEncoder = new FountainEncoder(_ur.cbor, maxFragmentLength, firstSeqNum, minFragmentLength);\n  }\n\n  public get fragmentsLength() { return this.fountainEncoder.fragmentsLength; }\n  public get fragments() { return this.fountainEncoder.fragments; }\n  public get messageLength() { return this.fountainEncoder.messageLength; }\n  public get cbor() { return this.ur.cbor; }\n\n  public encodeWhole(): string[] {\n    return [...new Array(this.fragmentsLength)].map(() => this.nextPart())\n  }\n\n  public nextPart(): string {\n    const part = this.fountainEncoder.nextPart();\n\n    if (this.fountainEncoder.isSinglePart()) {\n      return UREncoder.encodeSinglePart(this.ur);\n    }\n    else {\n      return UREncoder.encodePart(this.ur.type, part)\n    }\n  }\n\n  private static encodeUri(scheme: string, pathComponents: string[]): string {\n    const path = pathComponents.join('/');\n    return [scheme, path].join(':')\n  }\n\n  private static encodeUR(pathComponents: string[]): string {\n    return UREncoder.encodeUri('ur', pathComponents);\n  }\n\n  private static encodePart(type: string, part: FountainEncoderPart): string {\n    const seq = `${part.seqNum}-${part.seqLength}`;\n    const body = bytewords.encode(part.cbor().toString('hex'), bytewords.STYLES.MINIMAL);\n\n    return UREncoder.encodeUR([type, seq, body])\n  }\n\n  public static encodeSinglePart(ur: UR): string {\n    const body = bytewords.encode(ur.cbor.toString('hex'), bytewords.STYLES.MINIMAL);\n\n    return UREncoder.encodeUR([ur.type, body])\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}