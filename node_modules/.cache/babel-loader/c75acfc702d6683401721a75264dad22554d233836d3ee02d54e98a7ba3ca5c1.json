{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GpaBuilder = void 0;\nvar beet_1 = require(\"@metaplex-foundation/beet\");\nvar assert_1 = require(\"assert\");\nvar utils_1 = require(\"../utils\");\nvar util_1 = require(\"./util\");\n/**\n * Provides an Account specific GPA builder.\n *\n * @template T - the type of the account for which the GpaBuilder is used\n */\nvar GpaBuilder = /*#__PURE__*/function () {\n  function GpaBuilder(programId, beets, accountSize) {\n    _classCallCheck(this, GpaBuilder);\n    this.programId = programId;\n    this.beets = beets;\n    this.accountSize = accountSize;\n    /**\n     * web3.js {@link GetProgramAccountsConfig} configured via filter GpaBuilder filter methods.\n     */\n    this.config = {};\n  }\n  _createClass(GpaBuilder, [{\n    key: \"_addFilter\",\n    value: function _addFilter(filter) {\n      if (this.config.filters == null) {\n        this.config.filters = [];\n      }\n      this.config.filters.push(filter);\n      return this;\n    }\n  }, {\n    key: \"_addInnerFilter\",\n    value: function _addInnerFilter(key, innerKey, val) {\n      (0, utils_1.logTrace)(\"gpa.addInnerFilter: \".concat(key, \".\").concat(innerKey));\n      var outerBeetInfo = this.beets.get(key);\n      (0, assert_1.strict)(outerBeetInfo != null, 'Outer filter key needs to be an existing field name');\n      var beetInfo = outerBeetInfo.beet;\n      var offset = outerBeetInfo.offset;\n      var outerBeet = (0, beet_1.isFixedSizeBeet)(beetInfo) ? beetInfo : beetInfo.toFixedFromValue(val);\n      var beet;\n      var _iterator = _createForOfIteratorHelper(outerBeet.fields),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            k = _step$value[0],\n            v = _step$value[1];\n          if (k === innerKey) {\n            beet = v;\n            break;\n          }\n          offset += v.byteSize;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      (0, assert_1.strict)(beet != null, \"\".concat(innerKey, \" is not a field of the \").concat(key, \" struct\"));\n      var bytes = (0, util_1.encodeFixedBeet)(beet, val);\n      this._addFilter({\n        memcmp: {\n          offset: offset,\n          bytes: bytes\n        }\n      });\n      return this;\n    }\n    /**\n     * Adds a _memcmp_ filter for a field inside a field which is a struct value.\n     * The provided keys need to be separated by a `.` and only one level of\n     * nesting is supported at this point.\n     *\n     * The filter is applied to the inner value.\n     *\n     * ## Example\n     *\n     * ### Given:\n     *\n     * ```typescript\n     * type Inner = {\n     *   a: number\n     * }\n     * type Outer = {\n     *   idx: number\n     *   inner: Inner\n     * }\n     * ```\n     * ### Apply a filter on `a` of the `Inner` type:\n     *\n     * ```typescript\n     * gpaBuilder.addInnerFilter('inner.a', 2)\n     * ```\n     *\n     * @param keys - the names of the fields by which to filter, i.e. `'outer.inner'`\n     * @param val - the field value that the filter should match\n     */\n  }, {\n    key: \"addInnerFilter\",\n    value: function addInnerFilter(keys, val) {\n      var parts = keys.split('.');\n      assert_1.strict.equal(parts.length, 2, \"inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not\");\n      var _parts = _slicedToArray(parts, 2),\n        ka = _parts[0],\n        kb = _parts[1];\n      return this._addInnerFilter(ka, kb, val);\n    }\n    /**\n     * Adds a _memcmp_ filter for the provided {@link key} of the struct.\n     *\n     * @param key - the name of the field by which to filter\n     * @param val - the field value that the filter should match\n     */\n  }, {\n    key: \"addFilter\",\n    value: function addFilter(key, val) {\n      var beetInfo = this.beets.get(key);\n      (0, assert_1.strict)(beetInfo != null, 'Filter key needs to be an existing field name');\n      var beet = (0, beet_1.isFixedSizeBeet)(beetInfo.beet) ? beetInfo.beet : beetInfo.beet.toFixedFromValue(val);\n      var bytes = (0, util_1.encodeFixedBeet)(beet, val);\n      this._addFilter({\n        memcmp: {\n          offset: beetInfo.offset,\n          bytes: bytes\n        }\n      });\n      return this;\n    }\n    /**\n     * Adds a `dataSize` filter which will match on account's sizes.\n     * You have to provide that {@link size} for accounts that don't have a fixed size.\n     * For _fixed_ size accounts that size is determined for you.\n     *\n     * @param size - the account size to match for\n     */\n  }, {\n    key: \"dataSize\",\n    value: function dataSize(size) {\n      size = size !== null && size !== void 0 ? size : this.accountSize;\n      (0, assert_1.strict)(size != null, 'for accounts of dynamic size the dataSize arg needs to be provided');\n      return this._addFilter({\n        dataSize: size\n      });\n    }\n    /**\n     * Attempts to find the accounts matching the configured filters.\n     *\n     * @param connection used to query the program accounts on the cluster\n     */\n  }, {\n    key: \"run\",\n    value: function run(connection) {\n      return connection.getProgramAccounts(this.programId, this.config);\n    }\n    /**\n     * Creates a GPA builder that supports adding up to four filters for\n     * fixed size fields.\n     *\n     * Once a non-fixed field is encountered, the remaining fields following it\n     * will not be included as a filter option since their position in the\n     * bytes array will change depending on the content of the non-fixed field.\n     *\n     * @param programId - the id of the program that owns the accounts we are querying\n     * @param beetFields - the beet fields that make up the structure of the account data\n     */\n  }], [{\n    key: \"fromBeetFields\",\n    value: function fromBeetFields(programId, beetFields) {\n      var map = new Map();\n      var offset = 0;\n      var encounteredNonFixed = false;\n      var _iterator2 = _createForOfIteratorHelper(beetFields),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            k = _step2$value[0],\n            v = _step2$value[1];\n          map.set(k, {\n            beet: v,\n            offset: offset\n          });\n          if (!(0, beet_1.isFixedSizeBeet)(v)) {\n            encounteredNonFixed = true;\n            break;\n          }\n          offset += v.byteSize;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var accountSize = encounteredNonFixed ? undefined : offset;\n      return new GpaBuilder(programId, map, accountSize);\n    }\n    /**\n     * Convenience wrapper around {@link GpaBuilder.fromBeetFields} that allows\n     * providing a struct which contains the beet fields.\n     *\n     * @param programId - the id of the program that owns the accounts we are querying\n     * @param struct - containing the beet `fields` specifying the layout of the account\n     */\n  }, {\n    key: \"fromStruct\",\n    value: function fromStruct(programId, struct) {\n      return GpaBuilder.fromBeetFields(programId, struct.fields);\n    }\n  }]);\n  return GpaBuilder;\n}();\nexports.GpaBuilder = GpaBuilder;","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AAcA;AACA;AACA;AAMA;;;;;AAAA,IAKaA,UAAU;EAMrB,oBACmBC,SAAoB,EACpBC,KAMhB,EACgBC,WAA+B;IAAA;IAR/B,cAAS,GAATF,SAAS;IACT,UAAK,GAALC,KAAK;IAOL,gBAAW,GAAXC,WAAW;IAd9B;;;IAGS,WAAM,GAA6B,EAAE;EAY3C;EAAC;IAAA;IAAA,OAEI,oBAAWC,MAAgC;MACjD,IAAI,IAAI,CAACC,MAAM,CAACC,OAAO,IAAI,IAAI,EAAE;QAC/B,IAAI,CAACD,MAAM,CAACC,OAAO,GAAG,EAAE;;MAG1B,IAAI,CAACD,MAAM,CAACC,OAAO,CAACC,IAAI,CAACH,MAAM,CAAC;MAEhC,OAAO,IAAI;IACb;EAAC;IAAA;IAAA,OAEO,yBACNI,GAAqB,EACrBC,QAAgB,EAChBC,GAAoB;MAEpB,oBAAQ,gCAAwBF,GAAG,cAAIC,QAAQ,EAAG;MAClD,IAAME,aAAa,GAAG,IAAI,CAACT,KAAK,CAACU,GAAG,CAACJ,GAAG,CAAC;MACzC,mBAAM,EACJG,aAAa,IAAI,IAAI,EACrB,qDAAqD,CACtD;MAED,IAAME,QAAQ,GAAGF,aAAa,CAACG,IAEL;MAE1B,IAAIC,MAAM,GAAGJ,aAAa,CAACI,MAAM;MACjC,IAAMC,SAAS,GAAG,0BAAe,EAACH,QAAQ,CAAC,GACvCA,QAAQ,GACRA,QAAQ,CAACI,gBAAgB,CAACP,GAAG,CAAC;MAElC,IAAII,IAAI;MAAA,2CACaE,SAAS,CAACE,MAAM;QAAA;MAAA;QAArC,oDAAuC;UAAA;YAA3BC,CAAC;YAAEC,CAAC;UACd,IAAID,CAAC,KAAKV,QAAQ,EAAE;YAClBK,IAAI,GAAGM,CAAC;YACR;;UAEFL,MAAM,IAAIK,CAAC,CAACC,QAAQ;;MACrB;QAAA;MAAA;QAAA;MAAA;MACD,mBAAM,EAACP,IAAI,IAAI,IAAI,YAAKL,QAAQ,oCAA0BD,GAAG,aAAU;MACvE,IAAMc,KAAK,GAAG,0BAAe,EAACR,IAAI,EAAEJ,GAAG,CAAC;MACxC,IAAI,CAACa,UAAU,CAAC;QAAEC,MAAM,EAAE;UAAET,MAAM,EAANA,MAAM;UAAEO,KAAK,EAALA;QAAK;MAAE,CAAE,CAAC;MAC9C,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAAA;IAAA;IAAA,OA6BA,wBAAeG,IAAY,EAAEf,GAAoB;MAC/C,IAAMgB,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;MAC7BC,eAAM,CAACC,KAAK,CACVH,KAAK,CAACI,MAAM,EACZ,CAAC,sGAEF;MACD,4BAAiBJ,KAAmC;QAA7CK,EAAE;QAAEC,EAAE;MACb,OAAO,IAAI,CAACC,eAAe,CAACF,EAAE,EAAEC,EAAE,EAAEtB,GAAG,CAAC;IAC1C;IAEA;;;;;;EAAA;IAAA;IAAA,OAMA,mBAAUF,GAAqB,EAAEE,GAAe;MAC9C,IAAMG,QAAQ,GAAG,IAAI,CAACX,KAAK,CAACU,GAAG,CAACJ,GAAG,CAAC;MACpC,mBAAM,EAACK,QAAQ,IAAI,IAAI,EAAE,+CAA+C,CAAC;MAEzE,IAAMC,IAAI,GAAG,0BAAe,EAACD,QAAQ,CAACC,IAAI,CAAC,GACvCD,QAAQ,CAACC,IAAI,GACbD,QAAQ,CAACC,IAAI,CAACG,gBAAgB,CAACP,GAAG,CAAC;MAEvC,IAAMY,KAAK,GAAG,0BAAe,EAACR,IAAI,EAAEJ,GAAG,CAAC;MACxC,IAAI,CAACa,UAAU,CAAC;QAAEC,MAAM,EAAE;UAAET,MAAM,EAAEF,QAAQ,CAACE,MAAM;UAAEO,KAAK,EAALA;QAAK;MAAE,CAAE,CAAC;MAC/D,OAAO,IAAI;IACb;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOA,kBAASY,IAAa;MACpBA,IAAI,GAAGA,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI,IAAI,CAAC/B,WAAW;MAC/B,mBAAM,EACJ+B,IAAI,IAAI,IAAI,EACZ,oEAAoE,CACrE;MACD,OAAO,IAAI,CAACX,UAAU,CAAC;QAAEY,QAAQ,EAAED;MAAI,CAAE,CAAC;IAC5C;IAEA;;;;;EAAA;IAAA;IAAA,OAKA,aAAIE,UAAsB;MACxB,OAAOA,UAAU,CAACC,kBAAkB,CAAC,IAAI,CAACpC,SAAS,EAAE,IAAI,CAACI,MAAM,CAAC;IACnE;IAEA;;;;;;;;;;;EAAA;IAAA;IAAA,OAWA,wBACEJ,SAAoB,EACpBqC,UAAsC;MAEtC,IAAMC,GAAG,GAAG,IAAIC,GAAG,EAMhB;MAEH,IAAIzB,MAAM,GAAG,CAAC;MACd,IAAI0B,mBAAmB,GAAG,KAAK;MAAA,4CACVH,UAAU;QAAA;MAAA;QAA/B,uDAAiC;UAAA;YAArBnB,CAAC;YAAEC,CAAC;UACdmB,GAAG,CAACG,GAAG,CAACvB,CAAC,EAAE;YAAEL,IAAI,EAAEM,CAAqB;YAAEL,MAAM,EAANA;UAAM,CAAE,CAAC;UACnD,IAAI,CAAC,0BAAe,EAACK,CAAC,CAAC,EAAE;YACvBqB,mBAAmB,GAAG,IAAI;YAC1B;;UAEF1B,MAAM,IAAIK,CAAC,CAACC,QAAQ;;MACrB;QAAA;MAAA;QAAA;MAAA;MACD,IAAMlB,WAAW,GAAGsC,mBAAmB,GAAGE,SAAS,GAAG5B,MAAM;MAC5D,OAAO,IAAIf,UAAU,CAAIC,SAAS,EAAEsC,GAAG,EAAEpC,WAAW,CAAC;IACvD;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOA,oBACEF,SAAoB,EACpB2C,MAA8C;MAE9C,OAAO5C,UAAU,CAAC6C,cAAc,CAAC5C,SAAS,EAAE2C,MAAM,CAAC1B,MAAM,CAAC;IAC5D;EAAC;EAAA;AAAA;AApMH4B","names":["GpaBuilder","programId","beets","accountSize","filter","config","filters","push","key","innerKey","val","outerBeetInfo","get","beetInfo","beet","offset","outerBeet","toFixedFromValue","fields","k","v","byteSize","bytes","_addFilter","memcmp","keys","parts","split","assert_1","equal","length","ka","kb","_addInnerFilter","size","dataSize","connection","getProgramAccounts","beetFields","map","Map","encounteredNonFixed","set","undefined","struct","fromBeetFields","exports"],"sources":["../../../../src/gpa/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}