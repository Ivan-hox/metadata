{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError } from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport function getOrCreateAssociatedTokenAccount(_x, _x2, _x3, _x4) {\n  return _getOrCreateAssociatedTokenAccount.apply(this, arguments);\n}\nfunction _getOrCreateAssociatedTokenAccount() {\n  _getOrCreateAssociatedTokenAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, payer, mint, owner) {\n    var allowOwnerOffCurve,\n      commitment,\n      confirmOptions,\n      programId,\n      associatedTokenProgramId,\n      associatedToken,\n      account,\n      transaction,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            allowOwnerOffCurve = _args.length > 4 && _args[4] !== undefined ? _args[4] : false;\n            commitment = _args.length > 5 ? _args[5] : undefined;\n            confirmOptions = _args.length > 6 ? _args[6] : undefined;\n            programId = _args.length > 7 && _args[7] !== undefined ? _args[7] : TOKEN_PROGRAM_ID;\n            associatedTokenProgramId = _args.length > 8 && _args[8] !== undefined ? _args[8] : ASSOCIATED_TOKEN_PROGRAM_ID;\n            _context.next = 7;\n            return getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);\n          case 7:\n            associatedToken = _context.sent;\n            _context.prev = 8;\n            _context.next = 11;\n            return getAccount(connection, associatedToken, commitment, programId);\n          case 11:\n            account = _context.sent;\n            _context.next = 31;\n            break;\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](8);\n            if (!(_context.t0 instanceof TokenAccountNotFoundError || _context.t0 instanceof TokenInvalidAccountOwnerError)) {\n              _context.next = 30;\n              break;\n            }\n            _context.prev = 17;\n            transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n            _context.next = 21;\n            return sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n          case 21:\n            _context.next = 25;\n            break;\n          case 23:\n            _context.prev = 23;\n            _context.t1 = _context[\"catch\"](17);\n          case 25:\n            _context.next = 27;\n            return getAccount(connection, associatedToken, commitment, programId);\n          case 27:\n            account = _context.sent;\n            _context.next = 31;\n            break;\n          case 30:\n            throw _context.t0;\n          case 31:\n            if (account.mint.equals(mint)) {\n              _context.next = 33;\n              break;\n            }\n            throw new TokenInvalidMintError();\n          case 33:\n            if (account.owner.equals(owner)) {\n              _context.next = 35;\n              break;\n            }\n            throw new TokenInvalidOwnerError();\n          case 35:\n            return _context.abrupt(\"return\", account);\n          case 36:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[8, 14], [17, 23]]);\n  }));\n  return _getOrCreateAssociatedTokenAccount.apply(this, arguments);\n}","map":{"version":3,"mappings":";;AACA,SAASA,yBAAyB,EAAEC,WAAW,QAAQ,iBAAiB;AACxE,SAASC,2BAA2B,EAAEC,gBAAgB,QAAQ,iBAAiB;AAC/E,SACIC,yBAAyB,EACzBC,6BAA6B,EAC7BC,qBAAqB,EACrBC,sBAAsB,QACnB,cAAc;AACrB,SAASC,uCAAuC,QAAQ,2CAA2C;AAEnG,SAASC,UAAU,QAAQ,qBAAqB;AAChD,SAASC,yBAAyB,QAAQ,kBAAkB;AAE5D;;;;;;;;;;;;;;;AAeA,gBAAsBC,iCAAiC;EAAA;AAAA;AA2DtD;EAAA,gGA3DM,iBACHC,UAAsB,EACtBC,KAAa,EACbC,IAAe,EACfC,KAAgB;IAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YAChBC,kBAAkB,2DAAG,KAAK;YAC1BC,UAAuB;YACvBC,cAA+B;YAC/BC,SAAS,2DAAGhB,gBAAgB;YAC5BiB,wBAAwB,2DAAGlB,2BAA2B;YAAA;YAAA,OAExBQ,yBAAyB,CACnDI,IAAI,EACJC,KAAK,EACLC,kBAAkB,EAClBG,SAAS,EACTC,wBAAwB,CAC3B;UAAA;YANKC,eAAe;YAAA;YAAA;YAAA,OAYDZ,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;UAAA;YAA9EG,OAAO;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA,MAKH,uBAAiBlB,yBAAyB,IAAI,uBAAiBC,6BAA6B;cAAA;cAAA;YAAA;YAAA;YAGlFkB,WAAW,GAAG,IAAItB,WAAW,EAAE,CAACuB,GAAG,CACrChB,uCAAuC,CACnCK,KAAK,CAACY,SAAS,EACfJ,eAAe,EACfN,KAAK,EACLD,IAAI,EACJK,SAAS,EACTC,wBAAwB,CAC3B,CACJ;YAAA;YAAA,OAEKpB,yBAAyB,CAACY,UAAU,EAAEW,WAAW,EAAE,CAACV,KAAK,CAAC,EAAEK,cAAc,CAAC;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA,OAOrET,UAAU,CAACG,UAAU,EAAES,eAAe,EAAEJ,UAAU,EAAEE,SAAS,CAAC;UAAA;YAA9EG,OAAO;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA,IAMVA,OAAO,CAACR,IAAI,CAACY,MAAM,CAACZ,IAAI,CAAC;cAAA;cAAA;YAAA;YAAA,MAAQ,IAAIR,qBAAqB,EAAE;UAAA;YAAA,IAC5DgB,OAAO,CAACP,KAAK,CAACW,MAAM,CAACX,KAAK,CAAC;cAAA;cAAA;YAAA;YAAA,MAAQ,IAAIR,sBAAsB,EAAE;UAAA;YAAA,iCAE7De,OAAO;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACjB;EAAA;AAAA","names":["sendAndConfirmTransaction","Transaction","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","createAssociatedTokenAccountInstruction","getAccount","getAssociatedTokenAddress","getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","associatedTokenProgramId","associatedToken","account","transaction","add","publicKey","equals"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import type { Commitment, ConfirmOptions, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors.js';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/associatedTokenAccount.js';\nimport type { Account } from '../state/account.js';\nimport { getAccount } from '../state/account.js';\nimport { getAssociatedTokenAddress } from '../state/mint.js';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}