{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BaseMessageSignerWalletAdapter, scopePollingDetectionStrategy, WalletAccountError, WalletAdapterNetwork, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletLoadError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport var BaseSolletWalletAdapter = /*#__PURE__*/function (_BaseMessageSignerWal) {\n  _inherits(BaseSolletWalletAdapter, _BaseMessageSignerWal);\n  var _super = _createSuper(BaseSolletWalletAdapter);\n  function BaseSolletWalletAdapter() {\n    var _this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      provider = _ref.provider,\n      _ref$network = _ref.network,\n      network = _ref$network === void 0 ? WalletAdapterNetwork.Mainnet : _ref$network,\n      _ref$timeout = _ref.timeout,\n      timeout = _ref$timeout === void 0 ? 10000 : _ref$timeout;\n    _classCallCheck(this, BaseSolletWalletAdapter);\n    _this = _super.call(this);\n    _this.supportedTransactionVersions = null;\n    _this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n    _this._disconnected = function () {\n      var wallet = _this._wallet;\n      if (wallet) {\n        wallet.off('disconnect', _this._disconnected);\n        _this._wallet = null;\n        _this._publicKey = null;\n        _this.emit('error', new WalletDisconnectedError());\n        _this.emit('disconnect');\n      }\n    };\n    _this._provider = provider;\n    _this._network = network;\n    _this._timeout = timeout;\n    _this._connecting = false;\n    _this._wallet = null;\n    _this._publicKey = null;\n    if (_this._readyState !== WalletReadyState.Unsupported) {\n      if (typeof _this._provider === 'string') {\n        _this._readyState = WalletReadyState.Loadable;\n      } else {\n        scopePollingDetectionStrategy(function () {\n          var _window$sollet;\n          if (typeof ((_window$sollet = window.sollet) === null || _window$sollet === void 0 ? void 0 : _window$sollet.postMessage) === 'function') {\n            _this._readyState = WalletReadyState.Installed;\n            _this.emit('readyStateChange', _this._readyState);\n            return true;\n          }\n          return false;\n        });\n      }\n    }\n    return _this;\n  }\n  _createClass(BaseSolletWalletAdapter, [{\n    key: \"publicKey\",\n    get: function get() {\n      return this._publicKey;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this._connecting;\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      var _this$_wallet;\n      return !!((_this$_wallet = this._wallet) !== null && _this$_wallet !== void 0 && _this$_wallet.connected);\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n        var provider, SolWalletAdapterClass, wallet, handleDisconnect, timeout, interval, publicKey;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                if (!(this.connected || this.connecting)) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                if (!(this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)) {\n                  _context.next = 5;\n                  break;\n                }\n                throw new WalletNotReadyError();\n              case 5:\n                this._connecting = true;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                provider = this._provider || window.sollet;\n                _context.prev = 7;\n                _context.next = 10;\n                return import('@project-serum/sol-wallet-adapter');\n              case 10:\n                SolWalletAdapterClass = _context.sent.default;\n                _context.next = 16;\n                break;\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](7);\n                throw new WalletLoadError(_context.t0 === null || _context.t0 === void 0 ? void 0 : _context.t0.message, _context.t0);\n              case 16:\n                _context.prev = 16;\n                wallet = new SolWalletAdapterClass(provider, this._network);\n                _context.next = 23;\n                break;\n              case 20:\n                _context.prev = 20;\n                _context.t1 = _context[\"catch\"](16);\n                throw new WalletConfigError(_context.t1 === null || _context.t1 === void 0 ? void 0 : _context.t1.message, _context.t1);\n              case 23:\n                _context.prev = 23;\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                handleDisconnect = wallet.handleDisconnect;\n                _context.prev = 25;\n                _context.next = 28;\n                return new Promise(function (resolve, reject) {\n                  var connect = function connect() {\n                    if (timeout) clearTimeout(timeout);\n                    wallet.off('connect', connect);\n                    resolve();\n                  };\n                  wallet.handleDisconnect = function () {\n                    wallet.off('connect', connect);\n                    reject(new WalletWindowClosedError());\n                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                      args[_key] = arguments[_key];\n                    }\n                    return handleDisconnect.apply(wallet, args);\n                  };\n                  wallet.on('connect', connect);\n                  wallet.connect().catch(function (reason) {\n                    wallet.off('connect', connect);\n                    reject(reason);\n                  });\n                  if (typeof provider === 'string') {\n                    var count = 0;\n                    interval = setInterval(function () {\n                      var popup = wallet._popup;\n                      if (popup) {\n                        if (popup.closed) reject(new WalletWindowClosedError());\n                      } else {\n                        if (count > 50) reject(new WalletWindowBlockedError());\n                      }\n                      count++;\n                    }, 100);\n                  } else {\n                    // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                    timeout = setTimeout(function () {\n                      return reject(new WalletTimeoutError());\n                    }, _this2._timeout);\n                  }\n                });\n              case 28:\n                _context.prev = 28;\n                wallet.handleDisconnect = handleDisconnect;\n                if (interval) clearInterval(interval);\n                return _context.finish(28);\n              case 32:\n                _context.next = 39;\n                break;\n              case 34:\n                _context.prev = 34;\n                _context.t2 = _context[\"catch\"](23);\n                if (!(_context.t2 instanceof WalletError)) {\n                  _context.next = 38;\n                  break;\n                }\n                throw _context.t2;\n              case 38:\n                throw new WalletConnectionError(_context.t2 === null || _context.t2 === void 0 ? void 0 : _context.t2.message, _context.t2);\n              case 39:\n                if (wallet.publicKey) {\n                  _context.next = 41;\n                  break;\n                }\n                throw new WalletAccountError();\n              case 41:\n                _context.prev = 41;\n                publicKey = new PublicKey(wallet.publicKey.toBytes());\n                _context.next = 48;\n                break;\n              case 45:\n                _context.prev = 45;\n                _context.t3 = _context[\"catch\"](41);\n                throw new WalletPublicKeyError(_context.t3 === null || _context.t3 === void 0 ? void 0 : _context.t3.message, _context.t3);\n              case 48:\n                wallet.on('disconnect', this._disconnected);\n                this._wallet = wallet;\n                this._publicKey = publicKey;\n                this.emit('connect', publicKey);\n                _context.next = 58;\n                break;\n              case 54:\n                _context.prev = 54;\n                _context.t4 = _context[\"catch\"](0);\n                this.emit('error', _context.t4);\n                throw _context.t4;\n              case 58:\n                _context.prev = 58;\n                this._connecting = false;\n                return _context.finish(58);\n              case 61:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 54, 58, 61], [7, 13], [16, 20], [23, 34], [25,, 28, 32], [41, 45]]);\n      }));\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var wallet, handleDisconnect;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                wallet = this._wallet;\n                if (!wallet) {\n                  _context2.next = 17;\n                  break;\n                }\n                wallet.off('disconnect', this._disconnected);\n                this._wallet = null;\n                this._publicKey = null;\n                // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n                handleDisconnect = wallet.handleDisconnect;\n                _context2.prev = 6;\n                _context2.next = 9;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    return resolve();\n                  }, 250);\n                  wallet.handleDisconnect = function () {\n                    clearTimeout(timeout);\n                    resolve();\n                    // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                    wallet._responsePromises = new Map();\n                    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                      args[_key2] = arguments[_key2];\n                    }\n                    return handleDisconnect.apply(wallet, args);\n                  };\n                  wallet.disconnect().then(function () {\n                    clearTimeout(timeout);\n                    resolve();\n                  }, function (error) {\n                    clearTimeout(timeout);\n                    // HACK: sol-wallet-adapter rejects with an error on disconnect\n                    if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n                      resolve();\n                    } else {\n                      reject(error);\n                    }\n                  });\n                });\n              case 9:\n                _context2.next = 14;\n                break;\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](6);\n                this.emit('error', new WalletDisconnectionError(_context2.t0 === null || _context2.t0 === void 0 ? void 0 : _context2.t0.message, _context2.t0));\n              case 14:\n                _context2.prev = 14;\n                wallet.handleDisconnect = handleDisconnect;\n                return _context2.finish(14);\n              case 17:\n                this.emit('disconnect');\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[6, 11, 14, 17]]);\n      }));\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n      return disconnect;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(transaction) {\n        var wallet;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                wallet = this._wallet;\n                if (wallet) {\n                  _context3.next = 4;\n                  break;\n                }\n                throw new WalletNotConnectedError();\n              case 4:\n                _context3.prev = 4;\n                _context3.next = 7;\n                return wallet.signTransaction(transaction);\n              case 7:\n                _context3.t0 = _context3.sent;\n                if (_context3.t0) {\n                  _context3.next = 10;\n                  break;\n                }\n                _context3.t0 = transaction;\n              case 10:\n                return _context3.abrupt(\"return\", _context3.t0);\n              case 13:\n                _context3.prev = 13;\n                _context3.t1 = _context3[\"catch\"](4);\n                throw new WalletSignTransactionError(_context3.t1 === null || _context3.t1 === void 0 ? void 0 : _context3.t1.message, _context3.t1);\n              case 16:\n                _context3.next = 22;\n                break;\n              case 18:\n                _context3.prev = 18;\n                _context3.t2 = _context3[\"catch\"](0);\n                this.emit('error', _context3.t2);\n                throw _context3.t2;\n              case 22:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 18], [4, 13]]);\n      }));\n      function signTransaction(_x) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signAllTransactions\",\n    value: function () {\n      var _signAllTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transactions) {\n        var wallet;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                wallet = this._wallet;\n                if (wallet) {\n                  _context4.next = 4;\n                  break;\n                }\n                throw new WalletNotConnectedError();\n              case 4:\n                _context4.prev = 4;\n                _context4.next = 7;\n                return wallet.signAllTransactions(transactions);\n              case 7:\n                _context4.t0 = _context4.sent;\n                if (_context4.t0) {\n                  _context4.next = 10;\n                  break;\n                }\n                _context4.t0 = transactions;\n              case 10:\n                return _context4.abrupt(\"return\", _context4.t0);\n              case 13:\n                _context4.prev = 13;\n                _context4.t1 = _context4[\"catch\"](4);\n                throw new WalletSignTransactionError(_context4.t1 === null || _context4.t1 === void 0 ? void 0 : _context4.t1.message, _context4.t1);\n              case 16:\n                _context4.next = 22;\n                break;\n              case 18:\n                _context4.prev = 18;\n                _context4.t2 = _context4[\"catch\"](0);\n                this.emit('error', _context4.t2);\n                throw _context4.t2;\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 18], [4, 13]]);\n      }));\n      function signAllTransactions(_x2) {\n        return _signAllTransactions.apply(this, arguments);\n      }\n      return signAllTransactions;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(message) {\n        var wallet, _yield$wallet$sign, signature;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                wallet = this._wallet;\n                if (wallet) {\n                  _context5.next = 4;\n                  break;\n                }\n                throw new WalletNotConnectedError();\n              case 4:\n                _context5.prev = 4;\n                _context5.next = 7;\n                return wallet.sign(message, 'utf8');\n              case 7:\n                _yield$wallet$sign = _context5.sent;\n                signature = _yield$wallet$sign.signature;\n                return _context5.abrupt(\"return\", Uint8Array.from(signature));\n              case 12:\n                _context5.prev = 12;\n                _context5.t0 = _context5[\"catch\"](4);\n                throw new WalletSignMessageError(_context5.t0 === null || _context5.t0 === void 0 ? void 0 : _context5.t0.message, _context5.t0);\n              case 15:\n                _context5.next = 21;\n                break;\n              case 17:\n                _context5.prev = 17;\n                _context5.t1 = _context5[\"catch\"](0);\n                this.emit('error', _context5.t1);\n                throw _context5.t1;\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 17], [4, 12]]);\n      }));\n      function signMessage(_x3) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }()\n  }]);\n  return BaseSolletWalletAdapter;\n}(BaseMessageSignerWalletAdapter);","map":{"version":3,"mappings":"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","names":["BaseMessageSignerWalletAdapter","scopePollingDetectionStrategy","WalletAccountError","WalletAdapterNetwork","WalletConfigError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletError","WalletLoadError","WalletNotConnectedError","WalletNotReadyError","WalletPublicKeyError","WalletReadyState","WalletSignMessageError","WalletSignTransactionError","WalletTimeoutError","WalletWindowBlockedError","WalletWindowClosedError","PublicKey","BaseSolletWalletAdapter","provider","network","Mainnet","timeout","window","document","Unsupported","NotDetected","wallet","_wallet","off","_disconnected","_publicKey","emit","_provider","_network","_timeout","_connecting","_readyState","Loadable","sollet","postMessage","Installed","connected","connecting","SolWalletAdapterClass","default","message","handleDisconnect","Promise","resolve","reject","connect","clearTimeout","args","apply","on","catch","reason","count","interval","setInterval","popup","_popup","closed","setTimeout","clearInterval","publicKey","toBytes","_responsePromises","Map","disconnect","then","error","transaction","signTransaction","transactions","signAllTransactions","sign","signature","Uint8Array","from"],"sources":["/Users/ivan/Metadata/node_modules/@solana/wallet-adapter-sollet/src/base.ts"],"sourcesContent":["import type { default as SolWalletAdapter } from '@project-serum/sol-wallet-adapter';\nimport {\n    BaseMessageSignerWalletAdapter,\n    scopePollingDetectionStrategy,\n    WalletAccountError,\n    WalletAdapterNetwork,\n    WalletConfigError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    WalletLoadError,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSignMessageError,\n    WalletSignTransactionError,\n    WalletTimeoutError,\n    WalletWindowBlockedError,\n    WalletWindowClosedError,\n} from '@solana/wallet-adapter-base';\nimport type { Transaction } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\n\ninterface SolletWallet {\n    postMessage?(...args: unknown[]): unknown;\n}\n\ninterface SolletWindow extends Window {\n    sollet?: SolletWallet;\n}\n\ndeclare const window: SolletWindow;\n\nexport interface SolletWalletAdapterConfig {\n    provider?: string | SolletWallet;\n    network?: WalletAdapterNetwork;\n    timeout?: number;\n}\n\nexport abstract class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n    readonly supportedTransactionVersions = null;\n\n    protected _provider: string | SolletWallet | undefined;\n    protected _network: WalletAdapterNetwork;\n    protected _timeout: number;\n    protected _connecting: boolean;\n    protected _wallet: SolWalletAdapter | null;\n    protected _publicKey: PublicKey | null;\n    protected _readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n\n    constructor({ provider, network = WalletAdapterNetwork.Mainnet, timeout = 10000 }: SolletWalletAdapterConfig = {}) {\n        super();\n\n        this._provider = provider;\n        this._network = network;\n        this._timeout = timeout;\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n\n        if (this._readyState !== WalletReadyState.Unsupported) {\n            if (typeof this._provider === 'string') {\n                this._readyState = WalletReadyState.Loadable;\n            } else {\n                scopePollingDetectionStrategy(() => {\n                    if (typeof window.sollet?.postMessage === 'function') {\n                        this._readyState = WalletReadyState.Installed;\n                        this.emit('readyStateChange', this._readyState);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n        }\n    }\n\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    get connecting() {\n        return this._connecting;\n    }\n\n    get connected() {\n        return !!this._wallet?.connected;\n    }\n\n    get readyState() {\n        return this._readyState;\n    }\n\n    async connect(): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)\n                throw new WalletNotReadyError();\n\n            this._connecting = true;\n\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const provider = this._provider || window.sollet!;\n\n            let SolWalletAdapterClass: typeof SolWalletAdapter;\n            try {\n                SolWalletAdapterClass = (await import('@project-serum/sol-wallet-adapter')).default;\n            } catch (error: any) {\n                throw new WalletLoadError(error?.message, error);\n            }\n\n            let wallet: SolWalletAdapter;\n            try {\n                wallet = new SolWalletAdapterClass(provider, this._network);\n            } catch (error: any) {\n                throw new WalletConfigError(error?.message, error);\n            }\n\n            try {\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n                let timeout: NodeJS.Timer | undefined;\n                let interval: NodeJS.Timer | undefined;\n                try {\n                    await new Promise<void>((resolve, reject) => {\n                        const connect = () => {\n                            if (timeout) clearTimeout(timeout);\n                            wallet.off('connect', connect);\n                            resolve();\n                        };\n\n                        (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                            wallet.off('connect', connect);\n                            reject(new WalletWindowClosedError());\n                            return handleDisconnect.apply(wallet, args);\n                        };\n\n                        wallet.on('connect', connect);\n\n                        wallet.connect().catch((reason: any) => {\n                            wallet.off('connect', connect);\n                            reject(reason);\n                        });\n\n                        if (typeof provider === 'string') {\n                            let count = 0;\n\n                            interval = setInterval(() => {\n                                const popup = (wallet as any)._popup;\n                                if (popup) {\n                                    if (popup.closed) reject(new WalletWindowClosedError());\n                                } else {\n                                    if (count > 50) reject(new WalletWindowBlockedError());\n                                }\n\n                                count++;\n                            }, 100);\n                        } else {\n                            // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                            timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n                        }\n                    });\n                } finally {\n                    (wallet as any).handleDisconnect = handleDisconnect;\n                    if (interval) clearInterval(interval);\n                }\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletConnectionError(error?.message, error);\n            }\n\n            if (!wallet.publicKey) throw new WalletAccountError();\n\n            let publicKey: PublicKey;\n            try {\n                publicKey = new PublicKey(wallet.publicKey.toBytes());\n            } catch (error: any) {\n                throw new WalletPublicKeyError(error?.message, error);\n            }\n\n            wallet.on('disconnect', this._disconnected);\n\n            this._wallet = wallet;\n            this._publicKey = publicKey;\n\n            this.emit('connect', publicKey);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this._connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n            const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n            try {\n                await new Promise<void>((resolve, reject) => {\n                    const timeout = setTimeout(() => resolve(), 250);\n\n                    (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                        clearTimeout(timeout);\n                        resolve();\n                        // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                        (wallet as any)._responsePromises = new Map();\n                        return handleDisconnect.apply(wallet, args);\n                    };\n\n                    wallet.disconnect().then(\n                        () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        },\n                        (error: any) => {\n                            clearTimeout(timeout);\n                            // HACK: sol-wallet-adapter rejects with an error on disconnect\n                            if (error?.message === 'Wallet disconnected') {\n                                resolve();\n                            } else {\n                                reject(error);\n                            }\n                        }\n                    );\n                });\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            } finally {\n                (wallet as any).handleDisconnect = handleDisconnect;\n            }\n        }\n\n        this.emit('disconnect');\n    }\n\n    async signTransaction<T extends Transaction>(transaction: T): Promise<T> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return ((await wallet.signTransaction(transaction)) as T) || transaction;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signAllTransactions<T extends Transaction>(transactions: T[]): Promise<T[]> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return ((await wallet.signAllTransactions(transactions)) as T[]) || transactions;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                const { signature } = await wallet.sign(message, 'utf8');\n                return Uint8Array.from(signature);\n            } catch (error: any) {\n                throw new WalletSignMessageError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    private _disconnected = () => {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            this.emit('error', new WalletDisconnectedError());\n            this.emit('disconnect');\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}