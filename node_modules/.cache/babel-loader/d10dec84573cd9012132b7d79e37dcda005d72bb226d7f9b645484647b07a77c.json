{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainEncoderPart = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar utils_1 = require(\"./utils\");\nvar fountainUtils_1 = require(\"./fountainUtils\");\nvar cbor_1 = require(\"./cbor\");\nvar FountainEncoderPart = /*#__PURE__*/function () {\n  function FountainEncoderPart(_seqNum, _seqLength, _messageLength, _checksum, _fragment) {\n    _classCallCheck(this, FountainEncoderPart);\n    this._seqNum = _seqNum;\n    this._seqLength = _seqLength;\n    this._messageLength = _messageLength;\n    this._checksum = _checksum;\n    this._fragment = _fragment;\n  }\n  _createClass(FountainEncoderPart, [{\n    key: \"messageLength\",\n    get: function get() {\n      return this._messageLength;\n    }\n  }, {\n    key: \"fragment\",\n    get: function get() {\n      return this._fragment;\n    }\n  }, {\n    key: \"seqNum\",\n    get: function get() {\n      return this._seqNum;\n    }\n  }, {\n    key: \"seqLength\",\n    get: function get() {\n      return this._seqLength;\n    }\n  }, {\n    key: \"checksum\",\n    get: function get() {\n      return this._checksum;\n    }\n  }, {\n    key: \"cbor\",\n    value: function cbor() {\n      var result = cbor_1.cborEncode([this._seqNum, this._seqLength, this._messageLength, this._checksum, this._fragment]);\n      return Buffer.from(result);\n    }\n  }, {\n    key: \"description\",\n    value: function description() {\n      return \"seqNum:\".concat(this._seqNum, \", seqLen:\").concat(this._seqLength, \", messageLen:\").concat(this._messageLength, \", checksum:\").concat(this._checksum, \", data:\").concat(this._fragment.toString('hex'));\n    }\n  }], [{\n    key: \"fromCBOR\",\n    value: function fromCBOR(cborPayload) {\n      var _cbor_1$cborDecode = cbor_1.cborDecode(cborPayload),\n        _cbor_1$cborDecode2 = _slicedToArray(_cbor_1$cborDecode, 5),\n        seqNum = _cbor_1$cborDecode2[0],\n        seqLength = _cbor_1$cborDecode2[1],\n        messageLength = _cbor_1$cborDecode2[2],\n        checksum = _cbor_1$cborDecode2[3],\n        fragment = _cbor_1$cborDecode2[4];\n      assert_1.default(typeof seqNum === 'number');\n      assert_1.default(typeof seqLength === 'number');\n      assert_1.default(typeof messageLength === 'number');\n      assert_1.default(typeof checksum === 'number');\n      assert_1.default(Buffer.isBuffer(fragment) && fragment.length > 0);\n      return new FountainEncoderPart(seqNum, seqLength, messageLength, checksum, Buffer.from(fragment));\n    }\n  }]);\n  return FountainEncoderPart;\n}();\nexports.FountainEncoderPart = FountainEncoderPart;\nvar FountainEncoder = /*#__PURE__*/function () {\n  function FountainEncoder(message) {\n    var maxFragmentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var firstSeqNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var minFragmentLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n    _classCallCheck(this, FountainEncoder);\n    var fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = utils_1.toUint32(firstSeqNum);\n    this.checksum = utils_1.getCRC(message);\n  }\n  _createClass(FountainEncoder, [{\n    key: \"fragmentsLength\",\n    get: function get() {\n      return this._fragments.length;\n    }\n  }, {\n    key: \"fragments\",\n    get: function get() {\n      return this._fragments;\n    }\n  }, {\n    key: \"messageLength\",\n    get: function get() {\n      return this._messageLength;\n    }\n  }, {\n    key: \"isComplete\",\n    value: function isComplete() {\n      return this.seqNum >= this._fragments.length;\n    }\n  }, {\n    key: \"isSinglePart\",\n    value: function isSinglePart() {\n      return this._fragments.length === 1;\n    }\n  }, {\n    key: \"seqLength\",\n    value: function seqLength() {\n      return this._fragments.length;\n    }\n  }, {\n    key: \"mix\",\n    value: function mix(indexes) {\n      var _this = this;\n      return indexes.reduce(function (result, index) {\n        return utils_1.bufferXOR(_this._fragments[index], result);\n      }, Buffer.alloc(this.fragmentLength, 0));\n    }\n  }, {\n    key: \"nextPart\",\n    value: function nextPart() {\n      this.seqNum = utils_1.toUint32(this.seqNum + 1);\n      var indexes = fountainUtils_1.chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n      var mixed = this.mix(indexes);\n      return new FountainEncoderPart(this.seqNum, this._fragments.length, this._messageLength, this.checksum, mixed);\n    }\n  }], [{\n    key: \"findNominalFragmentLength\",\n    value: function findNominalFragmentLength(messageLength, minFragmentLength, maxFragmentLength) {\n      assert_1.default(messageLength > 0);\n      assert_1.default(minFragmentLength > 0);\n      assert_1.default(maxFragmentLength >= minFragmentLength);\n      var maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n      var fragmentLength = 0;\n      for (var fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n        fragmentLength = Math.ceil(messageLength / fragmentCount);\n        if (fragmentLength <= maxFragmentLength) {\n          break;\n        }\n      }\n      return fragmentLength;\n    }\n  }, {\n    key: \"partitionMessage\",\n    value: function partitionMessage(message, fragmentLength) {\n      var remaining = Buffer.from(message);\n      var fragment;\n      var _fragments = [];\n      while (remaining.length > 0) {\n        var _utils_1$split = utils_1.split(remaining, -fragmentLength);\n        var _utils_1$split2 = _slicedToArray(_utils_1$split, 2);\n        fragment = _utils_1$split2[0];\n        remaining = _utils_1$split2[1];\n        fragment = Buffer.alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n        .fill(fragment, 0, fragment.length);\n        _fragments.push(fragment);\n      }\n      return _fragments;\n    }\n  }]);\n  return FountainEncoder;\n}();\nexports.default = FountainEncoder;","map":{"version":3,"mappings":"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","names":["FountainEncoderPart","_seqNum","_seqLength","_messageLength","_checksum","_fragment","result","cbor_1","Buffer","from","toString","cborPayload","seqNum","seqLength","messageLength","checksum","fragment","assert_1","isBuffer","length","exports","FountainEncoder","message","maxFragmentLength","firstSeqNum","minFragmentLength","fragmentLength","findNominalFragmentLength","_fragments","partitionMessage","utils_1","indexes","reduce","index","alloc","fountainUtils_1","mixed","mix","maxFragmentCount","Math","ceil","fragmentCount","remaining","fill","push"],"sources":["/Users/ivan/Metadata/node_modules/@ngraveio/bc-ur/src/fountainEncoder.ts"],"sourcesContent":["import assert from \"assert\";\nimport { bufferXOR, getCRC, split, toUint32 } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { cborEncode, cborDecode } from './cbor';\n\nexport class FountainEncoderPart {\n  constructor(\n    private _seqNum: number,\n    private _seqLength: number,\n    private _messageLength: number,\n    private _checksum: number,\n    private _fragment: Buffer,\n  ) { }\n\n  get messageLength() { return this._messageLength; }\n  get fragment() { return this._fragment; }\n  get seqNum() { return this._seqNum; }\n  get seqLength() { return this._seqLength; }\n  get checksum() { return this._checksum; }\n\n  public cbor(): Buffer {\n    const result = cborEncode([\n      this._seqNum,\n      this._seqLength,\n      this._messageLength,\n      this._checksum,\n      this._fragment\n    ])\n\n    return Buffer.from(result);\n  }\n\n  public description(): string {\n    return `seqNum:${this._seqNum}, seqLen:${this._seqLength}, messageLen:${this._messageLength}, checksum:${this._checksum}, data:${this._fragment.toString('hex')}`\n  }\n\n  public static fromCBOR(cborPayload: string | Buffer) {\n    const [\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      fragment,\n    ] = cborDecode(cborPayload);\n\n    assert(typeof seqNum === 'number');\n    assert(typeof seqLength === 'number');\n    assert(typeof messageLength === 'number');\n    assert(typeof checksum === 'number');\n    assert(Buffer.isBuffer(fragment) && fragment.length > 0);\n\n    return new FountainEncoderPart(\n      seqNum,\n      seqLength,\n      messageLength,\n      checksum,\n      Buffer.from(fragment),\n    )\n  }\n}\n\nexport default class FountainEncoder {\n  private _messageLength: number;\n  private _fragments: Buffer[];\n  private fragmentLength: number;\n  private seqNum: number;\n  private checksum: number;\n\n  constructor(\n    message: Buffer,\n    maxFragmentLength: number = 100,\n    firstSeqNum: number = 0,\n    minFragmentLength: number = 10\n  ) {\n    const fragmentLength = FountainEncoder.findNominalFragmentLength(message.length, minFragmentLength, maxFragmentLength);\n\n    this._messageLength = message.length;\n    this._fragments = FountainEncoder.partitionMessage(message, fragmentLength);\n    this.fragmentLength = fragmentLength;\n    this.seqNum = toUint32(firstSeqNum);\n    this.checksum = getCRC(message)\n  }\n\n  public get fragmentsLength() { return this._fragments.length; }\n  public get fragments() { return this._fragments; }\n  public get messageLength() { return this._messageLength; }\n\n  public isComplete(): boolean {\n    return this.seqNum >= this._fragments.length;\n  }\n\n  public isSinglePart(): boolean {\n    return this._fragments.length === 1;\n  }\n\n  public seqLength(): number {\n    return this._fragments.length;\n  }\n\n  public mix(indexes: number[]) {\n    return indexes.reduce(\n      (result, index) => bufferXOR(this._fragments[index], result),\n      Buffer.alloc(this.fragmentLength, 0)\n    )\n  }\n\n  public nextPart(): FountainEncoderPart {\n    this.seqNum = toUint32(this.seqNum + 1);\n\n    const indexes = chooseFragments(this.seqNum, this._fragments.length, this.checksum);\n    const mixed = this.mix(indexes);\n\n    return new FountainEncoderPart(\n      this.seqNum,\n      this._fragments.length,\n      this._messageLength,\n      this.checksum,\n      mixed\n    )\n  }\n\n  public static findNominalFragmentLength(\n    messageLength: number,\n    minFragmentLength: number,\n    maxFragmentLength: number\n  ): number {\n    assert(messageLength > 0)\n    assert(minFragmentLength > 0)\n    assert(maxFragmentLength >= minFragmentLength)\n\n    const maxFragmentCount = Math.ceil(messageLength / minFragmentLength);\n    let fragmentLength = 0;\n\n    for (let fragmentCount = 1; fragmentCount <= maxFragmentCount; fragmentCount++) {\n      fragmentLength = Math.ceil(messageLength / fragmentCount);\n\n      if (fragmentLength <= maxFragmentLength) {\n        break;\n      }\n    }\n\n    return fragmentLength;\n  }\n\n  public static partitionMessage(message: Buffer, fragmentLength: number): Buffer[] {\n    let remaining = Buffer.from(message);\n    let fragment;\n    let _fragments: Buffer[] = [];\n\n    while (remaining.length > 0) {\n      [fragment, remaining] = split(remaining, -fragmentLength)\n      fragment = Buffer\n        .alloc(fragmentLength, 0) // initialize with 0's to achieve the padding\n        .fill(fragment, 0, fragment.length)\n      _fragments.push(fragment)\n    }\n\n    return _fragments;\n  }\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}