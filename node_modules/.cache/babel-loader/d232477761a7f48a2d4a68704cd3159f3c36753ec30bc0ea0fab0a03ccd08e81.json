{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoCoinInfo = exports.Network = exports.Type = void 0;\nvar lib_1 = require(\"./lib\");\nvar RegistryItem_1 = require(\"./RegistryItem\");\nvar RegistryType_1 = require(\"./RegistryType\");\nvar Keys;\n(function (Keys) {\n  Keys[\"type\"] = \"1\";\n  Keys[\"network\"] = \"2\";\n})(Keys || (Keys = {}));\nvar Type;\n(function (Type) {\n  Type[Type[\"bitcoin\"] = 0] = \"bitcoin\";\n})(Type = exports.Type || (exports.Type = {}));\nvar Network;\n(function (Network) {\n  Network[Network[\"mainnet\"] = 0] = \"mainnet\";\n  Network[Network[\"testnet\"] = 1] = \"testnet\";\n})(Network = exports.Network || (exports.Network = {}));\nvar CryptoCoinInfo = /*#__PURE__*/function (_RegistryItem_1$Regis) {\n  _inherits(CryptoCoinInfo, _RegistryItem_1$Regis);\n  var _super = _createSuper(CryptoCoinInfo);\n  function CryptoCoinInfo(type, network) {\n    var _this;\n    _classCallCheck(this, CryptoCoinInfo);\n    _this = _super.call(this);\n    _this.type = type;\n    _this.network = network;\n    _this.getRegistryType = function () {\n      return RegistryType_1.RegistryTypes.CRYPTO_COIN_INFO;\n    };\n    _this.getType = function () {\n      return _this.type || Type.bitcoin;\n    };\n    _this.getNetwork = function () {\n      return _this.network || Network.mainnet;\n    };\n    _this.toDataItem = function () {\n      var map = {};\n      if (_this.type) {\n        map[Keys.type] = _this.type;\n      }\n      if (_this.network) {\n        map[Keys.network] = _this.network;\n      }\n      return new lib_1.DataItem(map);\n    };\n    return _this;\n  }\n  return _createClass(CryptoCoinInfo);\n}(RegistryItem_1.RegistryItem);\nexports.CryptoCoinInfo = CryptoCoinInfo;\nCryptoCoinInfo.fromDataItem = function (dataItem) {\n  var map = dataItem.getData();\n  var type = map[Keys.type];\n  var network = map[Keys.network];\n  return new CryptoCoinInfo(type, network);\n};\nCryptoCoinInfo.fromCBOR = function (_cborPayload) {\n  var dataItem = (0, lib_1.decodeToDataItem)(_cborPayload);\n  return CryptoCoinInfo.fromDataItem(dataItem);\n};","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AACA;AAGA,IAAKA,IAGJ;AAHD,WAAKA,IAAI;EACPA,kBAAU;EACVA,qBAAa;AACf,CAAC,EAHIA,IAAI,KAAJA,IAAI;AAKT,IAAYC,IAEX;AAFD,WAAYA,IAAI;EACdA,qCAAW;AACb,CAAC,EAFWA,IAAI,GAAJC,YAAI,KAAJA,YAAI;AAIhB,IAAYC,OAGX;AAHD,WAAYA,OAAO;EACjBA,2CAAO;EACPA,2CAAO;AACT,CAAC,EAHWA,OAAO,GAAPD,eAAO,KAAPA,eAAO;AAGlB,IAEYE,cAAe;EAAA;EAAA;EAK1B,wBAAoBC,IAAW,EAAUC,OAAiB;IAAA;IAAA;IACxD;IADkB,UAAI,GAAJD,IAAI;IAAiB,aAAO,GAAPC,OAAO;IAJhD,qBAAe,GAAG,YAAK;MACrB,OAAOC,4BAAa,CAACC,gBAAgB;IACvC,CAAC;IAMM,aAAO,GAAG,YAAK;MACpB,OAAO,MAAKH,IAAI,IAAIJ,IAAI,CAACQ,OAAO;IAClC,CAAC;IAEM,gBAAU,GAAG,YAAK;MACvB,OAAO,MAAKH,OAAO,IAAIH,OAAO,CAACO,OAAO;IACxC,CAAC;IAEM,gBAAU,GAAG,YAAK;MACvB,IAAMC,GAAG,GAAgB,EAAE;MAC3B,IAAI,MAAKN,IAAI,EAAE;QACbM,GAAG,CAACX,IAAI,CAACK,IAAI,CAAC,GAAG,MAAKA,IAAI;;MAE5B,IAAI,MAAKC,OAAO,EAAE;QAChBK,GAAG,CAACX,IAAI,CAACM,OAAO,CAAC,GAAG,MAAKA,OAAO;;MAElC,OAAO,IAAIM,cAAQ,CAACD,GAAG,CAAC;IAC1B,CAAC;IAAC;EAnBF;EAAC;AAAA,EAPiCE,2BAAY;AAAhDX;AA4BgBE,2BAAY,GAAG,UAACU,QAAkB,EAAI;EAClD,IAAMH,GAAG,GAAGG,QAAQ,CAACC,OAAO,EAAE;EAC9B,IAAMV,IAAI,GAAGM,GAAG,CAACX,IAAI,CAACK,IAAI,CAAC;EAC3B,IAAMC,OAAO,GAAGK,GAAG,CAACX,IAAI,CAACM,OAAO,CAAC;EACjC,OAAO,IAAIF,cAAc,CAACC,IAAI,EAAEC,OAAO,CAAC;AAC1C,CAAC;AAEaF,uBAAQ,GAAG,UAACY,YAAoB,EAAI;EAChD,IAAMF,QAAQ,GAAG,0BAAgB,EAACE,YAAY,CAAC;EAC/C,OAAOZ,cAAc,CAACa,YAAY,CAACH,QAAQ,CAAC;AAC9C,CAAC","names":["Keys","Type","exports","Network","CryptoCoinInfo","type","network","RegistryType_1","CRYPTO_COIN_INFO","bitcoin","mainnet","map","lib_1","RegistryItem_1","dataItem","getData","_cborPayload","fromDataItem"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/bc-ur-registry/src/CryptoCoinInfo.ts"],"sourcesContent":["import { decodeToDataItem, DataItem } from './lib';\nimport { RegistryItem } from './RegistryItem';\nimport { RegistryTypes } from './RegistryType';\nimport { DataItemMap } from './types';\n\nenum Keys {\n  type = '1',\n  network = '2',\n}\n\nexport enum Type {\n  bitcoin = 0,\n}\n\nexport enum Network {\n  mainnet,\n  testnet,\n}\n\nexport class CryptoCoinInfo extends RegistryItem {\n  getRegistryType = () => {\n    return RegistryTypes.CRYPTO_COIN_INFO;\n  };\n\n  constructor(private type?: Type, private network?: Network) {\n    super();\n  }\n\n  public getType = () => {\n    return this.type || Type.bitcoin;\n  };\n\n  public getNetwork = () => {\n    return this.network || Network.mainnet;\n  };\n\n  public toDataItem = () => {\n    const map: DataItemMap = {};\n    if (this.type) {\n      map[Keys.type] = this.type;\n    }\n    if (this.network) {\n      map[Keys.network] = this.network;\n    }\n    return new DataItem(map);\n  };\n\n  public static fromDataItem = (dataItem: DataItem) => {\n    const map = dataItem.getData();\n    const type = map[Keys.type];\n    const network = map[Keys.network];\n    return new CryptoCoinInfo(type, network);\n  };\n\n  public static fromCBOR = (_cborPayload: Buffer) => {\n    const dataItem = decodeToDataItem(_cborPayload);\n    return CryptoCoinInfo.fromDataItem(dataItem);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}