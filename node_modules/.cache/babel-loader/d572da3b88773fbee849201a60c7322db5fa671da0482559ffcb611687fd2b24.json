{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Message, PublicKey, SIGNATURE_LENGTH_IN_BYTES, Transaction } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\nvar DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\nexport var StrikeWallet = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(StrikeWallet, _EventEmitter);\n  var _super = _createSuper(StrikeWallet);\n  function StrikeWallet() {\n    var _this;\n    _classCallCheck(this, StrikeWallet);\n    _this = _super.call(this);\n    _this.url = 'https://wallet.strikeprotocols.com';\n    _this.cleanUp = function () {\n      _toConsumableArray(_this._timers).forEach(function (t) {\n        return _this.clearTimer(t);\n      });\n      var wallet = _this._wallet;\n      if (wallet) {\n        wallet.close();\n      }\n      _this._wallet = null;\n      _this.emit('disconnected');\n    };\n    _this.clearTimer = function (timer) {\n      _this._timers = _this._timers.filter(function (t) {\n        return t != timer;\n      });\n      window.clearInterval(timer);\n    };\n    _this.instructionsToSerializableInstructions = function (instructions) {\n      return instructions.map(function (i) {\n        return {\n          'programId': i.programId.toBase58(),\n          'accountMetas': i.keys.map(function (k) {\n            return {\n              address: k.pubkey.toBase58(),\n              signer: k.isSigner,\n              writable: k.isWritable\n            };\n          }),\n          'data': window.btoa(String.fromCharCode.apply(String, _toConsumableArray(i.data)))\n        };\n      });\n    };\n    _this.handleWalletMessage = function (data) {\n      var _a, _b, _c;\n      if (data.type == \"connected\") {\n        _this._connecting = false;\n        if (!data.error) {\n          _this.isLoggedIn = true;\n          if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n            _this._publicKey = new PublicKey(data.connected.publicKey);\n          }\n        }\n      } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n        var transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n        if (transactionIdentifier && transactionIdentifier in _this._pendingTransactions) {\n          if (data.error) {\n            _this._pendingTransactionErrors[transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            _this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n          }\n        }\n      } else if (data.type == \"signTransaction\") {\n        var _transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n        if (_transactionIdentifier && _transactionIdentifier in _this._pendingTransactions) {\n          if (data.error) {\n            _this._pendingTransactionErrors[_transactionIdentifier] = {\n              message: data.error\n            };\n          } else {\n            _this._pendingTransactions[_transactionIdentifier] = data.signTransaction || null;\n          }\n        }\n      }\n    };\n    _this.isLoggedIn = false;\n    _this._pendingTransactions = {};\n    _this._pendingTransactionErrors = {};\n    _this._timers = [];\n    _this._wallet = null;\n    _this._connecting = false;\n    _this._publicKey = null;\n    window.addEventListener(\"message\", function (e) {\n      _this.handleWalletMessage(e.data);\n    });\n    return _this;\n  }\n  _createClass(StrikeWallet, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {\n        var _this2 = this;\n        var origin, connectUrl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                this.url = url || this.url;\n                origin = encodeURIComponent(window.location.origin);\n                connectUrl = \"\".concat(this.url, \"/connect?origin=\").concat(origin);\n                this._connecting = true;\n                this._wallet = window.open(connectUrl, \"strike-wallet-\".concat(origin), \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n                if (this._wallet) {\n                  _context.next = 9;\n                  break;\n                }\n                this._connecting = false;\n                throw new Error(\"Unable to connect to wallet\");\n              case 9:\n                this._timers.push(window.setInterval(function () {\n                  if (_this2._wallet.closed) {\n                    _this2.cleanUp();\n                  } else if (_this2._wallet) {\n                    _this2._wallet.postMessage({\n                      type: 'heartbeat'\n                    }, _this2.url);\n                  }\n                }, 100));\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var timer = window.setInterval(function () {\n                    if (_this2.isLoggedIn && _this2._publicKey) {\n                      _this2.clearTimer(timer);\n                      resolve(_this2._publicKey);\n                    } else if (!_this2.isLoggedIn && !_this2._connecting) {\n                      _this2.clearTimer(timer);\n                      reject(new Error(\"Unable to connect to Strike\"));\n                    }\n                  }, 100);\n                  _this2._timers.push(timer);\n                }));\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](0);\n                throw _context.t0;\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 13]]);\n      }));\n      function connect(_x) {\n        return _connect.apply(this, arguments);\n      }\n      return connect;\n    }()\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(transaction) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.verifyCanSignRequests([transaction]);\n                _context2.prev = 1;\n                return _context2.abrupt(\"return\", this.signOneTransaction(transaction));\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](1);\n                throw _context2.t0;\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 5]]);\n      }));\n      function signTransaction(_x2) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signAllTransactions\",\n    value: function () {\n      var _signAllTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(transactions) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.verifyCanSignRequests(transactions);\n                _context3.prev = 1;\n                return _context3.abrupt(\"return\", this.signMultipleTransactions(transactions));\n              case 5:\n                _context3.prev = 5;\n                _context3.t0 = _context3[\"catch\"](1);\n                throw _context3.t0;\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 5]]);\n      }));\n      function signAllTransactions(_x3) {\n        return _signAllTransactions.apply(this, arguments);\n      }\n      return signAllTransactions;\n    }()\n  }, {\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transaction, connection, options) {\n        var _this3 = this;\n        var wallet, transactionIdentifier, signers, instructions;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                wallet = this._wallet;\n                if (wallet) {\n                  _context4.next = 4;\n                  break;\n                }\n                throw new Error(\"Not Connected\");\n              case 4:\n                transactionIdentifier = uuidv4();\n                this._pendingTransactions[transactionIdentifier] = null;\n                signers = options ? options.signers : undefined;\n                if (!(signers && signers.length > 0)) {\n                  _context4.next = 11;\n                  break;\n                }\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this3.signOneTransaction(transaction, transactionIdentifier).then(function (walletTransaction) {\n                    _this3._pendingTransactions[transactionIdentifier] = null;\n                    (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign.apply(walletTransaction, _toConsumableArray(signers));\n                    wallet.postMessage({\n                      type: \"sendFinalTransaction\",\n                      sendFinalTransaction: {\n                        transactionIdentifier: transactionIdentifier,\n                        signaturePubkeyPairs: walletTransaction.signatures.filter(function (sp) {\n                          return sp.signature != null;\n                        }).map(function (sp) {\n                          return {\n                            'pubkey': sp.publicKey.toBase58(),\n                            'signature': sp.signature.toString('base64')\n                          };\n                        })\n                      }\n                    }, _this3.url);\n                    var timer = window.setInterval(function () {\n                      var pendingTransaction = _this3._pendingTransactions[transactionIdentifier];\n                      var pendingTransactionError = _this3._pendingTransactionErrors[transactionIdentifier];\n                      if (pendingTransaction != null || pendingTransactionError != null) {\n                        _this3.clearTimer(timer);\n                        pendingTransaction && resolve(pendingTransaction.signature);\n                        pendingTransactionError && reject(pendingTransactionError);\n                      }\n                    }, 100);\n                    _this3._timers.push(timer);\n                  }).catch(function (error) {\n                    reject(error);\n                    throw error;\n                  });\n                }));\n              case 11:\n                instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  wallet.postMessage({\n                    type: \"sendTransaction\",\n                    sendTransaction: {\n                      instructions: instructions,\n                      transactionIdentifier: transactionIdentifier\n                    }\n                  }, _this3.url);\n                  var timer = window.setInterval(function () {\n                    var pendingTransaction = _this3._pendingTransactions[transactionIdentifier];\n                    var pendingTransactionError = _this3._pendingTransactionErrors[transactionIdentifier];\n                    if (pendingTransaction != null || pendingTransactionError != null) {\n                      _this3.clearTimer(timer);\n                      pendingTransaction && resolve(pendingTransaction.signature);\n                      pendingTransactionError && reject(pendingTransactionError);\n                    }\n                  }, 100);\n                  _this3._timers.push(timer);\n                }));\n              case 13:\n                _context4.next = 18;\n                break;\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](0);\n                throw _context4.t0;\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 15]]);\n      }));\n      function sendTransaction(_x4, _x5, _x6) {\n        return _sendTransaction.apply(this, arguments);\n      }\n      return sendTransaction;\n    }()\n  }, {\n    key: \"buildTransaction\",\n    value: function buildTransaction(pendingTransaction) {\n      var message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), function (c) {\n        return c.charCodeAt(0);\n      })));\n      return Transaction.populate(message, Array.from({\n        length: message.header.numRequiredSignatures\n      }, function (_v, i) {\n        var sigPubkeyPair = pendingTransaction.signatures.find(function (s) {\n          return s.pubkey == message.accountKeys[i].toBase58();\n        });\n        return bs58.encode(sigPubkeyPair ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), function (c) {\n          return c.charCodeAt(0);\n        })) : DEFAULT_SIGNATURE_BUFFER);\n      }));\n    }\n  }, {\n    key: \"verifyCanSignRequests\",\n    value: function verifyCanSignRequests(transactions) {\n      transactions.forEach(function (transaction) {\n        if (transaction.signatures.some(function (s) {\n          return s.signature != null;\n        })) {\n          throw new Error(\"Strike does not support this signing mode\");\n        }\n      });\n    }\n  }, {\n    key: \"signOneTransaction\",\n    value: function signOneTransaction(transaction) {\n      var _this4 = this;\n      var transactionIdentifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : uuidv4();\n      var wallet = this._wallet;\n      if (!wallet) throw new Error(\"Not Connected\");\n      var instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n      this._pendingTransactions[transactionIdentifier] = null;\n      return new Promise(function (resolve, reject) {\n        wallet.postMessage({\n          type: \"signTransaction\",\n          signTransaction: {\n            instructions: instructions,\n            transactionIdentifier: transactionIdentifier\n          }\n        }, _this4.url);\n        var timer = window.setInterval(function () {\n          var pendingTransaction = _this4._pendingTransactions[transactionIdentifier];\n          var pendingTransactionError = _this4._pendingTransactionErrors[transactionIdentifier];\n          if (pendingTransaction != null || pendingTransactionError != null) {\n            _this4.clearTimer(timer);\n            pendingTransaction && resolve(_this4.buildTransaction(pendingTransaction));\n            pendingTransactionError && reject(pendingTransactionError);\n          }\n        }, 100);\n        _this4._timers.push(timer);\n      });\n    }\n  }, {\n    key: \"signMultipleTransactions\",\n    value: function signMultipleTransactions(transactions) {\n      var _this5 = this;\n      var wallet = this._wallet;\n      if (!wallet) throw new Error(\"Not Connected\");\n      var serializedTransactions = transactions.map(function (t) {\n        return {\n          instructions: _this5.instructionsToSerializableInstructions(t.instructions),\n          transactionIdentifier: uuidv4()\n        };\n      });\n      var transactionIdentifiers = serializedTransactions.map(function (t) {\n        return t.transactionIdentifier;\n      });\n      transactionIdentifiers.forEach(function (transactionIdentifier) {\n        return _this5._pendingTransactions[transactionIdentifier] = null;\n      });\n      return new Promise(function (resolve, reject) {\n        wallet.postMessage({\n          type: \"signAllTransactions\",\n          signAllTransactions: {\n            transactions: serializedTransactions\n          }\n        }, _this5.url);\n        var timer = window.setInterval(function () {\n          var pendingTransactions = transactionIdentifiers.map(function (txId) {\n            return _this5._pendingTransactions[txId];\n          });\n          var pendingTransactionErrors = transactionIdentifiers.map(function (txId) {\n            return _this5._pendingTransactionErrors[txId];\n          });\n          if (pendingTransactions.every(function (t) {\n            return t != null;\n          })) {\n            _this5.clearTimer(timer);\n            resolve(pendingTransactions.map(function (pt) {\n              return _this5.buildTransaction(pt);\n            }));\n          } else if (pendingTransactionErrors.some(function (e) {\n            return e != null;\n          })) {\n            _this5.clearTimer(timer);\n            reject(pendingTransactionErrors.find(function (e) {\n              return e != null;\n            }));\n          }\n        }, 100);\n        _this5._timers.push(timer);\n      });\n    }\n  }]);\n  return StrikeWallet;\n}(EventEmitter);","map":{"version":3,"mappings":"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","names":["Message","PublicKey","SIGNATURE_LENGTH_IN_BYTES","Transaction","bs58","v4","uuidv4","EventEmitter","DEFAULT_SIGNATURE_BUFFER","Buffer","alloc","fill","StrikeWallet","_timers","forEach","clearTimer","t","wallet","_wallet","close","emit","timer","filter","window","clearInterval","instructions","map","i","programId","toBase58","keys","address","k","pubkey","signer","isSigner","writable","isWritable","btoa","String","fromCharCode","data","type","_connecting","error","isLoggedIn","connected","publicKey","_publicKey","includes","transactionIdentifier","sendTransaction","identifier","_pendingTransactions","_pendingTransactionErrors","message","signTransaction","addEventListener","e","handleWalletMessage","url","origin","encodeURIComponent","location","connectUrl","open","Error","push","setInterval","closed","cleanUp","postMessage","Promise","resolve","reject","transaction","verifyCanSignRequests","signOneTransaction","transactions","signMultipleTransactions","connection","options","signers","undefined","length","then","walletTransaction","partialSign","sendFinalTransaction","signaturePubkeyPairs","signatures","sp","signature","toString","pendingTransaction","pendingTransactionError","catch","instructionsToSerializableInstructions","from","Uint8Array","atob","c","charCodeAt","populate","Array","header","numRequiredSignatures","_v","sigPubkeyPair","find","s","accountKeys","encode","some","buildTransaction","serializedTransactions","transactionIdentifiers","signAllTransactions","pendingTransactions","txId","pendingTransactionErrors","every","pt"],"sources":["/Users/ivan/Metadata/node_modules/@strike-protocols/solana-wallet-adapter/src/strikewallet.ts"],"sourcesContent":["\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\nimport { EventEmitter } from \"eventemitter3\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface StrikeWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface TransactionError {\n    message: string\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: TransactionError | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class StrikeWallet extends EventEmitter {\n    isLoggedIn: boolean;\n    url = 'https://wallet.strikeprotocols.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        super()\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as StrikeWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Strike\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n        this.emit('disconnected')\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return this.signMultipleTransactions(transactions);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Strike does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private signMultipleTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: uuidv4()\n            }\n        })\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier)\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null)\n        return new Promise<Transaction[]>((resolve, reject) => {\n            wallet.postMessage({type: \"signAllTransactions\", signAllTransactions: {transactions: serializedTransactions}}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId] as SignTransaction)\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId])\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer)\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)))\n                } else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer)\n                    reject(pendingTransactionErrors.find((e) => e != null))\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: StrikeWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error};\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = {message: data.error}\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}