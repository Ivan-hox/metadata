{"ast":null,"code":"import _regeneratorRuntime from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n/** Buffer layout for de/serializing a multisig */\nexport var MultisigLayout = struct([u8('m'), u8('n'), bool('isInitialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/** Byte length of a multisig */\nexport var MULTISIG_SIZE = MultisigLayout.span;\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport function getMultisig(_x, _x2, _x3) {\n  return _getMultisig.apply(this, arguments);\n}\n/**\n * Unpack a multisig\n *\n * @param address   Multisig account\n * @param info      Multisig account data\n * @param programId SPL Token program account\n *\n * @return Unpacked multisig\n */\nfunction _getMultisig() {\n  _getMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, address, commitment) {\n    var programId,\n      info,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            programId = _args.length > 3 && _args[3] !== undefined ? _args[3] : TOKEN_PROGRAM_ID;\n            _context.next = 3;\n            return connection.getAccountInfo(address, commitment);\n          case 3:\n            info = _context.sent;\n            return _context.abrupt(\"return\", unpackMultisig(address, info, programId));\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getMultisig.apply(this, arguments);\n}\nexport function unpackMultisig(address, info) {\n  var programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TOKEN_PROGRAM_ID;\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n  var multisig = MultisigLayout.decode(info.data);\n  return _objectSpread({\n    address: address\n  }, multisig);\n}\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport function getMinimumBalanceForRentExemptMultisig(_x4, _x5) {\n  return _getMinimumBalanceForRentExemptMultisig.apply(this, arguments);\n}\nfunction _getMinimumBalanceForRentExemptMultisig() {\n  _getMinimumBalanceForRentExemptMultisig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(connection, commitment) {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getMinimumBalanceForRentExemptMultisig.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;AAAA,SAASA,MAAM,EAAEC,EAAE,QAAQ,uBAAuB;AAClD,SAASC,IAAI,EAAEC,SAAS,QAAQ,6BAA6B;AAE7D,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,yBAAyB,EAAEC,6BAA6B,EAAEC,4BAA4B,QAAQ,cAAc;AA6BrH;AACA,OAAO,IAAMC,cAAc,GAAGR,MAAM,CAAc,CAC9CC,EAAE,CAAC,GAAG,CAAC,EACPA,EAAE,CAAC,GAAG,CAAC,EACPC,IAAI,CAAC,eAAe,CAAC,EACrBC,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,SAAS,CAAC,EACpBA,SAAS,CAAC,UAAU,CAAC,EACrBA,SAAS,CAAC,UAAU,CAAC,CACxB,CAAC;AAEF;AACA,OAAO,IAAMM,aAAa,GAAGD,cAAc,CAACE,IAAI;AAEhD;;;;;;;;;;AAUA,gBAAsBC,WAAW;EAAA;AAAA;AAUjC;;;;;;;;;AAAA;EAAA,0EAVO,iBACHC,UAAsB,EACtBC,OAAkB,EAClBC,UAAuB;IAAA;MAAA;MAAA;IAAA;MAAA;QAAA;UAAA;YACvBC,SAAS,2DAAGX,gBAAgB;YAAA;YAAA,OAETQ,UAAU,CAACI,cAAc,CAACH,OAAO,EAAEC,UAAU,CAAC;UAAA;YAA3DG,IAAI;YAAA,iCACHC,cAAc,CAACL,OAAO,EAAEI,IAAI,EAAEF,SAAS,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAClD;EAAA;AAAA;AAWD,OAAM,SAAUG,cAAc,CAC1BL,OAAkB,EAClBI,IAAgC,EACJ;EAAA,IAA5BF,SAAS,uEAAGX,gBAAgB;EAE5B,IAAI,CAACa,IAAI,EAAE,MAAM,IAAIZ,yBAAyB,EAAE;EAChD,IAAI,CAACY,IAAI,CAACE,KAAK,CAACC,MAAM,CAACL,SAAS,CAAC,EAAE,MAAM,IAAIT,6BAA6B,EAAE;EAC5E,IAAIW,IAAI,CAACI,IAAI,CAACC,MAAM,IAAIb,aAAa,EAAE,MAAM,IAAIF,4BAA4B,EAAE;EAE/E,IAAMgB,QAAQ,GAAGf,cAAc,CAACgB,MAAM,CAACP,IAAI,CAACI,IAAI,CAAC;EAEjD;IAASR,OAAO,EAAPA;EAAO,GAAKU,QAAQ;AACjC;AAEA;;;;;;;AAOA,gBAAsBE,sCAAsC;EAAA;AAAA;AAK3D;EAAA,qGALM,kBACHb,UAAsB,EACtBE,UAAuB;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OAEVF,UAAU,CAACc,iCAAiC,CAACjB,aAAa,EAAEK,UAAU,CAAC;UAAA;YAAA;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CACvF;EAAA;AAAA","names":["struct","u8","bool","publicKey","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","MultisigLayout","MULTISIG_SIZE","span","getMultisig","connection","address","commitment","programId","getAccountInfo","info","unpackMultisig","owner","equals","data","length","multisig","decode","getMinimumBalanceForRentExemptMultisig","getMinimumBalanceForRentExemption"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/state/multisig.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors.js';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMultisig(address, info, programId);\n}\n\n/**\n * Unpack a multisig\n *\n * @param address   Multisig account\n * @param info      Multisig account data\n * @param programId SPL Token program account\n *\n * @return Unpacked multisig\n */\nexport function unpackMultisig(\n    address: PublicKey,\n    info: AccountInfo<Buffer> | null,\n    programId = TOKEN_PROGRAM_ID\n): Multisig {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const multisig = MultisigLayout.decode(info.data);\n\n    return { address, ...multisig };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}