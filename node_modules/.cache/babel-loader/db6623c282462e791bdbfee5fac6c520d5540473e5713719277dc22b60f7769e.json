{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createClass = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nfunction e(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e.default : e;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar t = require(\"@keystonehq/bc-ur-registry-sol\"),\n  r = require(\"@keystonehq/sdk\"),\n  s = e(r),\n  n = require(\"@keystonehq/bc-ur-registry\"),\n  i = e(require(\"bs58\")),\n  a = require(\"uuid\"),\n  o = require(\"@solana/web3.js\");\nvar c = /*#__PURE__*/_createClass(function c() {\n  var _this = this;\n  _classCallCheck(this, c);\n  if (this.keystoneSDK = void 0, this.readCryptoMultiAccounts = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var e, _t;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _this.keystoneSDK.read([r.SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS], {\n              title: \"Sync Keystone\",\n              description: \"Please scan the QR code displayed on your Keystone\",\n              renderInitial: {\n                walletMode: \"Solflare\",\n                link: \"https://keyst.one/defi\"\n              },\n              URTypeErrorMessage: \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\"\n            });\n          case 2:\n            e = _context.sent;\n            if (!(e.status === r.ReadStatus.success)) {\n              _context.next = 6;\n              break;\n            }\n            _t = e.result;\n            return _context.abrupt(\"return\", n.CryptoMultiAccounts.fromCBOR(_t.cbor));\n          case 6:\n            throw new Error(\"Reading canceled\");\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), this.requestSignature = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(e, s, n) {\n      var i;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _this.keystoneSDK.play(e.toUR(), {\n                hasNext: !0,\n                title: s,\n                description: n,\n                maxFragmentLength: 400\n              });\n            case 2:\n              _context2.t0 = _context2.sent;\n              _context2.t1 = r.PlayStatus.canceled;\n              if (!(_context2.t0 === _context2.t1)) {\n                _context2.next = 6;\n                break;\n              }\n              throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n            case 6:\n              _context2.next = 8;\n              return _this.keystoneSDK.read([r.SupportedResult.UR_SOL_SIGNATURE], {\n                title: \"Scan Keystone\",\n                description: \"Please scan the QR code displayed on your Keystone\"\n              });\n            case 8:\n              i = _context2.sent;\n              if (!(i.status === r.ReadStatus.canceled)) {\n                _context2.next = 11;\n                break;\n              }\n              throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n            case 11:\n              return _context2.abrupt(\"return\", t.SolSignature.fromCBOR(i.result.cbor));\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), c.instance) return c.instance;\n  s.bootstrap(), this.keystoneSDK = s.getSdk(), c.instance = this;\n});\nvar u = /*#__PURE__*/function () {\n  function u() {\n    var _this2 = this;\n    _classCallCheck(this, u);\n    this.getInteraction = function () {\n      throw new Error(\"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\");\n    }, this.type = \"QR Hardware Wallet Device\", this.requestSignature = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(e, t, r, s) {\n        var n, i, o;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this2.getInteraction().requestSignature(t, r, s);\n              case 2:\n                n = _context3.sent;\n                i = n.getRequestId();\n                o = n.getSignature();\n                if (!(i && a.stringify(i) !== e)) {\n                  _context3.next = 7;\n                  break;\n                }\n                throw new Error(\"KeystoneError#invalid_data: read signature error: mismatched requestId\");\n              case 7:\n                return _context3.abrupt(\"return\", o);\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x4, _x5, _x6, _x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }(), this.getName = function () {\n      return _this2.name;\n    }, this.keys = [], this.name = \"QR Hardware\", this.initialized = !1, this.device = \"\", this.xfp = \"\";\n  }\n  _createClass(u, [{\n    key: \"readKeyring\",\n    value: function () {\n      var _readKeyring = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var e;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getInteraction().readCryptoMultiAccounts();\n              case 2:\n                e = _context4.sent;\n                this.syncKeyring(e);\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function readKeyring() {\n        return _readKeyring.apply(this, arguments);\n      }\n      return readKeyring;\n    }()\n  }, {\n    key: \"syncKeyring\",\n    value: function syncKeyring(e) {\n      var t;\n      var r = e.getKeys();\n      this.device = e.getDevice(), this.xfp = null == (t = e.getKeys()[0].getOrigin().getSourceFingerprint()) ? void 0 : t.toString(\"hex\"), this.name = e.getKeys()[0].getName(), this.keys = r.map(function (e, t) {\n        return {\n          hdPath: e.getOrigin().getPath(),\n          pubKey: i.encode(e.getKey()),\n          index: t\n        };\n      }), this.initialized = !0;\n    }\n  }, {\n    key: \"syncKeyringData\",\n    value: function syncKeyringData(_ref4) {\n      var e = _ref4.xfp,\n        t = _ref4.keys,\n        _ref4$name = _ref4.name,\n        r = _ref4$name === void 0 ? \"QR Hardware\" : _ref4$name,\n        s = _ref4.device;\n      this.xfp = e, this.name = r, this.keys = t, this.device = s, this.initialized = !0;\n    }\n  }, {\n    key: \"getAccounts\",\n    value: function getAccounts() {\n      return this.initialized ? this.keys : [];\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(e, r) {\n        var s;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._getSignature(e, Buffer.from(r.serializeMessage()), t.SignType.Transaction);\n              case 2:\n                s = _context5.sent;\n                return _context5.abrupt(\"return\", (r.addSignature(new o.PublicKey(e), s), r));\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function signTransaction(_x8, _x9) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(e, r) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._getSignature(e, Buffer.from(r), t.SignType.Message);\n              case 2:\n                return _context6.abrupt(\"return\", _context6.sent);\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function signMessage(_x10, _x11) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }()\n  }, {\n    key: \"createSignature\",\n    value: function () {\n      var _createSignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(e, r) {\n        var _s;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _s = o.Message.from(r);\n                if (!o.Transaction.populate(_s, [])) {\n                  _context7.next = 4;\n                  break;\n                }\n                return _context7.abrupt(\"return\", this._getSignature(e, Buffer.from(r), t.SignType.Transaction));\n              case 4:\n                _context7.next = 8;\n                break;\n              case 6:\n                _context7.prev = 6;\n                _context7.t0 = _context7[\"catch\"](0);\n              case 8:\n                return _context7.abrupt(\"return\", this.signMessage(e, r));\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 6]]);\n      }));\n      function createSignature(_x12, _x13) {\n        return _createSignature.apply(this, arguments);\n      }\n      return createSignature;\n    }()\n  }, {\n    key: \"_getSignature\",\n    value: function () {\n      var _getSignature2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(e, r, s) {\n        var n, i, o;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                n = a.v4(), i = this.getAccounts().find(function (t) {\n                  return t.pubKey == e;\n                }), o = t.SolSignRequest.constructSOLRequest(r, i.hdPath, this.xfp, s, n);\n                return _context8.abrupt(\"return\", this.requestSignature(n, o, \"Scan with your Keystone\", 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature'));\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function _getSignature(_x14, _x15, _x16) {\n        return _getSignature2.apply(this, arguments);\n      }\n      return _getSignature;\n    }()\n  }]);\n  return u;\n}();\nu.type = \"QR Hardware Wallet Device\";\nvar y = /*#__PURE__*/function (_u) {\n  _inherits(y, _u);\n  var _super = _createSuper(y);\n  function y() {\n    var _this3;\n    _classCallCheck(this, y);\n    _this3 = _super.call(this), _this3.getInteraction = function () {\n      return new c();\n    };\n    return _this3;\n  }\n  _createClass(y, null, [{\n    key: \"getEmptyKeyring\",\n    value: function getEmptyKeyring() {\n      return new y();\n    }\n  }]);\n  return y;\n}(u);\ny.type = u.type, exports.BaseKeyring = u, exports.DefaultKeyring = y;","map":{"version":3,"mappings":"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","names":["DefaultInteractionProvider","constructor","undefined","async","this","keystoneSDK","read","SupportedResult","UR_CRYPTO_MULTI_ACCOUNTS","title","description","renderInitial","walletMode","link","URTypeErrorMessage","decodedResult","status","ReadStatus","success","result","CryptoMultiAccounts","fromCBOR","cbor","Error","solSignRequest","requestTitle","requestDescription","play","toUR","hasNext","maxFragmentLength","PlayStatus","canceled","UR_SOL_SIGNATURE","SolSignature","instance","sdk","bootstrap","getSdk","BaseKeyring","_requestId","signRequest","getInteraction","requestSignature","solSignature","requestIdBuffer","getRequestId","signature","getSignature","uuid","name","keys","initialized","device","xfp","readCryptoMultiAccounts","syncKeyring","data","getKeys","getDevice","getOrigin","getSourceFingerprint","_data$getKeys$0$getOr","toString","getName","map","each","index","hdPath","getPath","pubKey","bs58","encode","getKey","syncKeyringData","getAccounts","tx","_getSignature","Buffer","from","serializeMessage","SignType","Transaction","addSignature","PublicKey","messageHex","Message","messageInstance","populate","signMessage","signType","requestId","account","find","SolSignRequest","constructSOLRequest","DefaultKeyring","type"],"sources":["/Users/ivan/Metadata/node_modules/@keystonehq/sol-keyring/src/DefaultInteractionProvider.ts","/Users/ivan/Metadata/node_modules/@keystonehq/sol-keyring/src/BaseKeyring.ts","/Users/ivan/Metadata/node_modules/@keystonehq/sol-keyring/src/DefaultKeyring.ts"],"sourcesContent":["import { SolSignature, SolSignRequest } from \"@keystonehq/bc-ur-registry-sol\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport sdk, { PlayStatus, ReadStatus, SupportedResult } from \"@keystonehq/sdk\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\n\nexport class DefaultInteractionProvider implements InteractionProvider {\n  private static instance;\n  private keystoneSDK = undefined;\n\n  constructor() {\n    if (DefaultInteractionProvider.instance) {\n      return DefaultInteractionProvider.instance;\n    }\n    sdk.bootstrap();\n    this.keystoneSDK = sdk.getSdk();\n    DefaultInteractionProvider.instance = this;\n  }\n\n  public readCryptoMultiAccounts = async () => {\n    const decodedResult = await this.keystoneSDK.read(\n      [SupportedResult.UR_CRYPTO_MULTI_ACCOUNTS],\n      {\n        title: \"Sync Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n        renderInitial: {\n          walletMode: \"Solflare\",\n          link: \"https://keyst.one/defi\",\n        },\n        URTypeErrorMessage:\n          \"The scanned QR code is not the sync code from the Keystone hardware wallet. Please verify the code and try again\",\n      }\n    );\n    if (decodedResult.status === ReadStatus.success) {\n      const { result } = decodedResult;\n      return CryptoMultiAccounts.fromCBOR(result.cbor);\n    } else {\n      throw new Error(\"Reading canceled\");\n    }\n  };\n\n  public requestSignature = async (\n    solSignRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ) => {\n    const status = await this.keystoneSDK.play(solSignRequest.toUR(), {\n      hasNext: true,\n      title: requestTitle,\n      description: requestDescription,\n      maxFragmentLength: 400\n    });\n    if (status === PlayStatus.canceled)\n      throw new Error(\"#ktek_error[play-cancel]: play canceled\");\n    const result = await this.keystoneSDK.read(\n      [SupportedResult.UR_SOL_SIGNATURE],\n      {\n        title: \"Scan Keystone\",\n        description: \"Please scan the QR code displayed on your Keystone\",\n      }\n    );\n    if (result.status === ReadStatus.canceled) {\n      throw new Error(\"#ktek_error[read-cancel]: read signature canceled\");\n    } else {\n      return SolSignature.fromCBOR(result.result.cbor);\n    }\n  };\n}\n","import bs58 from \"bs58\";\nimport * as uuid from \"uuid\";\nimport { Message, PublicKey, Transaction } from \"@solana/web3.js\";\nimport { InteractionProvider } from \"./InteractionProvider\";\nimport { CryptoMultiAccounts } from \"@keystonehq/bc-ur-registry\";\nimport { SolSignRequest, SignType } from \"@keystonehq/bc-ur-registry-sol\";\n\nconst keyringType = \"QR Hardware Wallet Device\";\n\nexport interface HDKey {\n  hdPath: string;\n  pubKey: string;\n  index: number;\n}\n\ninterface KeyringInitData {\n  xfp: string;\n  keys: HDKey[];\n  name?: string;\n  device?: string;\n}\n\nexport class BaseKeyring {\n  getInteraction = (): InteractionProvider => {\n    throw new Error(\n      \"KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.\"\n    );\n  };\n  static type = keyringType;\n  protected xfp: string;\n  protected type = keyringType;\n  protected initialized: boolean;\n  protected keys: HDKey[];\n  protected name: string;\n  protected device: string;\n  constructor() {\n    //common props\n    this.keys = [];\n    this.name = \"QR Hardware\";\n    this.initialized = false;\n    this.device = \"\";\n    this.xfp = \"\";\n  }\n\n  protected requestSignature = async (\n    _requestId: string,\n    signRequest: SolSignRequest,\n    requestTitle?: string,\n    requestDescription?: string\n  ): Promise<Buffer> => {\n    const solSignature = await this.getInteraction().requestSignature(\n      signRequest,\n      requestTitle,\n      requestDescription\n    );\n    const requestIdBuffer = solSignature.getRequestId();\n    const signature = solSignature.getSignature();\n    if (requestIdBuffer) {\n      const requestId = uuid.stringify(requestIdBuffer);\n      if (requestId !== _requestId) {\n        throw new Error(\n          \"KeystoneError#invalid_data: read signature error: mismatched requestId\"\n        );\n      }\n    }\n    return signature;\n  };\n\n  //initial read\n  async readKeyring(): Promise<void> {\n    const result = await this.getInteraction().readCryptoMultiAccounts();\n    this.syncKeyring(result);\n  }\n\n  public syncKeyring(data: CryptoMultiAccounts): void {\n    const keys = data.getKeys();\n    this.device = data.getDevice();\n    this.xfp = data\n      .getKeys()[0]\n      .getOrigin()\n      .getSourceFingerprint()\n      ?.toString(\"hex\");\n    this.name = data.getKeys()[0].getName();\n    this.keys = keys.map((each, index) => ({\n      hdPath: each.getOrigin().getPath(),\n      pubKey: bs58.encode(each.getKey()),\n      index,\n    }));\n    this.initialized = true;\n  }\n\n  public syncKeyringData({xfp, keys, name = \"QR Hardware\", device}: KeyringInitData): void {\n    this.xfp = xfp\n    this.name = name\n    this.keys = keys\n    this.device = device\n    this.initialized = true;\n  }\n\n  public getName = (): string => {\n    return this.name;\n  };\n\n  getAccounts() {\n    if (!this.initialized) {\n      return [];\n    }\n    return this.keys;\n  }\n\n  async signTransaction(pubKey: string, tx: Transaction): Promise<Transaction> {\n    const signature = await this._getSignature(pubKey, Buffer.from(tx.serializeMessage() as unknown as ArrayBuffer), SignType.Transaction)\n    tx.addSignature(new PublicKey(pubKey), signature);\n    return tx;\n  }\n\n  async signMessage(\n    pubKey: string,\n    messageHex: Uint8Array\n  ): Promise<Uint8Array> {\n    return await this._getSignature(pubKey, Buffer.from(messageHex), SignType.Message)\n  }\n\n  async createSignature(pubKey: string, messageHex: Uint8Array): Promise<Uint8Array>{\n    try{\n      const messageInstance = Message.from(messageHex);\n      const transaction = Transaction.populate(messageInstance, []);\n      if (transaction) {\n        return this._getSignature(pubKey, Buffer.from(messageHex),SignType.Transaction)\n      }\n    }catch(e){\n    }\n    return this.signMessage(pubKey, messageHex)\n  }\n\n  async _getSignature(pubKey: string, messageHex: Buffer, signType): Promise<Buffer>{\n    const requestId = uuid.v4();\n    const account = this.getAccounts().find(\n        (account) => account.pubKey == pubKey\n    );\n    const solSignRequest = SolSignRequest.constructSOLRequest(\n        messageHex,\n        account.hdPath,\n        this.xfp,\n        signType,\n        requestId,\n    );\n    return this.requestSignature(\n        requestId,\n        solSignRequest,\n        \"Scan with your Keystone\",\n        'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature'\n    );\n  }\n}\n","import { DefaultInteractionProvider } from \"./DefaultInteractionProvider\";\nimport { BaseKeyring } from \"./BaseKeyring\";\n\nexport class DefaultKeyring extends BaseKeyring {\n  static type = BaseKeyring.type;\n\n  static getEmptyKeyring(): DefaultKeyring {\n    return new DefaultKeyring();\n  }\n\n  constructor() {\n    super();\n  }\n\n  getInteraction = () => {\n    return new DefaultInteractionProvider();\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}