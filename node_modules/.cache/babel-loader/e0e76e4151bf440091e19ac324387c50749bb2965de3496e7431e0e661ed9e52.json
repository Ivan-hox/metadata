{"ast":null,"code":"import _slicedToArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nvar _userAgent;\nfunction getUserAgent() {\n  if (_userAgent === undefined) {\n    var _globalThis$navigator, _globalThis$navigator2;\n    _userAgent = (_globalThis$navigator = (_globalThis$navigator2 = globalThis.navigator) === null || _globalThis$navigator2 === void 0 ? void 0 : _globalThis$navigator2.userAgent) !== null && _globalThis$navigator !== void 0 ? _globalThis$navigator : null;\n  }\n  return _userAgent;\n}\nfunction getIsMobile(adapters) {\n  var userAgentString = getUserAgent();\n  return getEnvironment({\n    adapters: adapters,\n    userAgentString: userAgentString\n  }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n  var location = globalThis.location;\n  if (location == null) {\n    return;\n  }\n  return \"\".concat(location.protocol, \"//\").concat(location.host);\n}\nexport function WalletProvider(_ref) {\n  var children = _ref.children,\n    adapters = _ref.wallets,\n    autoConnect = _ref.autoConnect,\n    _ref$localStorageKey = _ref.localStorageKey,\n    localStorageKey = _ref$localStorageKey === void 0 ? 'walletName' : _ref$localStorageKey,\n    onError = _ref.onError;\n  var _useConnection = useConnection(),\n    connection = _useConnection.connection;\n  var adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n  var mobileWalletAdapter = useMemo(function () {\n    if (!getIsMobile(adaptersWithStandardAdapters)) {\n      return null;\n    }\n    var existingMobileWalletAdapter = adaptersWithStandardAdapters.find(function (adapter) {\n      return adapter.name === SolanaMobileWalletAdapterWalletName;\n    });\n    if (existingMobileWalletAdapter) {\n      return existingMobileWalletAdapter;\n    }\n    return new SolanaMobileWalletAdapter({\n      addressSelector: createDefaultAddressSelector(),\n      appIdentity: {\n        uri: getUriForAppIdentity()\n      },\n      authorizationResultCache: createDefaultAuthorizationResultCache(),\n      cluster: getInferredClusterFromEndpoint(connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint),\n      onWalletNotFound: createDefaultWalletNotFoundHandler()\n    });\n  }, [adaptersWithStandardAdapters, connection === null || connection === void 0 ? void 0 : connection.rpcEndpoint]);\n  var adaptersWithMobileWalletAdapter = useMemo(function () {\n    if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n      return adaptersWithStandardAdapters;\n    }\n    return [mobileWalletAdapter].concat(_toConsumableArray(adaptersWithStandardAdapters));\n  }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n  var _useLocalStorage = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null),\n    _useLocalStorage2 = _slicedToArray(_useLocalStorage, 2),\n    walletName = _useLocalStorage2[0],\n    setWalletName = _useLocalStorage2[1];\n  var adapter = useMemo(function () {\n    var _adaptersWithMobileWa;\n    return (_adaptersWithMobileWa = adaptersWithMobileWalletAdapter.find(function (a) {\n      return a.name === walletName;\n    })) !== null && _adaptersWithMobileWa !== void 0 ? _adaptersWithMobileWa : null;\n  }, [adaptersWithMobileWalletAdapter, walletName]);\n  useEffect(function () {\n    if (adapter == null) {\n      return;\n    }\n    function handleDisconnect() {\n      if (isUnloadingRef.current) {\n        return;\n      }\n      if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n        // Leave the adapter selected in the event of a disconnection.\n        return;\n      }\n      setWalletName(null);\n    }\n    adapter.on('disconnect', handleDisconnect);\n    return function () {\n      adapter.off('disconnect', handleDisconnect);\n    };\n  }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n  var handleAutoConnectRequest = useMemo(function () {\n    if (autoConnect !== true || !adapter) {\n      return;\n    }\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      return adapter.autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.bind(adapter);\n    } else {\n      return adapter.connect.bind(adapter);\n    }\n  }, [adapter, adaptersWithStandardAdapters, autoConnect, walletName]);\n  useEffect(function () {\n    if (adapter == null) {\n      return;\n    }\n    return function () {\n      if (\n      // Selecting a wallet other than the mobile wallet adapter is not\n      // sufficient reason to call `disconnect` on the mobile wallet adapter.\n      // Calling `disconnect` on the mobile wallet adapter causes the entire\n      // authorization store to be wiped.\n      adapter.name !== SolanaMobileWalletAdapterWalletName) {\n        adapter.disconnect();\n      }\n    };\n  }, [adapter]);\n  var isUnloadingRef = useRef(false);\n  useEffect(function () {\n    if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n      isUnloadingRef.current = false;\n      return;\n    }\n    function handleBeforeUnload() {\n      isUnloadingRef.current = true;\n    }\n    /**\n     * Some wallets fire disconnection events when the window unloads. Since there's no way to\n     * distinguish between a disconnection event received because a user initiated it, and one\n     * that was received because they've closed the window, we have to track window unload\n     * events themselves. Downstream components use this information to decide whether to act\n     * upon or drop wallet events and errors.\n     */\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return function () {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [adaptersWithStandardAdapters, walletName]);\n  var handleConnectError = useCallback(function () {\n    if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n      // If any error happens while connecting, unset the adapter.\n      setWalletName(null);\n    }\n  }, [adapter, setWalletName]);\n  return React.createElement(WalletProviderBase, {\n    wallets: adaptersWithMobileWalletAdapter,\n    adapter: adapter,\n    isUnloadingRef: isUnloadingRef,\n    onAutoConnectRequest: handleAutoConnectRequest,\n    onConnectError: handleConnectError,\n    onError: onError,\n    onSelectWallet: setWalletName\n  }, children);\n}","map":{"version":3,"mappings":";;AAAA,SACIA,4BAA4B,EAC5BC,qCAAqC,EACrCC,kCAAkC,EAClCC,yBAAyB,EACzBC,mCAAmC,QAChC,sCAAsC;AAE7C,SAASC,yBAAyB,QAAQ,8CAA8C;AACxF,OAAOC,KAAK,IAAoBC,WAAW,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACtF,OAAOC,cAAc,IAAIC,WAAW,QAAQ,qBAAqB;AACjE,OAAOC,8BAA8B,MAAM,qCAAqC;AAChF,SAASC,aAAa,QAAQ,oBAAoB;AAClD,SAASC,eAAe,QAAQ,sBAAsB;AACtD,SAASC,kBAAkB,QAAQ,yBAAyB;AAU5D,IAAIC,UAAyB;AAC7B,SAASC,YAAY;EACjB,IAAID,UAAU,KAAKE,SAAS,EAAE;IAAA;IAC1BF,UAAU,sDAAGG,UAAU,CAACC,SAAS,2DAApB,uBAAsBC,SAAS,yEAAI,IAAI;;EAExD,OAAOL,UAAU;AACrB;AAEA,SAASM,WAAW,CAACC,QAAmB;EACpC,IAAMC,eAAe,GAAGP,YAAY,EAAE;EACtC,OAAOP,cAAc,CAAC;IAAEa,QAAQ,EAARA,QAAQ;IAAEC,eAAe,EAAfA;EAAe,CAAE,CAAC,KAAKb,WAAW,CAACc,UAAU;AACnF;AAEA,SAASC,oBAAoB;EACzB,IAAMC,QAAQ,GAAGR,UAAU,CAACQ,QAAQ;EACpC,IAAIA,QAAQ,IAAI,IAAI,EAAE;IAClB;;EAEJ,iBAAUA,QAAQ,CAACC,QAAQ,eAAKD,QAAQ,CAACE,IAAI;AACjD;AAEA,OAAM,SAAUC,cAAc,OAMR;EAAA,IALlBC,QAAQ,QAARA,QAAQ;IACCR,QAAQ,QAAjBS,OAAO;IACPC,WAAW,QAAXA,WAAW;IAAA,4BACXC,eAAe;IAAfA,eAAe,qCAAG,YAAY;IAC9BC,OAAO,QAAPA,OAAO;EAEP,qBAAuBtB,aAAa,EAAE;IAA9BuB,UAAU,kBAAVA,UAAU;EAClB,IAAMC,4BAA4B,GAAGjC,yBAAyB,CAACmB,QAAQ,CAAC;EACxE,IAAMe,mBAAmB,GAAG9B,OAAO,CAAC,YAAK;IACrC,IAAI,CAACc,WAAW,CAACe,4BAA4B,CAAC,EAAE;MAC5C,OAAO,IAAI;;IAEf,IAAME,2BAA2B,GAAGF,4BAA4B,CAACG,IAAI,CACjE,UAACC,OAAO;MAAA,OAAKA,OAAO,CAACC,IAAI,KAAKvC,mCAAmC;IAAA,EACpE;IACD,IAAIoC,2BAA2B,EAAE;MAC7B,OAAOA,2BAA2B;;IAEtC,OAAO,IAAIrC,yBAAyB,CAAC;MACjCyC,eAAe,EAAE5C,4BAA4B,EAAE;MAC/C6C,WAAW,EAAE;QACTC,GAAG,EAAEnB,oBAAoB;OAC5B;MACDoB,wBAAwB,EAAE9C,qCAAqC,EAAE;MACjE+C,OAAO,EAAEnC,8BAA8B,CAACwB,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEY,WAAW,CAAC;MAChEC,gBAAgB,EAAEhD,kCAAkC;KACvD,CAAC;EACN,CAAC,EAAE,CAACoC,4BAA4B,EAAED,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEY,WAAW,CAAC,CAAC;EAC3D,IAAME,+BAA+B,GAAG1C,OAAO,CAAC,YAAK;IACjD,IAAI8B,mBAAmB,IAAI,IAAI,IAAID,4BAA4B,CAACc,OAAO,CAACb,mBAAmB,CAAC,KAAK,CAAC,CAAC,EAAE;MACjG,OAAOD,4BAA4B;;IAEvC,QAAQC,mBAAmB,4BAAKD,4BAA4B;EAChE,CAAC,EAAE,CAACA,4BAA4B,EAAEC,mBAAmB,CAAC,CAAC;EACvD,uBAAoCxB,eAAe,CAC/CoB,eAAe,EACfZ,WAAW,CAACe,4BAA4B,CAAC,GAAGlC,mCAAmC,GAAG,IAAI,CACzF;IAAA;IAHMiD,UAAU;IAAEC,aAAa;EAIhC,IAAMZ,OAAO,GAAGjC,OAAO,CACnB;IAAA;IAAA,gCAAM0C,+BAA+B,CAACV,IAAI,CAAC,UAACc,CAAC;MAAA,OAAKA,CAAC,CAACZ,IAAI,KAAKU,UAAU;IAAA,EAAC,yEAAI,IAAI;EAAA,GAChF,CAACF,+BAA+B,EAAEE,UAAU,CAAC,CAChD;EACD7C,SAAS,CAAC,YAAK;IACX,IAAIkC,OAAO,IAAI,IAAI,EAAE;MACjB;;IAEJ,SAASc,gBAAgB;MACrB,IAAIC,cAAc,CAACC,OAAO,EAAE;QACxB;;MAEJ,IAAIL,UAAU,KAAKjD,mCAAmC,IAAImB,WAAW,CAACe,4BAA4B,CAAC,EAAE;QACjG;QACA;;MAEJgB,aAAa,CAAC,IAAI,CAAC;IACvB;IACAZ,OAAO,CAACiB,EAAE,CAAC,YAAY,EAAEH,gBAAgB,CAAC;IAC1C,OAAO,YAAK;MACRd,OAAO,CAACkB,GAAG,CAAC,YAAY,EAAEJ,gBAAgB,CAAC;IAC/C,CAAC;EACL,CAAC,EAAE,CAACd,OAAO,EAAEJ,4BAA4B,EAAEgB,aAAa,EAAED,UAAU,CAAC,CAAC;EACtE,IAAMQ,wBAAwB,GAAGpD,OAAO,CAAC,YAAK;IAC1C,IAAIyB,WAAW,KAAK,IAAI,IAAI,CAACQ,OAAO,EAAE;MAClC;;IAEJ,IAAIW,UAAU,KAAKjD,mCAAmC,IAAImB,WAAW,CAACe,4BAA4B,CAAC,EAAE;MACjG,OAAQI,OAAqC,CAACoB,2CAA2C,CAACC,IAAI,CAACrB,OAAO,CAAC;KAC1G,MAAM;MACH,OAAOA,OAAO,CAACsB,OAAO,CAACD,IAAI,CAACrB,OAAO,CAAC;;EAE5C,CAAC,EAAE,CAACA,OAAO,EAAEJ,4BAA4B,EAAEJ,WAAW,EAAEmB,UAAU,CAAC,CAAC;EACpE7C,SAAS,CAAC,YAAK;IACX,IAAIkC,OAAO,IAAI,IAAI,EAAE;MACjB;;IAEJ,OAAO,YAAK;MACR;MACI;MACA;MACA;MACA;MACAA,OAAO,CAACC,IAAI,KAAKvC,mCAAmC,EACtD;QACEsC,OAAO,CAACuB,UAAU,EAAE;;IAE5B,CAAC;EACL,CAAC,EAAE,CAACvB,OAAO,CAAC,CAAC;EACb,IAAMe,cAAc,GAAG/C,MAAM,CAAC,KAAK,CAAC;EACpCF,SAAS,CAAC,YAAK;IACX,IAAI6C,UAAU,KAAKjD,mCAAmC,IAAImB,WAAW,CAACe,4BAA4B,CAAC,EAAE;MACjGmB,cAAc,CAACC,OAAO,GAAG,KAAK;MAC9B;;IAEJ,SAASQ,kBAAkB;MACvBT,cAAc,CAACC,OAAO,GAAG,IAAI;IACjC;IACA;;;;;;;IAOAS,MAAM,CAACC,gBAAgB,CAAC,cAAc,EAAEF,kBAAkB,CAAC;IAC3D,OAAO,YAAK;MACRC,MAAM,CAACE,mBAAmB,CAAC,cAAc,EAAEH,kBAAkB,CAAC;IAClE,CAAC;EACL,CAAC,EAAE,CAAC5B,4BAA4B,EAAEe,UAAU,CAAC,CAAC;EAC9C,IAAMiB,kBAAkB,GAAG/D,WAAW,CAAC,YAAK;IACxC,IAAImC,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAKvC,mCAAmC,EAAE;MACjE;MACAkD,aAAa,CAAC,IAAI,CAAC;;EAE3B,CAAC,EAAE,CAACZ,OAAO,EAAEY,aAAa,CAAC,CAAC;EAC5B,OACIhD,oBAACU,kBAAkB;IACfiB,OAAO,EAAEkB,+BAA+B;IACxCT,OAAO,EAAEA,OAAO;IAChBe,cAAc,EAAEA,cAAc;IAC9Bc,oBAAoB,EAAEV,wBAAwB;IAC9CW,cAAc,EAAEF,kBAAkB;IAClClC,OAAO,EAAEA,OAAO;IAChBqC,cAAc,EAAEnB;EAAa,GAE5BtB,QAAQ,CACQ;AAE7B","names":["createDefaultAddressSelector","createDefaultAuthorizationResultCache","createDefaultWalletNotFoundHandler","SolanaMobileWalletAdapter","SolanaMobileWalletAdapterWalletName","useStandardWalletAdapters","React","useCallback","useEffect","useMemo","useRef","getEnvironment","Environment","getInferredClusterFromEndpoint","useConnection","useLocalStorage","WalletProviderBase","_userAgent","getUserAgent","undefined","globalThis","navigator","userAgent","getIsMobile","adapters","userAgentString","MOBILE_WEB","getUriForAppIdentity","location","protocol","host","WalletProvider","children","wallets","autoConnect","localStorageKey","onError","connection","adaptersWithStandardAdapters","mobileWalletAdapter","existingMobileWalletAdapter","find","adapter","name","addressSelector","appIdentity","uri","authorizationResultCache","cluster","rpcEndpoint","onWalletNotFound","adaptersWithMobileWalletAdapter","indexOf","walletName","setWalletName","a","handleDisconnect","isUnloadingRef","current","on","off","handleAutoConnectRequest","autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","bind","connect","disconnect","handleBeforeUnload","window","addEventListener","removeEventListener","handleConnectError","onAutoConnectRequest","onConnectError","onSelectWallet"],"sources":["/Users/ivan/Metadata/node_modules/@solana/wallet-adapter-react/src/WalletProvider.tsx"],"sourcesContent":["import {\n    createDefaultAddressSelector,\n    createDefaultAuthorizationResultCache,\n    createDefaultWalletNotFoundHandler,\n    SolanaMobileWalletAdapter,\n    SolanaMobileWalletAdapterWalletName,\n} from '@solana-mobile/wallet-adapter-mobile';\nimport { type Adapter, type WalletError, type WalletName } from '@solana/wallet-adapter-base';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { type ReactNode, useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    autoConnect?: boolean;\n    localStorageKey?: string;\n    onError?: (error: WalletError, adapter?: Adapter) => void;\n}\n\nlet _userAgent: string | null;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\n\nfunction getIsMobile(adapters: Adapter[]) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\n\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (location == null) {\n        return;\n    }\n    return `${location.protocol}//${location.host}`;\n}\n\nexport function WalletProvider({\n    children,\n    wallets: adapters,\n    autoConnect,\n    localStorageKey = 'walletName',\n    onError,\n}: WalletProviderProps) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find(\n            (adapter) => adapter.name === SolanaMobileWalletAdapterWalletName\n        );\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage<WalletName | null>(\n        localStorageKey,\n        getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null\n    );\n    const adapter = useMemo(\n        () => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null,\n        [adaptersWithMobileWalletAdapter, walletName]\n    );\n    useEffect(() => {\n        if (adapter == null) {\n            return;\n        }\n        function handleDisconnect() {\n            if (isUnloadingRef.current) {\n                return;\n            }\n            if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n                // Leave the adapter selected in the event of a disconnection.\n                return;\n            }\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (autoConnect !== true || !adapter) {\n            return;\n        }\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            return (adapter as SolanaMobileWalletAdapter).autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.bind(adapter);\n        } else {\n            return adapter.connect.bind(adapter);\n        }\n    }, [adapter, adaptersWithStandardAdapters, autoConnect, walletName]);\n    useEffect(() => {\n        if (adapter == null) {\n            return;\n        }\n        return () => {\n            if (\n                // Selecting a wallet other than the mobile wallet adapter is not\n                // sufficient reason to call `disconnect` on the mobile wallet adapter.\n                // Calling `disconnect` on the mobile wallet adapter causes the entire\n                // authorization store to be wiped.\n                adapter.name !== SolanaMobileWalletAdapterWalletName\n            ) {\n                adapter.disconnect();\n            }\n        };\n    }, [adapter]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            setWalletName(null);\n        }\n    }, [adapter, setWalletName]);\n    return (\n        <WalletProviderBase\n            wallets={adaptersWithMobileWalletAdapter}\n            adapter={adapter}\n            isUnloadingRef={isUnloadingRef}\n            onAutoConnectRequest={handleAutoConnectRequest}\n            onConnectError={handleConnectError}\n            onError={onError}\n            onSelectWallet={setWalletName}\n        >\n            {children}\n        </WalletProviderBase>\n    );\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}