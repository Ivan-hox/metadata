{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _regeneratorRuntime = require(\"/Users/ivan/Metadata/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAssociatedTokenAddressSync = exports.getAssociatedTokenAddress = exports.getMinimumBalanceForRentExemptMintWithExtensions = exports.getMinimumBalanceForRentExemptMint = exports.unpackMint = exports.getMint = exports.MINT_SIZE = exports.MintLayout = void 0;\nvar buffer_layout_1 = require(\"@solana/buffer-layout\");\nvar buffer_layout_utils_1 = require(\"@solana/buffer-layout-utils\");\nvar web3_js_1 = require(\"@solana/web3.js\");\nvar constants_js_1 = require(\"../constants.js\");\nvar errors_js_1 = require(\"../errors.js\");\nvar accountType_js_1 = require(\"../extensions/accountType.js\");\nvar extensionType_js_1 = require(\"../extensions/extensionType.js\");\nvar account_js_1 = require(\"./account.js\");\nvar multisig_js_1 = require(\"./multisig.js\");\n/** Buffer layout for de/serializing a mint */\nexports.MintLayout = (0, buffer_layout_1.struct)([(0, buffer_layout_1.u32)('mintAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('mintAuthority'), (0, buffer_layout_utils_1.u64)('supply'), (0, buffer_layout_1.u8)('decimals'), (0, buffer_layout_utils_1.bool)('isInitialized'), (0, buffer_layout_1.u32)('freezeAuthorityOption'), (0, buffer_layout_utils_1.publicKey)('freezeAuthority')]);\n/** Byte length of a mint */\nexports.MINT_SIZE = exports.MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nfunction getMint(connection, address, commitment) {\n  var programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_js_1.TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var info;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return connection.getAccountInfo(address, commitment);\n          case 2:\n            info = _context.sent;\n            return _context.abrupt(\"return\", unpackMint(address, info, programId));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexports.getMint = getMint;\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nfunction unpackMint(address, info) {\n  var programId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_js_1.TOKEN_PROGRAM_ID;\n  if (!info) throw new errors_js_1.TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new errors_js_1.TokenInvalidAccountOwnerError();\n  if (info.data.length < exports.MINT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n  var rawMint = exports.MintLayout.decode(info.data.slice(0, exports.MINT_SIZE));\n  var tlvData = Buffer.alloc(0);\n  if (info.data.length > exports.MINT_SIZE) {\n    if (info.data.length <= account_js_1.ACCOUNT_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data.length === multisig_js_1.MULTISIG_SIZE) throw new errors_js_1.TokenInvalidAccountSizeError();\n    if (info.data[account_js_1.ACCOUNT_SIZE] != accountType_js_1.AccountType.Mint) throw new errors_js_1.TokenInvalidMintError();\n    tlvData = info.data.slice(account_js_1.ACCOUNT_SIZE + accountType_js_1.ACCOUNT_TYPE_SIZE);\n  }\n  return {\n    address: address,\n    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n    supply: rawMint.supply,\n    decimals: rawMint.decimals,\n    isInitialized: rawMint.isInitialized,\n    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    tlvData: tlvData\n  };\n}\nexports.unpackMint = unpackMint;\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent);\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\nexports.getMinimumBalanceForRentExemptMint = getMinimumBalanceForRentExemptMint;\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nfunction getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var mintLen;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            mintLen = (0, extensionType_js_1.getMintLen)(extensions);\n            _context3.next = 3;\n            return connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n          case 3:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\nexports.getMinimumBalanceForRentExemptMintWithExtensions = getMinimumBalanceForRentExemptMintWithExtensions;\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nfunction getAssociatedTokenAddress(mint, owner) {\n  var allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_js_1.TOKEN_PROGRAM_ID;\n  var associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var _yield$web3_js_1$Publ, _yield$web3_js_1$Publ2, address;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!(!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer()))) {\n              _context4.next = 2;\n              break;\n            }\n            throw new errors_js_1.TokenOwnerOffCurveError();\n          case 2:\n            _context4.next = 4;\n            return web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n          case 4:\n            _yield$web3_js_1$Publ = _context4.sent;\n            _yield$web3_js_1$Publ2 = _slicedToArray(_yield$web3_js_1$Publ, 1);\n            address = _yield$web3_js_1$Publ2[0];\n            return _context4.abrupt(\"return\", address);\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\nexports.getAssociatedTokenAddress = getAssociatedTokenAddress;\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nfunction getAssociatedTokenAddressSync(mint, owner) {\n  var allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : constants_js_1.TOKEN_PROGRAM_ID;\n  var associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : constants_js_1.ASSOCIATED_TOKEN_PROGRAM_ID;\n  if (!allowOwnerOffCurve && !web3_js_1.PublicKey.isOnCurve(owner.toBuffer())) throw new errors_js_1.TokenOwnerOffCurveError();\n  var _web3_js_1$PublicKey$ = web3_js_1.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId),\n    _web3_js_1$PublicKey$2 = _slicedToArray(_web3_js_1$PublicKey$, 1),\n    address = _web3_js_1$PublicKey$2[0];\n  return address;\n}\nexports.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;","map":{"version":3,"mappings":"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","names":["exports","span","getMint","connection","address","commitment","programId","constants_js_1","getAccountInfo","info","unpackMint","errors_js_1","owner","equals","data","length","rawMint","decode","slice","tlvData","Buffer","alloc","account_js_1","multisig_js_1","accountType_js_1","Mint","mintAuthority","mintAuthorityOption","supply","decimals","isInitialized","freezeAuthority","freezeAuthorityOption","getMinimumBalanceForRentExemptMint","getMinimumBalanceForRentExemptMintWithExtensions","extensions","mintLen","getMinimumBalanceForRentExemption","getAssociatedTokenAddress","mint","allowOwnerOffCurve","associatedTokenProgramId","web3_js_1","isOnCurve","toBuffer","findProgramAddress","getAssociatedTokenAddressSync","findProgramAddressSync"],"sources":["/Users/ivan/Metadata/node_modules/@solana/spl-token/src/state/mint.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport type { AccountInfo, Commitment, Connection } from '@solana/web3.js';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenInvalidMintError,\n    TokenOwnerOffCurveError,\n} from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport type { ExtensionType } from '../extensions/extensionType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n    /** Additional data for extension */\n    tlvData: Buffer;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address: PublicKey, info: AccountInfo<Buffer> | null, programId = TOKEN_PROGRAM_ID): Mint {\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint) throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(\n    connection: Connection,\n    extensions: ExtensionType[],\n    commitment?: Commitment\n): Promise<number> {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId\n    );\n\n    return address;\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): PublicKey {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = PublicKey.findProgramAddressSync(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId\n    );\n\n    return address;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}